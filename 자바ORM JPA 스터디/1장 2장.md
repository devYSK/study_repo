

# JPA

JPA는 Java Persistence API의 줄임말로서, ORM(Object-Relational Mapping, 객체-관계형 매핑) 프레임 워크이다.

JPA는 자바 진영의 ORM 기술 표준이다 

JPA는 자바 애플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스이며,

이 인터페이스를 구현한 구현체가 우리가 흔히 사용하는 하이버네이트(hibernate)이다.

또한 JPA 인터페이스를 구현한 구현체는 OpenJPA, EclipseLink, ToLink 등과 같은 구현체가 있다. 

JPA는 특정 기능을 하는 라이브러리가 아니고, 자바 어플리케이션에서 관계형 데이터 베이스를 어떻게 사용해야 하는지 정의하는 한 방법일 뿐이다.



ORM은 RDB를 객체지향적으로 사용하기 위한 기술이다. 관계형 데이터베이스로 정의된 데이터들을 객체로 맵핑해준다고 생각하면 된다.

RDB 테이블은 객체지향적 특징인 상속, 다형성, 레퍼런스, 객체 등이 없고 자바와 같은 언어로 접근하기 쉽지 않다.

때문에 ORM 기술을 사용해 오브젝트와 RDB 사이에 존재하는 개념과 접근을 객체지향적으로 좀더 쉽게 다루기 위한 기술이다. 





JPA 는 명세이면서 인터페이스 이기 때문에 구현이 없다. 

JPA를 정의한 javax.persistence 패키지는 대부분 interface, enum, annotation, Exception으로 이루어져 있다.

* https://docs.oracle.com/javaee/7/api/javax/persistence/package-summary.html





JPA는 지루하고 반복적인 간단한 CRUD SQL을 알아서 처리해준다.

* 다만 복잡한 쿼리같은 경우 native SQL을 사용하거나 querydsl 등을 사용해서 문제를 해결한다.

객체지향적으로 데이터를 관리할 수 있기 때문에 비즈니스 로직에 집중 할 수 있으며, 객체지향 개발이 가능하다.

테이블 생성, 변경, 관리가 쉽다. (JPA를 잘 이해하고 있는 경우)

로직을 쿼리에 집중하기 보다는 객체자체에 집중 할 수 있다.

빠른 개발이 가능하며 유지보수가 쉬워진다.



## SQL을 직접 다룰 때 발생하는 문제점

![image-20220830003428406](/Users/ysk/study/study_repo/자바ORM JPA 스터디/images//image-20220830003428406.png)

* 애플리케이션을 만들라면 프로그래밍 언어를, 관계형데이터베이스를 다루어서 데이터를 이용할라면 SQL을 사용해야 한다.



기존 JDBC API를 사용하면 String타입으로  SQL을 작성해야하지, (오타가 나서 오류나는 경우 많음)

try-catch-finally로 커넥션 객체를 열었다 닫아줘야하지,

SQL을 실행한 다음, 결과를 담은 ResultSet 객체에서 하나하나꺼내서 객체에 매핑 시켜줘야 한다.

정말 간단한, join도 없고 where문도 복잡하지 않은 단순한 CRUD 기능을 우리는 매번 반복해서 작성해야 한다.

 실제로 하나하나 기능 구현을 하다보면 너무나도 SQL에 의존적이며 많은 코드가 나오게 된다.

시간을 공들여서 기능을 개발했더니 수정 요구사항이 들어오면 너무나도 많은 부분을 바꿔야 한다. JSP 처럼



## JPA와 문제해결

JPA를 사용하면 객체를 데이터베이스에 저장하고, 관리할 때 개발자가 직접 SQL을 작성하는것이 아니라 JPA가 제공하는 API를 사용하면 된다.

* 모든 쿼리들이 그런것은 아니고, 대부분 간단한 기능들은 쉽게 해결할 수 있다는 것이다.



여기서 나오는 jpa는 EntityManager의 객체 이름이다. 

- 저장 기능 - insert

  - ```java
    jpa.persist(Object); // 저장 
    ```

- 조회 기능 - select

  - ```java
    jpa.find(Member.class, memberId); // 조회. 멤버 아이디로 멤버 객체를 찾아오라는 것으로 해석된다. 
    ```

- 수정 기능 - update

  - ```java
    Member member = jpa.find(Member.class, memberId);
    member.setName("변경할 값"); // 수정. 객체를 찾은 다음 이름만 바꿔주면 된다. 물론 바뀌는데 조건도 있다-  트랜잭션
    ```

- 연관된 객체 조회 - select , join

  - ```java
    Member member = jpa.find(Member.class, memberId);
    Team team = member.getTeam(); // 연관된 객체 조회
    ```

  - Member와 Team이 연관 관계가 맺어져 있고, Member class 안에 Team이 정의되어 있을 때 연관된 객체 조회 가능



## 패러다임의 불일치

객체지향 프로그래밍은 `추상화`, `정보은닉(캡슐화)`, `상속`, `다형성` 등 다양한 개발 방법을 제공한다.

비즈니스 요구사항을 정의하여, 비즈니스 로직이 있는 도메인 모델도 객체로 모델링하면 훨씬 쉽고 코드가 깔끔하게 데이터를 다룰 수 있다.

* '도메인'은 해결하고자 하는 문제 영역이라고 할 수 있다. 현실세계의 어떠한 문제를 도메인이라는 모델로 구조화 한것 
* 단순히 클래스 다이어그램이나 엔티티가 아니다. 

문제는 이렇게 정의한 도메인 모델을  데이터베이스에 저장할때 발생한다. 

관계형 데이터 베이스에 객체를 저장하는 것인데, 

관계형 데이터베이스는 데이터 중심으로 구조화 되어 있어서 데이터만 저장하면 되는 곳인데 

객체는 필드(속성)와 메서드(기능), 상속, 다형성, 추상화 등이 구현되어있다.

자바 언어로 만든 다양한 데이터들을, SQL 언어를 이용한 데이터베이스랑은 지향하는 목적 자체가 다르므로 

기능과 표현 방법이 아예 다르기 때문에 문제가 발생하는 것이다. 

객체 구조 자체를 테이블에 저장할 수가 없다

이것이 객체지향 언어와 관계형 데이터베이스의 패러다임의 불일치 라고 할 수 있다.



패러다임의 불일치로 인해 발생하는 문제들은 다음과 같다

### 상속

객체지향 언어는 상속이라는 개념과 기능을 가지고 있지만 테이블은 상속이란 개념이 없다.

* 상속 : 부모의 것을 자식이 물려받아 사용하는것
* postgres같은 데이터베이스는 지원하는 경우가 있지만, 대부분의 관계형 데이터베이스는 상속을 지원하지 않고 객체의 상속과는 약간 다르다. 

![image-20220830005244173](/Users/ysk/study/study_repo/자바ORM JPA 스터디/images//image-20220830005244173.png)

* 이그림은 객체 상속 모델을 다이어그램으로 그린 것.
* Item이라는 큰 틀로 추상화하고 자식들이 상속받았다고 할 수 있다.

---

![image-20220830005356660](/Users/ysk/study/study_repo/자바ORM JPA 스터디/images//image-20220830005356660.png)

* 이 그림은 관계형 데이터베이스를 슈퍼타입 / 서브타입 관계를 사용해서 그나마 객체 상속과 유사한 형태로 테이블로 만든것

  * #### 슈퍼/서브 타입 데이터 모델 : Extended ER모델이라고도 부른다

    * 공통 부분을 슈퍼타입으로 모델링하고, 공통부분으로부터 상속받아 다른 엔티티와 차이가 있는 속성에 대해서는 별도의 서브엔티티(서브 테이블)로 구분하여 업무의 모습을 정확하게 표현하면서 물리적인 데이터 모델로 변환을 할 때 선택의 폭을 넓힌 것

  *  즉 슈퍼타입(전체를 하나의 테이블로 관리)에 정의된 **공통 속성과 각 서브타입의 속성을 더하여 각각의 서브타입별로 테이블을 설계**하는 방법



* JDBC API를 사용해서 자식 객체들을(여기서는 ALBUM, MOVIE, BOOK) 저장하려면 비용이 만만치 않다.
  * 일단 모든 자식들이 부모 ID를 참조하여 식별관계(외래키가 자기의 PK)로 만들어져 있기 때문에 부모 데이터만 꺼내서 부모 데이터 INSERT 기능 만들고, 자식 객체에서 자식 데이터만 꺼내서 또 INSERT 해야한다
  * 코드량이 어마어마하다 SQL부터 작성하고 쿼리 날려서 결과 받아온 다음 ResultSet 객체를 다시 하나하나 맵핑해야 하고.  



* 이런 과정들이 모두 객체지향과 관계형 데이터베이스의 패러다임의 불일치를 해결하려고 소모하는 비용이다.
  * 곰곰히 생각해보면 진짜 너무 비싸다. 막말로 노가다라고 표현할 수 있는데 이 시간들이 진짜 어마어마 하다.



JPA는 해당 자식 객체들을 데이터베이스가 아닌 자바 컬렉션에 보관해서 추가하면 너무 쉬워진다

```java
부모객체.getAlbums().add(album);
부모객체.getMovies().add(movie);
```

* 트랜잭션 내에서 insert하고 후에 배우는 persist하게 되면 실제로 데이터베이스에 반영되어 insert된다

 

## 연관관계

객체는 참조를 사용해서(다른 엔티티를 필드로 보관. 연관관계) 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다.

반면에 테이블은 외래키를 사용해서 다른 테이블과 연관관게를 가지고 조인을 사용해서 연관된 테이블을 조회한다.



![image-20220830010333725](/Users/ysk/study/study_repo/자바ORM JPA 스터디/images//image-20220830010333725.png)



* 그림을 보면, 테이블 연관관계에서는 외래키를 보관해서 이 외래키를 이용해서 조인해서 TEAM 객체를 찾아오거나 Member 객체를 찾는다
* 하지만 객체 연관관계에서는 그냥 자신의 멤버변수인 team을 호출해서 찾을 수 있다. 

* 반면 이그림에서의 객체 연관관계에서는, 단방향 연관관계이기 때문에(Member->team) 
  * member.getTeam()은 가능하지만, team.getMember()는 불가능하다



### JPA와 연관관계

JPA없이 member와 Team을 저장하려고 할때 SQL과 JDBC API나 MyBatis를 이용해서 저장하게 된다면 아주 많은 코드가 들어가지만, JPA는 다음과 같이 두줄로 해결할 수 있다.

```java
member.setTeam(team); // 회원과 팀 연관관계 설정
jpa.persist(member); // 회원과 팀(연관관계)을 같이 저장. 
```



개발자는 코드에서 처럼 연관관계를 설정하고 member객체만 저장하면 된다 .

JPA가 알아서 team의 참조를 외래키로 변환해서 적절한 insert sql을 사용해서 데이터베이스에 전달한다.



반대로 객체를 조회할 때 외래키를 참조로 변환하는 일도 JPA가 처리해준다

```java
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam();
```

member와 필드로서 연관관계를 맺은 team은 그냥 getTeam() 메서드로 호출해서 조회할 수 있다.

하지만 이런 연관관계도 극복하기 어려운 문제들이 있다. 다음 패러다임의 불일치 문제들을 보자.



## 객체 그래프 탐색

객체에서 member가 소속된 team을 조회할 때는 다음처럼 참조를 사용해서 연관된 팀을 찾으면 된다.

참조를 사용해서 연관된 객체를 조회하는 것을 `객체 그래프 탐색` 이라고 한다

```java
Team team = member.getTeam(); // 객체 그래프 탐색.
```



* 다음 그림처럼 관계가 설계되어 있다고 가정해보자

![image-20220830011140356](/Users/ysk/study/study_repo/자바ORM JPA 스터디/images//image-20220830011140356.png)

* 벌써 그림부터 복잡하다

* member가 주문한 item을 찾고싶다면 ..?
  * member.getOrder().getOrderItem();
* 예를 들어 member 객체를 조회할 때 Member와 team만 조인하는 SQL을 실행해서 member와 team에 대한 데이터만 조회했다면 member.getTeam()은 가능하지만 , member.getOrder()는 불가능하다.
  * 당연하다. member와 order, orderItem은 같이 조인하지 않았으니까.
* SQL을 직접 다루면 처음 실행하는 SQL에 따라 그래프를 어디까지 탐색할 수 있는지 정해져 버린다.
  * 이말이 무슨말이냐 하면, sql을 직접 써서 조회한 쿼리로서는 조회한 만큼만 가져올 수 밖에 없단 이야기다. 
  * 위 예시대로 한번에 다 조인을 안하고 member와 team만 조인하면 두 데이터만 가져오지 order와 orderItem은 가져오지 않으니까 member와 team 까지만으로 그래프를 탐색할 수 있는 범위가 정해진 것이다. 
* 이것이 객체지향 개발자한테 너무나 큰 제약인것도 같은 의미이다.
  * 코드만 보고서는 team까지 가져올 수 있을지, 아니면 저 멀리 order와 orderItem, item 까지 가져올 수 있는지는 알 수 없다.
  * DAO(데이터 접근 계층, 쿼리가 작성되어있고 DB와 연동하는 곳)를 열어서 SQL을 직접 확인하기 전 까진 알 수 없다.
    * 쿼리가 join 1번만 한건지 2번 3번 4번 해서 다 가져오는지는 알 수가 없으니까..
    * 이것도 결국 비용이 되는것이다.
* 그렇다고 모든 연관된 테이블들과 조회해서 매번 애플리케이션에 불러와 메모리에 올려두고 사용하는것도 매우 비효율적이다
  * 그나마 현실적인게 메서드를 각각 네이밍도 다르게 짓고 SQL도 다르게 해서 사용해야 한다.
  * 이것도 또 비용인것이다



### 하지만 JPA를 사용하면 다르다

JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있다.

* 쿼리 작성할 필요가 없고, 연관관계가 있다면 이 SELECT를 호출했을 때 어디까지 쓸 수 있는지 알아볼 필요가 없다.

* member.getOrder().getOrderItem()... 쭉쭉쭉
* 참조하는 연관된 객체(테이블)를 사용하는 시점에 그 시점마다 알아서 SQL을 날려주고 조회해와 주는 것이다.
* 실제 객체에 접근해서 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 `지연로딩 Lazy Loading` 이라고 한다

```java
// 처음 조회 시점에는 SELECT MEMBER SQL
Member member = jpa.find(Member.class, memberId);

Order order = member.getOrder();
order.getOrderDate(); // Order를 사용하는 시점에 JPA가 알아서 SELECT Order SQL을 날려서 조회해온다. - 지연로딩
```

* 이렇게 둘이 따로따로 쿼리 2방을 날려서 조회하는 것보다, member와 order를 같이 조회해야 하는 기능이 필요하다면 Join을 사용해서 조회해서 가져오는게 효과적이다.
* JPA는 연관된 객체를 `즉시 함께 JOIN해서 조회할지(EAGER)` 
* 아니면 실제 사용되는 시점에 `쿼리를 한방더 날려서 총 2방으로 조회 해올지(LAZY)`를 간단하게 설정할 수 있다.



## 비교 (==) 같은지 다른지

데이터베이스는 기본 키 값으로 각 row(로우)를 구분한다.

반면에 객체는 `동일성(identity)` 비교와 `동등성(equality)` 비교라는 두가지 방법을 사용해서 비교한다

* 동일성 비교는 `obj1 == obj2` 객체 인스턴스의 주솟값 비교. 같은 주소를 참조하는지. 같으면 true 다르면 false
* 동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교하는것. 주소는 달라도 내부 값이 같으면 같은걸로 치는 둥
  * 물론 값이 여러개라면 equals() 메서드는 오버라이딩을 해야한다.
  * 오버라이딩 안한 Object의 기본 equals() 메서드는 기본적으로 == 비교를 한다 



JPA를 사용 안하고 DAO등으로 같은 기본키 (pk) 값으로 조회해온 두 객체를 `동일성 ==`으로 비교하면 false가 반환된다.

*  왜? 둘이 주소가 다르니까. ==비교는 주소 비교다. 값은 같아도 둘 인스턴스는 다른 인스턴스이고 생성된 주소가 다르다.

* 그러나 객체를 컬렉션에 보관하면 동일성 비교에 성공한다

```java
Member member1 = list.get(0);
Member member2 = list.get(0);

member1 == member2; // true. 같다
```

리스트가 참조하는 같은 주소의 인스턴스를 == 비교 하는거니까 같은것이다.

데이터베이스의 같은 로우를 조회할 때마다 같은 인스턴스를 반환하도록 구현하는 것은 쉽지 않다.

### 하지만 JPA의 비교 다르다.

JPA는 `같은 트랜잭션` 일 때 같은 객체가 조회되는 것을 보장한다.

그러므로 다음 코드에서는 동일성 비교가 성공한다

```java
Member member1 = jpa.find(Member.class, 1L);
Member mebmer2 = jpa.find(Member.class, 1L);
```

* 위에서 설명한 오버라이딩 안한 기본 Object 클래스의 equals 메서드를 사용해도 같다고 나온다. (오버라이딩 안하면 ==비교니까)
* 뒷장에 나오는 영속성 컨텍스트와 연관이 있다. 
  * 반드시 트랜잭션을 명심하자! 



## JPA란 무엇인가? 

















