# Spring Transaction















# 트랜잭션관리

트랜잭션 관리는 크게 2가지가 있다.

1. dataSource의 `Conection`  객체를 받아 트랜잭션 관리 
2. @Transaction` 어노테이션을 이용한 선언적 트랜잭션 관리



## 프로그래밍 방식 트랜잭션 관리



```java
import java.sql.Connection;
import javax.sql.DataSource;

private DataSource datasource;

public void method() {
  Conection con = dataSource.getConnection();
  
  try {
    connection.setAutoCommit(false);
    
    // 로직 시작
    
    // 로직 종료
    
    connection.commit();
    
  } catch (Exception e) {
    connection.rollback();
  }
  
}
```



1. 설정한 DataSource 기반으로 connection 객체를 얻는다
2. setAutoCommit(false)로 설정
   * auto-commit 을 disabled 한 상태에서 명시적으로 commit/rollback 을 호출하지 않으면 자동으로 commit
   * [오라클 문서](https://docs.oracle.com/cd/B10500_01/java.920/a96654/basic.htm#1019368)
   * PreparedStatement의 특성상, 자동으로 commit이 이루어 지는데 각각을 따로 commit/rollback 할 수 있게 설정
   * 커밋과 롤백의 제어를 자동이 아닌 클라이언트(개발자)가 설정 

3. 예외 발생 안하면 commit, 예외 발생시 rollback;

<br>

* 선언적 트랜잭션 (@transactional)과 유사한 형식 

```java
@Transactional(readOnly = true, isolation = Isolation.READ_COMMITTED)

// 위 코드와 아래가 같다

Connection connection = dataSource.getConnection();

//readOnly = true
connection.setReadOnly(true);

//isolation = Isolation.READ_COMMITTED
connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
```



JDBC의 connection을 이용한 Transaction isolation, readOnly 등 다양한 옵션을 하는데처리를 하는데, 

스프링에서는 직접 JDBC와 같은 코드를 대신 편리하게 사용할 수 있도록 다양한 방법을 제공

-> `@Transactional`





* 스프링은 프로그래밍 방식 트랜잭션 관리를 편하게 도와준다

```java
@Service
public class MemberService {

    private final TransactionTemplate template;

    private final PlatformTransactionManager platformTransactionManager;

    public void createMember(Member member) {
        template.execute(status ->  {
            // SQL, 로직 실행
            
            return ...;
        });
    }
}
```

## 선언적 트랜잭션 관리

선언적 트랜잭션 : `@Transactional` 어노테이션.

<br>

AOP를 이용하여  선언적 트랜잭션을 사용할 수 있다.

```java
//트랜잭션 시작
{
	로직();
// 커밋 또는 롤백
}
```



### 어떻게 AOP를 이용하여 트랜잭션을 사용하는가?

![image-20220906020336881](/Users/ysk/study/study_repo/spring/transaction/images//image-20220906020336881.png)

* Spring AOP의 proxy를 이용한다. 



## Proxy

* Proxy는 대리업무를 수행하는 시스템이나 응용프로그램

  * 즉 JDBC 방식의 복잡한 Transaction 과정을 대신 간단하게 처리해주는것.

* #### 프록시 패턴을 사용하는 이유 ?

  * 프록시 객체는 원래 객체를 감싸고 있는 객체로, 원래 객체와 타입은 동일하다. 

    * 원래 객체를 상속받아 프록시 객체를 만든다. 

  * 프록시 객체가 원래 객체를 감싸서 client의 요청을 처리하게 하는 패턴이다.

    - 접근 권한을 부여할 수 있다

    - 부가 기능을 추가할 수 있다

# IoC 컨테이너와 AOP Proxy

`Spring`에는 크게 두 가지 프록시 구현체를 사용한다.

1.  `JDK PROXY(=Dynamic PROXY)`  
2. `CGLib` 



* `Spring AOP`는 PROXY의 매커니즘을 기반으로 AOP PROXY를 제공하고 있다.

* 상황에 따라 `JDK Proxy`와 `CGLib`방식을 통해 `Proxy Bean`을 생성해준다.

### Weaving

Aspect가 지정된 객체를 새로운 프록시 객체를 생성하는 과정.

3가지 방법이 존재한다.

1. 컴파일시에 Weaving하기
2. 클래스 로딩 시에 Weaving하기
3. 런타임시에 Weaving하기



* 일반적으로 1,2번째 방법은 AspectJ라이브러리를 추가해 구현할때 사용된다.

* 스프링AOP에서 사용하는 방식은 `Runtime Weaving을 통해 프록시를 생성`한다.

* 소스코드나 클래스 정보자체를 변경하지 않는다.
* 프록시 기반의 AOP는 핵심로직을 구현할 객체에 직접 접근하는것이 아니라, 아래 그림과 같이 중간에 프록시를 생성, 프록시를 통해 