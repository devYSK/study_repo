# 코루틴(coroutine)

코루틴이란?



Coroutine은 Co + routine 2개가 합쳐진 단어다. 이 단어들의 뜻은 각각 아래와 같다.

> Co : 함께, 서로, 동시에
> routine : 규칙적으로 하는 일의 통상적인 순서나 방법, 일반적으로 빈번히 사용할 수 있는 프로그램 또는 그 일부

코루틴은 코틀린만의 것이 아니다. 이름이 비슷해서 코틀린의 것이라고 생각할 수 있지만 파이썬, C#, Go, Javascript 등 여러 언어에서 지원하고 있는 개념입니다. 

즉, 동시성 프로그래밍 개념을 코틀린에 도입한 것이 코투린 이라고 합니다.

코루틴은 코루틴이 시작된 스레드를 중단하지 않으면서 비동기적으로 실행되는 코드입니다.

코루틴은 비동기 프로그래밍을 지원하는데 유용합니다. 예를 들어, 네트워크 연결을 통해 데이터를 가져오는 작업을 수행하면서 다른 작업을 수행할 수 있도록 해주는 것이 바로 코루틴입니다. 이러한 방식으로 코루틴은 다중 작업(multitasking)을 가능하게 하며, 다른 비동기 작업과 함께 동작할 수 있습니다.



> [위키피디아 코루틴](https://en.wikipedia.org/wiki/Coroutine)
>
> **코루틴은 실행을 일시 중단하고 재개할 수 있도록 해서 비선점형 멀티태스킹을 위한 서브 루틴을 일반화하는 컴퓨터 프로그램 구성 요소**다. 코루틴은 협력 작업, 예외, 이벤트 루프, 반복자, 무한 목록 및 파이프와 같은 친숙한 프로그램 구성 요소를 구현하는 데 적합하다.
> 서브루틴은 코루틴의 특수한 경우다. 
>
> 서브루틴이 호출되면 시작하고 종료되면 서브루틴도 종료된다. 서브루틴의 인스턴스는 한 번만 반환하고 호출 사이에 상태를 유지하지 않는다. 대조적으로 **코루틴은 다른 코루틴을 호출해 종료할 수 있으며 나중에 원래 코루틴에서 호출된 지점으로 돌아갈 수 있다. 코루틴의 관점에서 보면 종료되는 게 아니라 다른 코루틴을 호출하는 것이다. 따라서 코루틴 인스턴스는 상태를 유지하고 호출마다 다르다. 한 번에 주어진 코루틴의 여러 인스턴스가 있을 수 있다.** 다른 코루틴에 "양보"해서 다른 코루틴을 호출하는 것과 단순히 다른 루틴을 호출하는 것(그러면 원래 지점으로 돌아감)의 차이는 서로에게 양보하는 두 코루틴 간의 관계가 호출자의 관계가 아니란 것이다
>
> **코루틴은 쓰레드와 매우 유사하다. 그러나 코루틴은 협력적으로 멀티태스킹되는 반면 쓰레드는 일반적으로 선점형으로 멀티태스킹된다. 코루틴은 동시성을 제공하지만 병렬성은 제공하지 않는다.** 쓰레드에 비해 코루틴의 장점은 실시간 컨텍스트에서 사용할 수 있다는 것이다(코루틴 간 전환에는 시스템 호출이나 차단 호출이 불필요함) 뮤텍스, 세마포어 등과 같은 동기화 기본 요소가 불필요하다. 크리티컬 섹션을 보호하기 위해 OS 지원이 필요하지 않다. 호출 코드에 투명하게 미리 예약된 쓰레드를 써서 코루틴을 구현하는 게 가능하지만 일부 이점(실시간 작업에 대한 적합성과 이들 간의 전환이 상대적으로 저렴함)이 손실된다

일반 쓰레드보다 경량 쓰레드라는 점에서 속도 면에서 우월하다는 장점을 가지고 있다.





## 코루틴의 간단한 예시

#### 스레드의 종류에는 3가지가 있습니다.

코루틴에서는 아래와 같이 3가지 스레드를 선언하고, 동기는 launch, 비동기는 async로 표현합니다.

1. Main : 메인 스레드, 화면 ui 작업 등을 하는 곳
2. IO : 네트워크, DB 등 백그라운드에서 필요한 작업을 하는 곳
3. Default : 정렬이나 무거운 계산 작업 등을 하는 곳



다음과 같이 선언해서 사용가능하다

```kotlin
CorutinScope(Dispatchers.쓰레드종류).동기/비동기 {
```

#### 동기 / 비동기

1. launch : 동기

```
CoroutineScope(Dispatchers.Main).launch{
}
```

2. async : 비동기

```kotlin
//example : I0스레드를 비동기처리한다.
CoroutineScope(Dispatchers.IO).async { }
```





코루틴의 장점으로는 다음과 같은 것들이 있습니다.

1. 메모리 사용량이 적습니다. 코루틴은 일반적인 스레드처럼 많은 메모리를 필요로 하지 않습니다.
2. 코루틴은 다른 작업과 함께 동작할 수 있습니다. 이는 비동기 작업을 수행하면서 다른 작업을 동시에 수행할 수 있도록 해주어 프로그램의 성능을 향상시킬 수 있습니다.
3. 코루틴은 더 높은 수준의 추상화를 제공합니다. 이는 프로그래밍의 복잡도를 낮추고 코드의 가독성을 높일 수 있습니다.

코루틴의 단점으로는 다음과 같은 것들이 있습니다.

1. 코루틴은 일반적으로 스레드보다 느립니다. 이는 코루틴이 단일 스레드에서 실행되는 반면, 스레드는 여러 개의 코어를 사용하여 병렬로 실행될 수 있기 때문입니다.
2. 코루틴은 동시에 실행되는 코드 블록의 수를 제한합니다. 이는 코루틴이 오버헤드를 줄이기 위해 한 번에 동시에 실행할 수 있는 코드 블록 수를 제한하기 때문입니다.

코루틴은 비동기 프로그래밍을 지원하고 다중 작업을 가능하게 하며, 메모리 사용량이 적고 높은 수준의 추상화를 제공합니다. 하지만 일반적으로 스레드보다 느리며, 동시에 실행되는 코드 블록의 수를 제한합니다. 따라서, 코루