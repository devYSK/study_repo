# 공변, 무공변, 반공변



변성(가변성, variance)은 **타입의 계층 관계(Type Hierarchy)에서 서로 다른 타입 간에 어떤 관계가 있는지**를 나타내는 개념.

제네릭(Generic)을 사용하는 클래스나 인터페이스가 타입 매개변수를 어떻게 다룰 것인지 지정할 수 있도록 해주는 개념이기도 합니다.

* 코틀린에서는 `out`, `in` 키워드로 명시하며, 자바에서는 `? extends`, `? super` 와일드카드로 표현합니다.



**공변(Covariance)**: `Producer<T>`가 `Producer<부모타입>`과 같은 맥락으로 취급될 수 있는가?

- “자식 제네릭”을 “부모 제네릭”에 대입해도 안전한가?
- 공변성이란, 상위 타입으로 형변환이 가능하도록 허용하는 것
- “리스트를 오직 원소를 **읽기**만 한다”는 관점으로 보면, 원소 타입의 상하위 관계가 그대로 리스트(혹은 컬렉션) 타입에도 적용될 수 있습니다.
- “리턴 위치”의 타입 매개변수일 때 주로 공변적으로 설계가 가능합니다. 즉 밖으로 내보내는(Output) 역할을 하는 타입 파라미터가 공변적이라는 뜻

**반공변(Contravariance)**: `Consumer<T>`가 `Consumer<자식타입>`과 같은 맥락으로 취급될 수 있는가?

- “부모 제네릭”을 “자식 제네릭”에 대입해도 안전한가?
- 반공변성이란, 하위타입으로 형변환이 가능하도록 허용하는 것. 
- 함수를 예로 들면, 함수의 **입력 파라미터 위치**의 타입 매개변수는 반공변으로 설계될 수 있습니다. 왜냐하면 “호출할 때 ‘더 상위’ 타입도 받을 수 있어야” 하므로, 함수 파라미터의 타입이 더 상위 타입을 허용해야 하기 때문입니다.

**무공변(Invariance)**: `Box<T>`가 `Box<S>`와 다른 타입으로 취급된다면?

- 타입 A와 B 사이에 서브타입 관계가 있더라도  둘이 전혀 호환되지 않는 경우.
- 예를 들어, `List<String>`은 `List<Any>`로 볼 수 없고, `List<Any>`는 `List<String>`로 볼 수 없습니다.

## 가변성이 왜 필요한가?

**“상속 관계를 활용해 한 층 더 유연하게 코드를 재사용하되, 안정성(런타임 타입 오류)을 최대한 컴파일 시점에 막기 위해서”** 가변성 개념이 필요합니다.



**타입 안전성**과 **유연성**을 조화롭게 보장하기 위해, 제네릭 클래스나 인터페이스에서 입력, 출력 위치에 사용되는 타입 매개변수가 공변인지, 반공변인지, 무공변인지를 정하는 것은 중요합니다.

- “이 객체(컬렉션이나 함수 등)는 내부 요소를 읽기만 하나?” 혹은
- “이 객체는 내부에 요소(타입)를 밀어 넣기만 하나?”
- “이 객체는 내부 요소를 읽기도, 쓰기도 하나?”

이런 사용 패턴에 따라, **해당 타입 매개변수를 공변으로 설계해야 할지, 반공변으로 설계해야 할지, 혹은 무공변으로 두어야 할지** 결정됩니다.



## 자바에서의 가변성

자바에서는 wildcard(?)를 사용해 제네릭 파라미터의 가변성을 표현합니다.

- `? extends Type`: 공변(Covariance)을 표현합니다.
  - 상속 관계에서 `? extends Type`은 `Type`의 하위 클래스를 담을 수 있음을 의미합니다.
  - 읽기는 안전하지만, 쓰기는 불가능(혹은 제한적)하다는 특징이 있습니다.
- `? super Type`: 반공변(Contravariance)을 표현합니다.
  - 상속 관계에서 `? super Type`은 `Type`의 상위 클래스를 담을 수 있음을 의미합니다.
  - 쓰기는 안전하지만, 읽기는 `Object` 타입으로만 안전하게 처리할 수 있습니다.

자바에서는 기본적으로 제네릭 타입은 **무공변**으로 동작합니다.

```java
List<String> strList = new ArrayList<>();
// List<Object> objList = strList; // 컴파일 오류! 
```

## 코틀린(Kotlin)에서의 가변성

코틀린에서는 자바와 달리 `out`, `in` 키워드를 제네릭 클래스 선언 시(혹은 사용 시) 명시해 공변성, 반공변성을 설정할 수 있습니다.

`out T`: 공변(Covariance)을 나타냅니다.

- `T`를 **“생산(Producer)”**하는 입장이라면 `out`을 사용합니다.
- 반대로, `T`를 매개변수로 받는(“소비자”) 함수 파라미터로는 사용할 수 없습니다(제한됨).

* 즉, 외부에 값을 **내보내는**(생산하는) 방향으로만 사용이 가능합니다.

  함수의 리턴 타입으로는 가능하지만, 함수의 매개변수 타입으로는 사용할 수 없습니다.

* 상위 타입으로 변환 가능.

```kotlin
open class Fruit(val name: String)
class Apple : Fruit("Apple")
class Banana : Fruit("Banana")

class Box<out T>(
    private val item: T
) { // `out` 사용 (생산)
    fun getItem(): T = item // ✅ 아이템을 꺼낼 수 있음
    fun setItem(newItem: T) { // ❌ 컴파일 에러
        item = newItem
    }
}

val appleBox: Box<Apple> = Box(Apple()) // ✅ Box2<Apple> 생성
val fruitBox: Box<Fruit> = appleBox // ✅ Box2<Apple>을 Box2<Fruit>로 사용

fruitBox.setItem(Banana()) // ❌ Apple 박스에 Banana를 넣으려 해서 타입 충돌!

```

- `out T` → **생산자(Producer) 역할** 즉, `T`는 **꺼내는 것만 가능** 하고 **새로운 값을 넣는 것은 허용되지 않음**.

* `Box2<Apple>`을 `Box2<Fruit>`으로 사용할 수 있도록 허용했기 때문에,

  만약 `setItem()`이 가능하다면, `Box2<Apple>`인데 `Banana`를 넣을 수도 있음.

  하지만 `Apple` 박스에 `Banana`가 들어가는 건 **타입 불일치 오류** 이므로 막는것.



`in T`: 반공변(Contravariance)을 나타냅니다.

- `T`를 **“소비(Consumer)”**하는 입장이라면 `in`을 사용합니다.
- 반대로, 반환값으로 `T`를 사용하면(“생산”) 제한됩니다.
- 즉, 외부에서 값을 **받아들이는**(소비하는) 방향으로만 사용이 가능합니다.
- 함수의 파라미터 타입으로는 가능하지만, 함수의 반환 타입으로는 사용할 수 없습니다.

* 반공변성이 걸린 타입 파라미터는 **쓰기 전용**이라고 이해할 수 있습니다.
* * **“반공변(in)은 서브타입 관계를 반대로 뒤집어서, 자식 제네릭 타입을 부모 제네릭 타입에 대입할 수 있게 해주는 것”**

```kotlin

class Box<in T> { // `in` 사용 (소비)
    private var item: T? = null

    fun putItem(item: T) { // ✅ 아이템을 넣을 수 있음
        println("${item}을(를) 박스에 넣음")
        this.item = item
    }

    fun getItem(): T { // ❌ 컴파일 에러
        return item
    }
}

val fruitBox: Box<Fruit> = Box<Apple>() // ✅ Box<Apple>을 Box<Fruit>으로 사용할 수 있음
val fruit: Fruit = fruitBox.getItem() // ❌ 그런데 Apple을 반환하려는데 타입이 Fruit이라 위험
```

* `Box<Apple>`을 `Box<Fruit>`으로 캐스팅할 수 있도록 허용했기 때문에,

  만약 `getItem()`을 허용하면, `Box<Fruit>`에서 `Apple`을 꺼내는 게 가능해짐.

* 하지만, **실제로는 `Box<Fruit>` 이므로 `Banana`도 넣을 수 있어야 함!**

  `Banana`를 넣고, `Apple`을 꺼내려 하면 **타입 불일치 오류가 발생**할 수 있기 때문에 막는 것.



- 무공변 : out, in이 붙지 않은 경우.
  - 기본적으로는 `MyClass<A>`와 `MyClass<B>`는 무공변 관계입니다.\
  - 상속 관계가 없는 타입. 



**Apple을 Fruit로 바꾸는 것은 업캐스팅**(OOP 상속 관점)

제네릭에서 “서브타입 관계가 같은 방향으로 유지되면” → “공변성(covariance)”

반대로 뒤집히면(자식이 부모 제네릭보다 상위) → “반공변성(contravariance)”



### 선언 지점 변성(Declaration-site Variance) vs 사용 지점 변성(Use-site Variance)

**선언 지점 변성(Declaration-site Variance)**: 클래스나 인터페이스를 정의할 때, 제네릭 타입 파라미터에 `out`이나 `in`을 직접 선언해두는 것.

- 예: `interface Producer<out T>`, `interface Consumer<in T>`



**사용 지점 변성(Use-site Variance)**: 제네릭 클래스를 사용할 때, 특정한 매개변수 위치에서만 `out` 또는 `in`을 지정하는 것.

- 예: 함수 호출 시점 등에 `Array<out T>` 형식으로 사용



**선언 지점 변성**과 **사용 지점 변성**은 보완적인 개념으로, 라이브러리를 설계하는 측에서는 “선언 지점 변성”을 활용해 제네릭의 용도를 명확히 하고, 사용자 측에서는 “사용 지점 변성”을 통해 특정 상황에서만 변성을 적용할 수 있습니다.

## 면접에서의 질문 예시

### 4.1 자바 관련

1. **“자바에서 제네릭 타입은 기본적으로 공변인가요, 무공변인가요?”**
   - 답: 자바의 제네릭은 무공변이다. `? extends` 혹은 `? super` 와일드카드로 명시적인 공변/반공변 설정을 해야 한다.
2. **“`List<? extends Number>`와 `List<? super Number>`의 차이는 무엇인가요?”**
   - 답:
     - `List<? extends Number>`는 `Number` 또는 `Number`의 하위 타입을 읽을 수 있지만, 쓸 때는 제한된다.
     - `List<? super Number>`는 `Number` 타입(또는 하위 타입)을 쓸 수 있지만, 읽을 때는 `Object`로만 안전하게 읽을 수 있다.
3. **“Java에서 Arrays는 어떻게 공변성을 허용하고, 왜 타입 안전성 문제가 생길 수 있나요?”**
   - 답: 자바의 배열은 공변이지만(`String[]`을 `Object[]` 변수에 대입 가능), 런타임 시 타입 불안전(`ArrayStoreException`) 이슈가 생길 수 있다.

### 4.2 코틀린 관련

1. **“코틀린에서 `out` 키워드를 사용하는 이유는 무엇인가요?”**
   - 답: `out T`는 공변성을 부여하여, “읽기 전용”으로만 사용 가능케 한다. Producer(생산자)로 동작할 때 타입 안정성을 보장해준다.
2. **“코틀린의 `in` 키워드는 어떤 상황에서 유용한가요?”**
   - 답: `in T`는 반공변성을 부여하여, “소비자” 관점의 매개변수를 받을 때만 사용하도록 제한한다. 이를 통해 자식 타입을 받아서 처리할 수 있도록 한다.
3. **“선언 지점 변성(declaration-site variance)과 사용 지점 변성(use-site variance)의 차이를 설명해주세요.”**
   - 답:
     - 선언 지점 변성은 클래스/인터페이스를 선언할 때 미리 `out`/`in`을 사용해 변성을 설정하는 방법.
     - 사용 지점 변성은 함수를 정의하거나 호출할 때, 제네릭 타입에 `out`/`in` 키워드를 붙이는 방법(자바의 `? extends`, `? super`와 유사).
4. **“코틀린에서 `MutableList<out T>`는 왜 대부분 사용하기 어렵나요?”**
   - 답: `MutableList`는 요소를 읽고 쓸 수 있어야 하는데, `out` 키워드를 쓰면 공변성으로 인해 원소 추가가 제한된다. 이 때문에 대부분 `MutableList`에서는 공변 키워드를 사용하기 어렵다.