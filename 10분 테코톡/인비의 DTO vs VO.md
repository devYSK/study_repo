# 10분 테코톡 - 지노 & 비모의 DTO vs VO & 인비의 DTO vs VO

## 목차

* DTO
* VO
* 공통점과 차이점

* ENTITY
* DTO vs VO vs ENTITY

## DTO

DTO란 Data Trasfer Object의 약자로, `계층간 데이터를 전달하기 위해 사용하는 객체` - 데이터 전달용이다

* 계층 - Layer

* getter, setter 메서드 외에 특별한 기능을 가지지 않는다.
    * 정렬, 직렬화 등 데이터 표현을 위한 기능은 가질 수 있다.
* 데이터의 캡슐화를 통해 유연한 대응이 가능하다
    * 데이터 요청 수 감소 효과
    * 각기 다른 API 요청대신, DTO에 데이터를 묶어 보내서 요청 수 감소 효과를 기대할 수 있다.

* setter가 아닌 `생성자`를 이용해서 초기화하는 경우 불변 객체로 활용할 수 있다. 불변 객체로 만들면 데이터를 전달하는 과정에서 데이터가 변조되지 않음을 보장할 수 있다.
* 비즈니스 로직을 포함하지 않는다.

## VO

VO란 Value Object의 약자로, `값 자체로 의미를 갖는 객체` - 값 표현용이다

* 변하지 않는 값을 가지는 객체
    * 값이 변하지 않음을 보장하며 코드의 안정성과 생산성을 높임
* 값이 같다면 동일한 객체
    * 각 객체를 비교하는데 사용되는 ID가 없다
    * 같은 객체인데 판단하기 위해 각 속성들의 값을 비교한다
        * `equals() & hashCode() 메서드!`
        * <img src ="https://blog.kakaocdn.net/dn/x0mwg/btrJMBhirLQ/jwYdVLqvmlpHjY9B6NQOb0/img.png" width=900 height=450>
        * 두 객체가 동등한지 비교할 때 hashCode()의 리턴값을 비교하고, 같으면 eqauls()로 한번 더 비교한다.
        * VO를 같은 객체로 판단하기 위해서는 모든 필드값을 hashCode()메서드와 equlas() 메서드로 비교할 수 있게 오버라이딩 해줘야 한다.
            * `객체의 주소값은 달라도 모든 필드값이 같으면 같은 객체인것이 VO`

* 값이 쉽게 변할 수 있다면 값을 표현하는 본래 목적에 어긋나게 되기에 불변성(immutability)를 보장해줘야 한다.

* 값을 변경할 수 있는 setter를 포함하면 안되고, 생성자를 통해서만 값을 초기화해줘야 한다.
* 비즈니스 로직을 포함할 수 있따.

## DTO와 VO의 공통점과 차이점

### 공통점

* 계층(layer)간 데이터를 전달할 때 사용 가능
    * VO는 불변을 보장하기 때문에 데이터 전달 용도로 사용 가능.

### 차이점

* DTO는 값이 변할 수 있지만 VO는 값이 변하면 안된다(불변객체)
* DTO는 레이어와 레이어에서 사용 가능하고, VO는 모든 레이어에서 사용 가능하다
* DTO는 dto1(1) != dto2(1) 이며, VO는 vo1(1) == vo2(1) 이다
* DTO는 데이터 접근 기능 이외에 비즈니스 로직을 갖지 않으며
* VO는 특정한 비즈니스 로직을 가질 수 있다.

DTO는 `데이터 전달`만을 위한 객체이다. 데이터 전달 이외에 비즈니스 로직은 굳이 있을 필요가 없다.

* ![img](https://images.velog.io/images/taehee-kim-dev/post/339b65e4-6918-4531-bca1-569fc12f423d/Layers.png)

VO는 두 객체의 모든 필드 값들이 동일하면, 두 객체는 같다는게 핵심 정의이다.

equals()와 hashCode() 메서드의 오버라이딩이 중요하지 메소드는 어떤 메소드가 있든 상관 없지만,

setter 등 값을 변화시키는 메소드들은 지양하는게 좋다. VO는 특정 값 자체를 표현하기 때문에 불변이여야 한다.

## Entity

실제 데이터베이스의 테이블과 맵핑되는 핵심 클래스.

이 객체와 데이터베이스의 테이블과 1:1 맵핑된다.

절대로 요청이나 응답 값을 전달하는 클래스로 사용하면 안된다.

엔티티 클래스를 요청이나 응답 값을 전달하는 클래스로 사용한다면 뷰가 변경될 때마다 엔티티 클래스를 그에 맞춰 매번 변경해야 한다.

엔티티 클래스는 변경이 적어야 한다.

이를 방지하기 위해 요청이나 응답 값을 전달하는 클래스로는,

뷰나 요구사항에 변경에 따라 다른 클래스들에게 영향을 끼치지 않고 자유롭게 변경할 수 있는 DTO를 사용해야 한다.

또한 한 테이블이 아닌 여러 테이블들을 조인한 결괏값을 줘야 할 경우가 빈번하기 때문에 DTO로 응답값을 표현하는 경우가 더 유연하고 편리하다.

DTO와 VO, 그리고 Entity는 다 다르다.

세 객체의 목적이 다르고, 세 객체를 복합해 사용하게 된다면 객체간의 결합도는 증가하고 응ㅈ비도는 떨어지게 된다.

좋지못한 설계이다.

## DTO, VO, ENTITY 비교

| 분류                    | DTO                               | VO                      | ENTITY                  |
| ----------------------- | --------------------------------- | ----------------------- | ----------------------- |
| 정의                    | 계층간 데이터 전송용 객체         | 값 표현용 객체          | DB 테이블 맵핑 객체     |
| 상태 또는 변경 여부     | setter 사용시 가변, 미사용시 불변 | 불변 객체               | 가변 또는 불변 객체     |
| 비즈니스 로직 포함 여부 | 비즈니스 로직을 포함할 수 없음    | 비즈니스 로직 포함 가능 | 비즈니스 로직 포함 가능 |

* https://www.youtube.com/watch?v=EeJnNaiMy3U&list=PLgXGHBqgT2TvpJ_p9L_yZKPifgdBOzdVH&index=230
* https://www.youtube.com/watch?v=z5fUkck_RZM