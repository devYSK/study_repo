

# 분산 트랜잭션 



2개이상의 같은 혹은 다른 분리된 데이터베이스들의 연산들의 트랜잭션을 보장하기 위함임.

단일 데이터베이스 내부 트랜잭션과 달리, **분산 환경**에서의 트랜잭션은 네트워크 지연, 노드 장애, 데이터 일관성 유지 등의 추가적인 복잡도가 존재합니다.



### 분산 트랜잭션의 문제점

1. **네트워크 지연과 장애**: 네트워크 불안정성, 노드 장애로 인해 트랜잭션 전체가 실패하거나 굉장히 지연될 수 있음.
2. **확장성 문제**: 2PC(2 Phase Commit)와 같은 방식은 참여 노드가 많아질수록 지연 시간이 크게 늘어나고, 전체 처리량(Throughput)이 떨어짐.
3. **ACID vs. 성능**: 전통적인 분산 트랜잭션은 엄격하게 ACID를 지키기 위해 오버헤드가 큰 편이며, 높은 성능을 내기 어렵다.
4. **운영 복잡도**: 참여하는 데이터 소스마다 Lock 혹은 Coordinator 역할 등이 달라서 운영 난이도가 높음.



# 분산 트랜잭션 기법

###  2PC(Two Phase Commit)

- **개념**: 트랜잭션 코디네이터(Coordinator)와 여러 파티시펀트(Participant) 노드(자원)가 2단계(prepare, commit)로 나누어 커밋을 진행함.
- **동작 과정**:
  1. **Prepare 단계**: 코디네이터가 모든 파티시펀트에게 “prepare to commit” 요청을 전송하고, 각 파티시펀트는 트랜잭션이 유효한지 확인 후 “OK” 또는 “Abort” 응답.
  2. **Commit 단계**: 모든 파티시펀트가 “OK”를 보낸 경우, 코디네이터는 “commit” 지시를 내려 실제 커밋을 진행. 만약 하나라도 “Abort”를 보낸다면 전체 트랜잭션은 Rollback.
- **장점**: 구현이 간단하며 원자성을 보장한다.
- **단점**:
  - Coordinator 장애 시 참가 노드들은 long-lived lock이 걸려 오랫동안 대기할 수 있다.
  - 네트워크가 불안정하면 전체 트랜잭션이 지연 혹은 무한 대기 상태에 빠질 수 있다.
  - 확장성에 취약하다.

## Saga 패턴

**개념**: 마이크로서비스 아키텍처에서 자주 활용되는 패턴으로, 장기 실행 트랜잭션을 여러 “로컬 트랜잭션”들의 연쇄로 구성하고, 각 단계가 실패하면 “보상 트랜잭션(Compensation Transaction)”을 실행하여 롤백 논리를 수행한다.

**운영 방식**:

- **Choreography Saga**: 이벤트 기반으로 각 서비스가 다음 로직을 호출(이벤트 발행 → 다른 서비스가 해당 이벤트 구독 후 로직 수행).
- **Orchestration Saga**: 중앙에서 오케스트레이터가 순차적으로 각 서비스를 호출하고, 실패 시 보상 로직을 수행.

**장점**:

- 2PC 등에 비해 비교적 **상대적으로 높은 확장성**. 2PC에 비해 락 동시 점유 시간이 줄어들고, 각 서비스가 독립적으로 동작하므로 확장성이 좋음
- 한 서비스가 장애를 일으켜도 다른 서비스의 로컬 트랜잭션까지 완전히 막히는 것은 아님(보상 트랜잭션으로 처리 가능
- 메시지 이벤트를 활용하므로, 각 로컬 트랜잭션만 롤백하면 됨.

**단점**:

- 보상 트랜잭션 작성이 복잡하며, 모든 서비스/단계에서 복구 로직을 별도 관리해야 함.
- 데이터가 실제로 "즉시" 일관성을 이루지 못할 수 있음(최종적 일관성).



## 코레오그라피 사가 vs 오케스트레이션 사가



### 코레오그라피

**이벤트(Event) 기반**으로 각 마이크로서비스가 트랜잭션 단계와 보상(롤백) 단계를 관리.

각 서비스는 **독립적으로 이벤트를 구독**하고, 필요한 작업이 완료되면 **새로운 이벤트를 발행**하여 다음 단계 서비스를 트리거.

즉, **별도의 중앙 컨트롤러(오케스트레이터)가 없음**. 서비스들끼리 **직접** 주고받는 이벤트 흐름을 통해 전체 사가를 진행.

#### 장점

1. **분산·탈중앙화**: 어떤 중앙 통제 서비스 없이 각 서비스가 스스로 이벤트를 발행/구독하므로, 독립 배포·확장에 유리.
2. **확장성**: 각 서비스가 이벤트를 통해 loosely coupled(느슨하게 결합)되어 있어, 트랜잭션이 필요 없는 서비스나 새로운 이벤트 리스너를 쉽게 추가 가능.
3. **단순한 경우**: 사가 단계가 적거나 변경이 드물다면, 이벤트 흐름만으로 간단히 트랜잭션을 이어갈 수 있음.
4. 느슨한 결합. 

#### 단점

1. **이벤트 폭발**: 많은 단계가 꼬리를 물고 이벤트를 발행하면, 이벤트 로직이 복잡해지고 메시지 수도 증가(“이벤트 스톰” 문제).
2. **흐름 파악 난이도**: 중앙에서 프로세스를 관장하지 않으므로, 이벤트 흐름이 늘어날수록 “전체 시나리오를 한눈에 파악”하기 어려움. 여러 서비스에 구현 로직이 흩어져 있기 때문. 
3. **변경 관리 복잡**: 새로운 기능이나 단계가 추가될 때, 어떤 이벤트를 발행/구독해야 하는지, 연쇄 효과가 어떻게 일어날지 추적이 까다로움.
4. 서비스간 순환 의존성. 



복잡한 사가는 오케스트레이션이 적합하다? 왜?

### 오케스트레이션 사가

중앙에 **오케스트레이터(Orchestrator) 서비스**가 존재하여 전체 프로세스를 관리.

각 단계가 끝날 때마다 오케스트레이터에 결과(성공/실패)를 전달하고, 오케스트레이터가 “다음에 해야 할 일”을 결정하여 해당 서비스를 **직접** 호출(혹은 메시지)함.

즉, 중앙 집중형 “지휘자(오케스트라 지휘자)”가 있어, 모든 마이크로서비스가 이 지휘자의 **명령**에 따라 순차적으로 로컬 트랜잭션을 실행.

#### 예시 시나리오

1. **Order Service**에 주문 생성 요청이 들어오면, **Orchestrator**가 Order Service를 호출(또는 메시지 전송)해서 “주문 생성 트랜잭션” 진행.
2. Order가 성공하면 Orchestrator가 **Payment Service**를 호출(“결제 요청”).
3. Payment가 성공하면 Orchestrator가 **Inventory Service**를 호출(“재고 차감 요청”).
4. 모든 서비스가 정상 완료 → Orchestrator가 “주문 완료” 상태로 설정하라고 Order Service에 지시.

- 만약 **Inventory Service**에서 실패 → Orchestrator가 Payment Service에 “보상 트랜잭션(결제 취소)”를 지시하고, Order Service에도 “주문 실패” 상태로 변경하라고 명령.



#### 장점

1. **흐름 관리 용이**: 모든 트랜잭션 단계를 **오케스트레이터가 중앙에서 제어**하므로, 트랜잭션 시나리오 전체가 명시적이고 추적이 쉬움.
2. **명확한 책임 분리**: 보상 트랜잭션의 호출 시점, 각 단계의 순서, 장애 처리는 Orchestrator에서 전담 → 개별 서비스는 로컬 트랜잭션 로직과 보상 로직에만 집중.
3. **상태 기계(State Machine) 구현 가능**: Orchestrator를 상태 기계(예: BPMN, State Machine)로 설계하면, 복잡한 분기나 예외 처리를 유연하게 관리 가능.
4. 의존관계까 단순화되고 결합도가 낮아짐. 

#### 단점

1. **단일 장애점(Single Point of Failure)**: Orchestrator가 죽거나 과부하가 걸리면 전체 프로세스 흐름이 중단될 수 있음.
2. **확장성 문제**: 마이크로서비스가 늘어나고, 프로세스 흐름이 복잡해질수록 오케스트레이터가 과부하를 받을 수 있음 → 멀티 인스턴스 운영, 리더-팔로워 구성 등 추가 설계 필요.
3. **개발 복잡도**: 중앙 컨트롤러를 별도로 개발/운영해야 하고, 각 단계의 호출/에러 처리를 모두 여기서 관리해야 함.





| 구분            | **코레오그라피(Choreography)**                               | **오케스트레이션(Orchestration)**                            |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **주요 개념**   | 이벤트 기반 분산 흐름, 각 서비스가 이벤트를 발행/구독        | 중앙 컨트롤러(Orchestrator)가 존재, 모든 단계를 지휘         |
| **구성 요소**   | 이벤트(메시지) 브로커, 이벤트 핸들러, 로컬 트랜잭션          | 오케스트레이터 + 마이크로서비스(로컬 트랜잭션)               |
| **흐름 제어**   | 완전히 분산됨(탈중앙화), 서비스 간 이벤트로 연결             | 중앙 집중형(오케스트레이터), 각 단계는 직접 호출/제어        |
| **장점**        | - 높은 확장성, 탈중앙화 - 각 서비스가 느슨하게 결합 - 특정 이벤트만 구독하면 신규 서비스 추가 용이 | - 트랜잭션 시나리오가 명시적 - 흐름 및 장애 처리 단순 - 상태 기계 도입 쉬움 |
| **단점**        | - 이벤트 폭발, 전체 시나리오 파악 어려움 - 복잡한 흐름일수록 디버깅 난이도 증가 - 변경 시 서비스 간 이벤트 정의를 일일이 수정해야 함 | - 오케스트레이터 장애 시 전체 프로세스 중단 - 확장 시 오케스트레이터 부담 증가 - 별도 중앙 컨트롤러 구현 필요 |
| **적합한 경우** | - 서비스 간 결합도를 최대한 낮추고 싶을 때 - 비교적 간단한 트랜잭션 흐름, 변경성이 적을 때 - 이벤트 드리븐 아키텍처 선호 | - 복잡한 시나리오(브랜치, 조건 분기 많음) - 한눈에 프로세스 전반을 모니터링/관리해야 함 - BPM, State Machine 필요 |
| **구현 예시**   | - Kafka, RabbitMQ 등 브로커를 활용한 이벤트 발행/구독 - 각 서비스 내 보상 트랜잭션 구현 | - Orchestrator 서비스(혹은 모듈)에서 각 서비스 호출 + 보상 트랜잭션 호출 |

# 분산 트랜잭션 아키텍처에서 고려해야 할 사항

### 데이터 일관성 모델

- **강력한 일관성(Strong Consistency)** vs **최종적 일관성(Eventual Consistency)**
  - 마이크로서비스, NoSQL 환경에서는 완벽한 동시 일관성보다 “최종적 일관성”을 택하는 경우가 많음.
  - 실제 업무에서 즉각적인 동시 일관성이 꼭 필요한지, 아니면 약간의 지연을 허용할 수 있는지를 사전에 결정해야 함.

### 4.2 Locking / Timeout 문제

- 분산 트랜잭션에서는 여러 노드가 동시에 Lock을 잡기 때문에 교착 상태(Deadlock) 및 Lock이 장시간 유지되는 문제를 주의해야 함.
- 네트워크 장애나 Coordinator 장애로 인해 Lock이 해제되지 않는 상황이 발생할 수 있음.

### 4.3 장애 처리와 재시도(Retry)

- 분산 환경에서 네트워크 장애, 서버 재시작, DB 장애 등은 일상적으로 발생할 수 있음.
- **Idempotency(멱등성)**: 재시도가 발생하더라도 중복 처리가 되지 않도록 로직을 설계해야 함(예: 동일한 트랜잭션 ID가 들어왔을 때 이미 처리한 요청이면 무시 또는 동일 결과 반환).

### 4.4 모니터링 & 로깅

- 여러 노드에서 하나의 트랜잭션을 구성하므로, 어떤 단계에서 실패했는지 추적이 어려울 수 있음.
- **분산 트레이싱**(Jaeger, Zipkin 등)이나 중앙화된 로깅 시스템(ELK Stack 등)으로 트랜잭션 흐름을 추적할 수 있어야 함.



# 면접 대비: 자주 묻는 질문 & 답변 가이드

아래는 면접에서 분산 트랜잭션을 주제로 자주 나오는 질문을 요약하고, 간단한 답변 가이드를 함께 정리한 것입니다.

1. **분산 트랜잭션이란 무엇이고, 어떤 경우에 필요합니까?**

   - **키 포인트**: 여러 분산된 자원(DB, 외부 시스템 등)에 걸쳐서 원자적 연산을 보장해야 할 때 필요한 개념임을 강조.
   - **답변 예**: “분산 트랜잭션은 여러 마이크로서비스나 분산된 데이터베이스에 걸쳐 트랜잭션을 보장해야 할 때 사용됩니다. 단일 DB에서의 트랜잭션처럼 원자성, 일관성 등을 지켜야 하지만, 분산 환경의 특성상 네트워크 지연, 노드 장애 등의 문제를 해결하는 기법이 포함됩니다.”

2. **2PC(2 Phase Commit) 알고리즘을 설명해보세요.**

   - **키 포인트**: 준비(Prepare) 단계와 커밋(Commit) 단계로 나뉜다는 것, 모든 파티시펀트의 승인이 있어야 커밋이 진행된다는 것, 장애/지연 위험 등을 언급.
   - **답변 예**: “2PC는 Coordinator가 먼저 모든 Participant에게 prepare를 요청하여 준비 여부를 확인하고, 모두 OK라면 최종 commit을 명령하는 방식입니다. 하나라도 실패 응답이 있거나 시간 초과가 발생하면 전체 트랜잭션을 rollback합니다.”

3. **2PC의 단점과 이를 보완하기 위한 방법에는 무엇이 있나요?**

   - **키 포인트**: Coordinator 장애 시 participant들이 대기 상태에 빠지는 문제, 네트워크 지연, 확장성 문제, 3PC, Saga 등의 대안.
   - **답변 예**: “Coordinator가 장애를 일으키면 participant들이 Lock을 오래 유지해 시스템 전체가 느려집니다. 이 문제를 완화하기 위해 3PC를 사용할 수도 있지만, 최근에는 Saga 패턴 등을 활용해 비동기적인 이벤트 기반 보상 트랜잭션을 적용하는 경우가 많습니다.”

4. **Saga 패턴은 무엇이며, 어떤 장단점이 있나요?**

   - **키 포인트**: 장기 실행 트랜잭션을 여러 로컬 트랜잭션으로 나누어 처리하고, 실패 시 보상 트랜잭션으로 롤백하는 방식.
   - **답변 예**: “Saga는 마이크로서비스에서 자주 쓰이는 패턴으로 각 단계가 로컬 트랜잭션을 수행한 후 성공 이벤트를 발행하고, 실패 시 보상 트랜잭션을 실행합니다. 동기로 묶는 2PC와 달리 확장성이 좋고 분산 락 이슈가 덜하지만, 보상 로직을 개별적으로 작성해야 해서 구현 복잡도가 높습니다.”

5. **TCC(Try-Confirm/Cancel) 패턴을 알고 있나요?**

   - **키 포인트**: 자원을 임시 예약(Try) 후에 최종 확정(Confirm) 또는 취소(Cancel)하는 패턴.
   - **답변 예**: “TCC는 Saga와 비슷한 개념이나, 자원을 미리 예약(Try)하고 모든 단계가 정상 완료 시 Confirm으로 확정, 아니면 Cancel로 취소하는 방식입니다. 자원 예약/확정/취소 로직을 모두 작성해야 해서 개발이 복잡하지만, 서비스마다 세밀한 트랜잭션 제어가 가능합니다.”

6. **분산 트랜잭션에서 데이터 일관성을 어떻게 보장할 수 있나요?**

   - **키 포인트**: 강한 일관성 vs 최종적 일관성, Locking, Retry, 메시지 전달 보장 등.
   - **답변 예**: “모든 자원에 대해 락을 걸고 2PC로 처리하면 강한 일관성을 얻을 수 있지만 성능 문제가 큽니다. 보통은 이벤트 기반 설계를 통해 최종적 일관성을 허용하고, 실패 시 재시도(멱등성 로직)를 구현해서 전체 시스템의 유연성과 안정성을 높입니다.”

7. **마이크로서비스에서 XA 트랜잭션을 그대로 적용하면 어떤 문제가 있나요?**

   - **키 포인트**: XA 트랜잭션은 전통적인 모놀리식/엔터프라이즈 환경에서 자주 쓰이며, MSA 환경에서는 확장성과 분산 락 이슈로 인해 잘 사용되지 않는다는 점.
   - **답변 예**: “XA 트랜잭션은 2PC를 사용하고, DB 수준의 Lock이 발생하여 서비스 확장성이 크게 떨어집니다. 마이크로서비스 아키텍처는 독립 배포, 확장 등을 지향하
   
   
   
   