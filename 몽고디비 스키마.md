# 몽고디비 스키마

## 1. 기본 개념 및 설계 철학

### MongoDB (NoSQL)

- **문서 지향(Document-Oriented) 모델:**
   MongoDB는 데이터를 JSON 유사한 BSON 문서에 저장합니다. 이 문서 하나에 관련 정보를 한 번에 담아 전달할 수 있어, 읽기 작업 시 여러 테이블을 JOIN하는 과정을 줄일 수 있습니다.
- **스키마 유연성:**
   스키마가 엄격하게 정해져 있지 않으므로 애플리케이션 요구에 따라 구조를 유연하게 변경할 수 있습니다. 다만, 일관성을 유지하기 위해 설계 단계에서 어느 정도 규칙을 정하는 것이 좋습니다.
- **임베딩 vs 참조:**
  - **임베딩(Embedding):** 관련 데이터를 하나의 문서 안에 중첩 구조로 저장합니다. 읽기 성능은 좋지만 문서 크기가 커질 수 있으며, 업데이트 시 전체 문서를 다시 갱신해야 합니다.
  - **참조(Referencing):** 관련 데이터를 별도 컬렉션에 저장하고, 서로 참조합니다. 데이터 중복을 줄이고 일관성을 유지할 수 있으나, 읽기 시 JOIN과 유사한 추가 작업이 필요할 수 있습니다.

### 관계형 데이터베이스 (RDB)

- **정규화(Normalization):**
   데이터를 여러 테이블로 분리하여 중복을 최소화하고, 데이터 무결성을 유지하는 설계 원칙입니다.
- **관계(Relationships):**
   테이블 간의 관계(1:1, 1:다, 다:다)를 외래키(Foreign Key)를 통해 명확하게 정의합니다.
- **ACID 특성:**
   트랜잭션의 원자성, 일관성, 격리성, 지속성을 보장하여 데이터 신뢰성을 높입니다.



# 몽고디비 데이터 모델링 - 데이터 연결 패턴

mongodb 에서는 되도록 embedded document 로 데이터를 구성하는 것이 바람직합니다.

####  **Access Pattern**

 Application이 데이터에 접근하는 패턴을 파악하여 collection을 정의할 수 있습니다. 우리는 이 과정에서 아래와 같은 질문들을 던질 수 있습니다.

- *Application이 어떤 query들을 수행하는가?*
- *어떤 query를 가장 빈번하게 수행하는가?*
- *Application은 주로 DB에서 데이터를 읽는가? 아니면 쓰는가?*

 위의 질문들을 통해 우리는 아래와 같은 과정을 통해 collection을 정의합니다.

- *함께 조회되는 경우가 빈번한 데이터들은 같은 collection에 담아, query의 횟수를 줄일 수 있습니다.*
- *주로 읽기만 하는 데이터와 자주 업데이트하는 데이터는 별개의 collection에 담습니다.*

몽고디비는, 반정규화를 통해 데이터를 중복 저장합니다.

RDB는 데이터를 삽입하기 전 스키마를 결정하고 데이터를 넣어야 하지만, 몽고DB는 그렇지 않습니다. 



고려해야 할 점

- 임베디드는 중복하여 저장하므로 일관성에 대해 고민해야 함. 참조되는 값이 업데이트 될 여지가 있다면, 참조하는곳에서 모두 업데이트를 해야함. 이것은 업데이트 성능을 매우 늦츨 수 있음. 
- 레퍼런스는 조인 혹은 추가 조회가 필요함. 이것은 조회 성능을 늦츨 수 있음. 적절한 인덱스 설계가 필요. 

몽고디비는 관계 패턴과, 스키마 모델링 전략을 고려할 수 있습니다.

* 스키마 모델링 전략 (MongoDB에서 **구현하는 방식**) : 그 관계를 MongoDB 문서로 어떻게 구현할지"에 대한 방법
  * 임베디드 형태인가, 레퍼런스 형태인가

* 관계 패턴 (데이터 간 **관계의 형태**) : 문서 간 연결 방식이나 데이터 수의 규모에 대한 개념을 관계로 표현
  * 1 to 1? 1 to many?



## 스키마 모델링 전략

### 1. **Embedded Pattern (중첩 문서 패턴)**

관련 데이터를 하나의 문서로 **중첩(내장, embedded)**시켜 저장

게시글 컬렉션

```json
{
  "_id": 1,
  "title": "게시글 제목",
  "comments": [
    { "user": "홍길동", "comment": "좋아요!" },
    { "user": "김철수", "comment": "잘 봤어요" }
  ]
}
```

#### 장점:

- **읽기 성능**이 매우 빠름 (한 번의 조회로 데이터 획득)
- 트랜잭션 없이 **원자성 보장**

#### 단점:

- **문서 크기 제한(16MB)** 이 있음. 무한정 추가할 수 없음. 
- **중첩 배열의 갱신/검색 어려움** -> 애플리케이션에서 한번에 조회해서 찾아야 할 수도 있음.
  - 디스크 I/O속도와 네트워크 패킷 전송 데이터 량을 고려해야함.

### 2. **Reference Pattern (참조 패턴)**

RDB처럼 **관계형 설계**. 각 데이터를 별도의 컬렉션으로 분리하고 대상 컬렉션의 `_id`로 참조

```json
// posts 컬렉션
{
  "_id": 1,
  "title": "게시글 제목",
  "commentIds": [101, 102]
}

// comments 컬렉션
{
  "_id": 101,
  "postId": 1,
  "user": "홍길동",
  "comment": "좋아요!"
}
```

#### 장점:

- 데이터 중복 최소화
- 크고 복잡한 데이터 모델링 가능

#### 단점:

- **조인을 직접 구현하거나 다중 쿼리 필요** -> MongoDB LookUp을 사용해야 함. 
- 성능 저하 가능 (여러 번의 round-trip)

### 3. **Subset Pattern (부분 패턴)**

> **일부만 중첩으로 내장**, 나머지는 참조

```json
{
  "_id": 1,
  "title": "게시글 제목",
  "recentComments": [
    { "user": "홍길동", "comment": "좋아요!" }
  ],
  "commentCount": 142
}
```

#### 장점:

- 자주 보는 정보는 **빠르게 접근**
- 전체는 필요할 때만 참조
- 대량 업데이트의 부담감을 줄일 수 있음.

### 4. **Computed Pattern (계산 필드 패턴)**

> 자주 계산되는 값을 **문서에 직접 저장** (denormalization)

#### 예시:

```json
{
  "_id": 1,
  "title": "게시글 제목",
  "commentCount": 132  // comment 수를 계산하지 않고 바로 사용
}
```

#### 장점:

- 실시간 성능 개선
- 집계 쿼리 필요 없음

#### 단점:

- 데이터 일관성 유지 필요 (쓰기 트랜잭션이 복잡해짐)
- 스트림 방식과 유사하게, 해당 값을 주기적으로 업데이트 필요



**읽기 성능이 중요**하다면 → Embedded

**데이터 중복 피하고 구조화**가 중요하다면 → Reference

**조회 패턴 먼저** 고려한 후 스키마 선택

**성능 분석 도구 (MongoDB Compass, profiler)**로 병목 지점 확인하며 리팩토링



## 2. 관계 패턴 

MongoDB는 문서 기반이기 때문에 이런 관계를 처리할 때 **임베딩(중첩)**할지, **레퍼런싱(참조)**할지를 결정해야 하고, 그걸 상황별로 정리한 게 바로 이 패턴들이에요.

### 1. One-to-One

한 문서가 다른 문서 **하나와만 연결**되는 관계
 (예: 사용자 1명 ↔ 프로필 정보 1개)

- Reference 방식으로도 구성할 수 있지만, **Embedded**로 한 문서에 같이 넣는 게 대부분 더 좋음

```json
{
  "_id": "user123",
  "name": "홍길동",
  "profile": {
    "age": 29,
    "bio": "백엔드 개발자"
  }
}
```

### 2. One-to-Few

한 문서가 소수(대략 10~100개 미만)의 문서와 연결됨
 (예: 게시글 ↔ 몇 개의 태그, 댓글 10개 미만)

- 한 문서와, 그 하위 문서가 될수있는것들을 대부분 **Embedded 배열**로 처리
- 작은 크기와 자주 함께 조회될 때 유리

```json
{
  "postId": 1,
  "title": "MongoDB 패턴",
  "tags": ["MongoDB", "NoSQL", "패턴"]
}
```

### 3. One-to-Many

한 문서가 많은 하위 문서와 연결됨
 (예: 사용자 ↔ 수백 개의 주문)

- 자주 같이 조회되면 → **부분 Embedded**
- 전체는 → **Reference** (예: order 컬렉션 따로 분리)
- 또한, 어떤 데이터들을 embedded로 구성하려고 했지만, 해당 embedded들은 감싸고 있는 문서 외에 독립적으로도 조회될 수 있다면 별도의 컬렉션으로 구성하는게 맞다. 

```json
// users
{
  "_id": "user123",
  "name": "김철수",
  "recentOrders": [
    {
      "item": "커피",
      "price": 3000
    }
  ]
}

// orders
{
  "_id": "order789",
  "userId": "user123",
  "item": "맥북",
  "price": 2000000
}
```

###  4. One-to-Squillions

한 문서가 **수천~수백만 개의 문서와 연결**됨

- 인스타그램의 한 게시글에 수백만 명이 “좋아요”를 누를 수 있음.
- 즉, 게시글 하나(Post)는 수백만 개의 “좋아요(Like)”와 연결됨.
- 참조의 방향을 뒤집어서 squillions의 개별 도큐멘트가 one 쪽의 도큐멘트를 참조하도록 구성하는것이 좋음.

- 절대 Embedded 금지 (16MB 문서 제한)
- **Reference**로 연결 (comments 컬렉션 따로)
- 인덱스와 페이징 설계 중요

```json
// posts
{
  "_id": "post123",
  "imageUrl": "...",
  "likeCount": 1042353  // 집계만 포함
}

// likes
{
  "_id": "like789",
  "postId": "post123",
  "userId": "user1",
  "likedAt": "2025-04-07T08:30:00Z"
}
```

### 5. Many-to-Many

여러 문서가 서로 **다대다 관계**를 가짐
 (예시: **사용자(User) ↔ 태그(Tag)**)

- 양쪽 문서에 ID 배열 넣기 (작을 경우)
- 많아지면 **중간 컬렉션** 생성 (join 테이블처럼)

```json
// users
{ "_id": "user1", "name": "홍길동" }

// tag
{ "_id": "tag1", "name": "운동" }

// user_tag (중간 컬렉션)
{ "_id": "ut1", "userId": "user1", "tagId": "tag1" }
{ "_id": "ut2", "userId": "user1", "tagId": "tag2" }


```

### 6. Outlier Pattern

문서 중 일부만 **비정상적으로 큰 배열이나 데이터**를 가질 경우

- 큰 데이터를 **분리해서 별도 문서**로 저장 (Outlier만 분리)
- 나머지는 Embedded
- 게시글(Post)에 **댓글이 많을 수도 있고, 없을 수도** 있는 구조

```json
[
  {
    "_id": ObjectId("user123"),
    "name": "홍길동",
    "notifications": [
      { "message": "로그인 성공", "timestamp": "2025-04-07T10:00:00Z" },
      { "message": "팔로우 요청 수락", "timestamp": "2025-04-07T10:10:00Z" }
      // ... 일반 사용자면 여기까지만 저장
    ],
    "hasExtras": true  // 이게 핵심 플래그!
  },
  {
    "_id": ObjectId("user123-1"),
    "origin": ObjectId("user123"),
    "isOverflow": true,
    "notifications": [
      { "message": "30일 전 알림입니다", "timestamp": "2025-03-01T08:00:00Z" },
      { "message": "1달 전 팔로우", "timestamp": "2025-03-02T09:00:00Z" }
      // ... overflow 알림들
    ]
  },
  {
    "_id": ObjectId("user123-2"),
    "origin": ObjectId("user123"),
    "isOverflow": true,
    "notifications": [
      // 2번째 overflow 문서 (너무 많을 때)
    ]
  }
]

```

기본적으로 embedded array 다루고, 추가 데이터가 있다는 것을 hasExtras 를 사용해서 표시하고 이전 데이터에서 이어진다는 것을 isOverflow 를 표시하는 방법도 있습니다.

저렇게 하면 쿼리시에

1. 먼저 `user123` 문서를 조회 → `notifications` 필드 바로 사용
2. `hasExtras == true`인 경우 → overflow 문서들 조회

```
db.notifications.find({ origin: ObjectId("user123"), isOverflow: true })
```

3. 결과를 합쳐서 사용자에게 반환

### 🔍 요약표

| 관계 패턴         | 권장 설계 방식                 |
| ----------------- | ------------------------------ |
| One-to-One        | Embedded                       |
| One-to-Few        | Embedded                       |
| One-to-Many       | Embedded + Reference 조합      |
| One-to-Squillions | Reference + 인덱스 최적화 필요 |
| Many-to-Many      | 중간 컬렉션 사용 (Join 컬렉션) |
| Outlier Pattern   | Outlier만 분리해서 저장        |

각 패턴은 "데이터 크기", "조회 패턴", "갱신 빈도", "성능"에 따라 선택해하는게 좋습니다.



# MongoDB vs RDB 차이

## 1. 설계 원리와 결정 요인

### MongoDB 설계 원리

- **쿼리 패턴 분석:**
   데이터를 주로 어떻게 조회할지(예: 한 번에 가져와야 하는 정보의 양, 읽기/쓰기 빈도 등)를 분석합니다.
- **데이터 중복 vs 일관성:**
   중첩(임베딩)을 통해 읽기 성능을 개선할 수 있으나, 동일 정보가 여러 문서에 중복되어 저장될 경우 업데이트 일관성을 고려해야 합니다.
- **문서 크기와 업데이트 빈도:**
   자주 변경되는 데이터와 덜 변경되는 데이터를 구분하여, 임베딩할지 참조할지 결정합니다.

### RDB 설계 원리

- **정규화(Normalization) 단계:**
   1NF, 2NF, 3NF 등 정규화 과정을 통해 데이터 중복을 제거하고, 이상 현상을 방지합니다.
- **관계 정의:**
   엔티티 간 관계를 명확히 하여, JOIN을 통해 데이터를 결합할 수 있도록 설계합니다.
- **트랜잭션 관리:**
   데이터 일관성과 무결성을 위해 트랜잭션 처리가 중요하며, 이를 염두에 두고 테이블 및 인덱스를 설계합니다.

## 1. 사례별 설계 예시

### A. SNS (소셜 네트워크 서비스)

#### MongoDB 설계

- **유저(User) 문서:**
  - 기본 프로필 정보(아이디, 이름, 프로필 사진 등)를 저장.
  - 친구 목록이나 팔로워/팔로잉 정보를 배열로 저장하거나, 별도의 컬렉션(참조)으로 관리.
- **포스트(Post) 문서:**
  - 포스트 내용, 작성자 정보, 작성 시간 등.
  - **임베디드:** 댓글(Comment)을 포스트 문서 내 배열로 포함시키면, 포스트와 그 댓글을 한 번에 조회할 수 있음.
  - **참조:**  댓글 수가 많거나 별도로 관리해야 할 경우, 댓글을 별도의 컬렉션에 저장하고 포스트 ID를 참조.
- **좋아요(Like) 및 기타 상호작용:**
  - 간단한 상호작용은 포스트 문서 내에서 카운터 혹은 배열로 관리.
  - 복잡한 상호작용(예: 누가 언제 좋아요를 눌렀는지 상세 기록)은 별도 컬렉션에 저장하여 참조할 수 있음.
    단, 데이터가 지나치게 커지거나 업데이트 빈도가 높으면 별도 참조로 전환해 데이터베이스의 부하를 줄여야 합니다.

#### RDB 설계

- **Users 테이블:**
  - user_id(PK), name, profile_photo, 기타 프로필 정보.
- **Posts 테이블:**
  - post_id(PK), user_id(FK), content, created_at 등.
- **Comments 테이블:**
  - comment_id(PK), post_id(FK), user_id(FK), content, created_at 등.
- **Likes 테이블:**
  - like_id(PK) 혹은 composite key(user_id, post_id), created_at 등.
- **친구/팔로잉 관계 테이블:**
  - 관계를 표현하기 위한 별도의 테이블(user_id, friend_id) 또는 user_id와 follow_id 등.


RDB는 조인을 위한 데이터베이스입니다. 정규화를 통해 데이터 중복을 방지하며, 관계형 JOIN을 사용해 유저, 포스트, 댓글 등 각각의 데이터를 명확하게 분리합니다. 이는 데이터 무결성을 보장하고, 트랜잭션 처리가 필요한 경우에 유리합니다.



## 3. 왜 이런 설계를 선택해야 하는가?

### MongoDB 선택 이유

- **유연성:**
   스키마가 자유로워, 초기 프로토타입 제작 및 애플리케이션 요구사항 변화에 빠르게 대응할 수 있음.
- **읽기 성능 최적화:**
   임베딩을 통해 관련 데이터를 한 번에 조회할 수 있어, 대량의 읽기 작업이 많은 경우 유리함.
- **분산 및 확장성:**
   수평 확장이 용이하여, 빅데이터 환경이나 트래픽이 많은 서비스에 적합함.

### RDB 선택 이유

- **데이터 무결성과 일관성:**
   정규화와 트랜잭션 관리 덕분에 데이터의 신뢰성을 보장할 수 있음.
- **복잡한 관계 표현:**
   복잡한 다대다 관계나 JOIN이 빈번한 경우, RDB가 명확하고 안정적인 관계 모델링을 제공함.
- **성숙한 기술 및 도구 지원:**
   오랜 기간 사용되어온 만큼 다양한 관리 도구와 최적화 기법, 커뮤니티 지원이 강점임.



# RDB vs MongoDB 인덱스 전략 

예시로 PostgreSQL과 비교 해보도록 하곘습니다. 

## 1. PostgreSQL 인덱스 전략

PostgreSQL은 전통적인 RDBMS로서 다양한 인덱스 타입과 기능을 제공합니다.

### 주요 인덱스 타입 및 특징

- **B-tree 인덱스 (기본):**
  - **용도:** 대부분의 비교 연산(=, >, < 등)에 최적화되어 있음
  - **특징:** 균형 잡힌 트리 구조를 사용하여 빠른 검색 속도를 제공함
- **Hash 인덱스:**
  - **용도:** 등치(=) 비교에 특화되어 있음
  - **제한:** PostgreSQL에서는 WAL(write-ahead log)과 관련된 이슈로 사용 빈도가 낮으며, 일반적으로 B-tree가 더 널리 사용됨
- **GiST (Generalized Search Tree):**
  - **용도:** 공간 데이터, 범위 검색, 텍스트 검색 등 복잡한 데이터 타입에 사용
  - **예:** 지리정보 데이터나 유사도 검색
- **GIN (Generalized Inverted Index):**
  - **용도:** 배열, JSONB, 텍스트 검색 등에 효과적
  - **특징:** 여러 값이 하나의 컬럼에 포함된 경우 빠른 검색 지원
- **BRIN (Block Range INdexes):**
  - **용도:** 대량의 데이터 중 자연스러운 순서(예: 타임스탬프)를 가진 컬럼에 적합
  - **특징:** 저장 공간이 작고, 범위 검색에서 효율적

### 추가 기능

- **Composite 인덱스:**
   여러 컬럼을 하나의 인덱스로 구성하여 복합 조건 검색에 효율적입니다.
- **Partial 인덱스:**
   조건에 맞는 일부 데이터에만 인덱스를 생성하여 인덱스 크기를 줄이고, 특정 조건에 최적화할 수 있습니다.
- **Functional 인덱스:**
   컬럼의 변환 결과나 표현식을 기준으로 인덱스를 생성할 수 있어, 계산된 값에 대해 빠른 검색이 가능합니다.

## 2. MongoDB 인덱스 전략

MongoDB는 문서 지향(NoSQL) 데이터베이스로, JSON(BSON) 형태의 데이터를 다루기 때문에 구조적 특성과 사용 패턴에 맞는 인덱싱 기능을 제공합니다.

### 주요 인덱스 타입 및 특징

- **B-tree 기반 인덱스 (기본):**
  - **용도:** 대부분의 필드에 대해 기본 인덱스 기능 제공
  - **특징:** PostgreSQL의 B-tree와 유사하게 작동하지만, MongoDB는 내부적으로 JSON 문서의 키-값 구조에 맞게 최적화되어 있음
- **복합(Compound) 인덱스:**
  - **용도:** 여러 필드를 조합한 검색 조건에 대해 하나의 인덱스를 생성
  - **특징:** 필드 순서가 중요하며, 복합 인덱스는 왼쪽 접두사(left-prefix) 원칙에 따라 사용됨
- **멀티키(Multikey) 인덱스:**
  - **용도:** 배열 값을 가진 필드를 인덱싱할 때 사용
  - **특징:** 문서 안의 **배열 요소 각각을 인덱싱**해서, 배열 안의 값도 인덱스를 통해 빠르게 검색
  - 복합 Multikey 인덱스에서 배열 2개 이상 사용 불가 -> 카테시안 곱 문제 
  - 배열의 모든 요소를 **개별 키로 분해**하고 B-TREE 인덱스로 들어가는것.  검색 조건에 해당하는 인덱스 키에 연결된 문서 목록을 반환 -> 하나의 문서가 여러 키로 인덱싱 되는것. 
  - https://www.mongodb.com/ko-kr/docs/manual/core/indexes/index-types/index-multikey/
- **텍스트(Text) 인덱스:**
  - **용도:** 문자열 내 단어 검색, 자연어 검색에 최적화
  - **특징:** 여러 필드에 대해 하나의 텍스트 인덱스를 구성할 수 있음
- **지리공간(Geospatial) 인덱스:**
  - **용도:** 2d 또는 2dsphere 인덱스를 통해 위치 기반 쿼리 지원
  - **특징:** 지도 데이터나 위치 기반 검색에서 필수적
- **와일드카드(Wildcard) 인덱스:**
  - **용도:** 동적 스키마 환경에서, 문서 내 다양한 필드에 대해 자동 인덱싱
  - **특징:** 모든 하위 필드를 대상으로 인덱스를 생성하여, 스키마 변경에 유연하게 대응
- **Partial 인덱스:** 특정 조건을 만족하는 문서에만 인덱스를 적용하여, 인덱스 크기를 줄이고 성능 최적화

- **유니크 인덱스:** 중복 데이터를 방지하며, 데이터 무결성을 유지할 수 있음
- **TTL(Time To Live) 인덱스:**  일정 시간이 지난 데이터를 자동으로 삭제하기 위해 사용, 로그나 세션 데이터에 유용함



# **Read Concern**과 **Write Concern**

### Read Concern이란?

> 데이터를 **읽을 때, 어느 수준의 일관성을 보장할 것인지**를 설정하는 기능. 특히 복제본(replica set)이나 트랜잭션 환경에서 중요

대부분의 실무 환경에서는 `majority`로 설정해 강한 일관성을 보장하면서도 적당한 성능을 유지함.

| 수준           | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| `local`        | (기본값) 현재 노드에 기록된 데이터만 읽음. 복제되었는지는 보장 안 됨. 빠르지만 일관성 낮음. |
| `available`    | (샤딩용) 샤드에 접근 가능하면 바로 반환. 일관성 전혀 보장 안 됨. |
| `majority`     | 복제본 세트의 과반수 노드에 복제된 데이터만 읽음. 강한 일관성 보장. |
| `linearizable` | 가장 최근의 쓰기가 반영된 값을 보장. 매우 강력한 일관성, 하지만 성능 저하 있음. |
| `snapshot`     | 트랜잭션 중 동일 시점의 데이터를 보장. 멀티도큐먼트 트랜잭션용. |

### Write Concern이란?

> 데이터를 **쓸 때, 몇 개의 노드에 안전하게 기록되었는지 보장할 것인지** 설정하는 기능

- 쉽게 말하면: *"쓰기 작업이 다른 서버들에도 확실히 저장됐는지 확인하고 싶다"*는 요구

**Write Concern**은 **쓰기 작업이 얼마나 많은 노드에 복제되고 나서 클라이언트에 성공 응답을 줄 것인지**를 정합니다.

| 수준          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| `w: 1`        | (기본값) primary에만 기록되면 성공 응답. 빠르지만 내구성 약함. |
| `w: 0`        | 응답 기다리지 않음. 초고속, 하지만 실패 여부 모름.           |
| `w: majority` | 과반수 노드에 복제되면 성공. 높은 내구성.                    |
| `w: "all"`    | 모든 노드에 복제되면 성공 (샤딩 환경에 사용).                |

옵션:

- `wtimeout`: 복제 타임아웃 시간 (예: `wtimeout: 1000` → 1초 내 복제 안되면 실패 처리)
- `journal: true`: 디스크의 Journal 파일까지 기록되어야 성공으로 간주

> 💡 실시간성과 내구성이 모두 중요한 경우 `w: majority, journal: true` 같이 조합해서 사용함.

* j : Journal(디스크 반영 여부)까지 확인할지 여부

왜 필요한가?

| 상황        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| 복제 지연   | Secondary가 Primary보다 늦게 동기화될 수 있음                |
| 장애 복구   | Primary 다운 후 Secondary가 승격될 때, 최신 데이터가 복제 안 됐으면 손실 가능 |
| 일관성 보장 | 읽기/쓰기 트랜잭션이 정확하고 신뢰 가능해야 함               |
| 내구성 강화 | "쓰기 완료"를 너무 빨리 응답하면, 실제 저장은 안 됐을 수도 있음 |

즉, **성능 vs 안전성** 사이에서 균형을 맞추는 설정임

| 항목          | 목적             | 강하게 설정하면 | 약하게 설정하면 |
| ------------- | ---------------- | --------------- | --------------- |
| Read Concern  | 읽기 일관성 보장 | 정확하지만 느림 | 빠르지만 위험   |
| Write Concern | 쓰기 내구성 보장 | 안전하지만 느림 | 빠르지만 위험   |

## 설정 방법

### 🛠 설정 위치

1. **클라이언트 설정**
2. **명령어(쿼리) 단위**
3. **세션/트랜잭션 레벨**
