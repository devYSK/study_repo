# 레디스 내부 자료구조

레디스 오브젝트

* https://github.com/redis/redis/blob/unstable/src/object.c

## 1. 문자열 (String)

- Redis에서 가장 기본이 되는 자료구조
- 하나의 키에 대해 최대 512MB까지의 문자열 값 저장 가능
- 숫자, JSON, 이미지 파일 같은 바이너리도 string으로 간주되어 저장 가능
- INCR key : 특정 키의 값을 1 증가시킴

### 내부 구현 상세

- SDS (Simple Dynamic String) 구조
  - https://github.com/redis/redis/blob/unstable/src/sds.h
  - Redis의 문자열은 단순한 C 문자열 배열이 아닌 SDS라는 구조체로 관리됩니다.
  - SDS는 문자열의 길이, 사용 가능한 여유 공간(free space) 등의 메타데이터를 함께 저장하여, 문자열의 길이를 O(1)로 조회할 수 있고, 재할당 시에도 오버헤드를 줄입니다.
  - 헤더 구성:
    - 이 헤더 덕분에 문자열의 길이를 매번 순회하지 않고 상수 시간에 확인할 수 있으며, 여러 SDS 타입을 통해 짧은 문자열과 긴 문자열 모두 메모리 효율적으로 관리할 수 있습니다.
  - 예비 메모리 할당 전략:
    - 문자열에 추가 데이터가 append될 때, 기존 크기보다 약간 여유 있는 메모리 공간을 미리 할당하여 재할당을 줄이는 “exponential buffer growth” 방식을 사용합니다.
  - 메모리 재할당:
    - 만약 기존 버퍼가 부족하면 새로운 메모리 블록을 할당하고 데이터를 복사한 뒤, 원래 메모리를 해제하는 방식으로 처리됩니다.
  - 이진 안전성:
    - SDS는 내부에 NULL 문자가 포함되어도 데이터를 온전히 저장할 수 있어, 이진 데이터나 텍스트 데이터 모두에 적합합니다.

### 성능 및 장단점

- 성능:
  - GET, SET, APPEND 등의 기본 연산은 상수 시간(O(1))에 수행됩니다.
  - 헤더 정보를 이용해 길이를 즉시 파악할 수 있으므로 반복 계산 없이 빠른 처리 가능.
- 장점:
  - 메모리 할당 및 재할당 전략 덕분에 잦은 업데이트에도 효율적
  - 다양한 SDS 타입 지원으로 작은 데이터와 큰 데이터 모두 최적화됨
- 단점:
  - 문자열 자체에 복잡한 부가 정보가 없으므로, 복합 데이터 구조를 표현하려면 별도의 인코딩/디코딩 과정이 필요함

## 2. 리스트 (List)

### 내부 구현 상세

* http://redisgate.kr/redis/configuration/internal_quicklist.php

여러 개의 quicklistNode로 구성된 **이중 연결 리스트(doubly linked list)**입니다.

각 노드는 내부에 하나의 **listpack**을 포함하고 있는데, 이 listpack은 여러 개의 리스트 요소들을 연속된 메모리 공간에 압축하여 저장합니다.

- Quicklist – 하이브리드 자료구조
  - 여러 개의 노드(quicklistNode)로 구성된 **이중 연결 리스트(doubly linked list)**입니다. 각 노드는 내부에 하나의 **listpack**을 포함하고 있는데, 이 listpack은 여러 개의 리스트 요소들을 연속된 메모리 공간에 압축하여 저장합니다.
  - 이중 연결 리스트:
    - 전체 리스트는 노드들이 서로 연결된 이중 연결 리스트로 구성되어 있으며, 각 노드는 독립적으로 메모리 할당된 압축 블록을 가리킵니다.
  - 압축 노드 (Listpack):
    - 각 노드는 여러 원소들을 연속 메모리 영역에 저장합니다.
    - Listpack:
      - listpack은 연속적인 메모리 블록에 “엔트리”들을 순차적으로 저장하며, 각 엔트리는 길이 정보, 데이터 타입, 데이터 값 등을 포함합니다.
      - Ziplist의 후속으로, 더 빠른 압축 해제 및 삽입/삭제 연산을 지원하며, 내부 포맷이 개선되어 메모리 효율과 속도에서 이점을 가집니다.
  - 노드 분할 및 병합:
    - 리스트 중간에 삽입하거나 삭제할 경우, 압축된 노드를 분할하거나 두 노드를 병합하는 추가 연산이 발생할 수 있습니다.
  - 구성 파라미터:
    - Quicklist는 “fill factor” 및 “compress depth”와 같은 설정으로 각 노드의 최대 원소 수와 압축 적용 범위를 제어합니다.

### 성능 및 장단점

- 성능:
  - 양쪽 끝(LPUSH, RPUSH, LPOP, RPOP)의 연산은 O(1)에 가까운 시간 내에 처리됩니다.
  - 인덱스 기반 임의 접근은 내부 노드 순차 탐색으로 인해 최악의 경우 O(N) 시간이 소요됩니다.
- 장점:
  - 메모리 단편화를 줄이고 캐시 지역성을 극대화하여, 대량의 데이터를 다룰 때 효율적임
  - 큐, 스택, 데크 등 다양한 자료구조로 활용 가능
- 단점:
  - 중간 삽입/삭제 시 압축 블록을 재구성하는 오버헤드가 존재
  - 무작위 인덱스 접근은 빠르지 않으므로, 순차적 접근에 적합

## 3. 집합 (Set)

### 내부 구현 상세

Redis의 `Set` 자료구조는 **중복을 허용하지 않는 유일한 값들의 집합**을 저장하는 구조입니다. 내부적으로는 저장되는 원소의 개수에 따라 **두 가지 방식**으로 구현됩니다.

1. **intset (정수 집합)**
   * https://github.com/redis/redis/blob/unstable/src/intset.c
2. **hashtable (해시 테이블)**
   * https://github.com/redis/redis/blob/unstable/src/dict.c



intSet은 정수 값들만 저장할 수 있는 내부적으로 **정렬된 배열** 형태로 저장됩니다.



원소가 정수타입이 아니거나 설정된 임계치를 초과하면 자동으로 Hashtable 형식으로 변환되어 저장됩니다.

hashTable은 내부적으로 **Redis의 `dict` (해시 테이블) 구조를 사용하여** 데이터를 저장하며, Key-Value 구조에서 Value가 `NULL`인 형태로 저장됩니다.

```c
typedef struct dictht {
    dictEntry **table;  // 해시 테이블 (버킷 배열)
    unsigned long size; // 테이블 크기
    unsigned long sizemask; // 인덱싱을 위한 마스크 값 (size-1)
    unsigned long used; // 현재 저장된 요소 개수
} dictht;

typedef struct dictEntry {
    void *key;          // 저장된 키 (Set의 값)
    struct dictEntry *next; // 체이닝 방식 충돌 해결을 위한 다음 노드
} dictEntry;

```

해시 테이블의 크기는 보통 **2의 거듭제곱 형태**이며, 충돌이 발생하면 `dictEntry` 노드를 연결하여 **체이닝 방식**으로 해결합니다.

* Redis의 해시 테이블(`dict`)은 **체이닝(Chaining)** 방식으로 해시 충돌을 해결합니다.
   즉, 동일한 해시 값을 갖는 키들이 발생하면 **연결 리스트(Linked List)** 를 사용하여 충돌을 해결합니다
* 해시 함수로는 키를 해시 값으로 변환할 때 **MurmurHash2** 또는 **MurmurHash3**을 사용합니다.

`O(1)`의 평균 접근 시간을 제공하지만, 최악의 경우 충돌이 많을 때 `O(N)`까지 성능이 저하될 수 있습니다

### 성능 및 장단점

- 성능:
  - 소규모 정수 집합은 Intset 덕분에 매우 낮은 메모리 사용과 빠른 순차 접근이 가능함
  - 일반적인 집합 연산(원소 추가, 삭제, 포함 여부 확인)은 Hashtable 방식에서 평균 O(1) 성능 보장
- 장점:
  - 상황에 맞게 두 가지 인코딩 방식을 자동 전환하여 메모리와 속도 효율을 최적화함
  - 집합 간의 합집합, 교집합, 차집합 연산을 효과적으로 지원함
- 단점:
  - Hashtable 사용 시 메모리 오버헤드가 발생할 수 있음
  - Intset은 정수 타입만 지원하므로, 문자열 등 다른 타입은 Hashtable로 전환되어야 함

## 4. 정렬된 집합 (Sorted Set, Zset)

- Sorted Set은 데이터가 정렬되어 저장되는데, 이때 내부적으로 두 가지 데이터 구조로 저장됨
- member 모두 64 byte 이하이며 member 수가 128개 이하이면 Listpack 데이터 구조로 저장
- member 중 하나라도 65byte 이상이거나 member 수가 129개 이상이면 Skip List 데이터 구조로 변환하여 저장

Redis의 `Sorted Set` (`ZSet`)은 **고유한 요소(값)와 각 요소에 대응하는 점수(score)** 로 구성된 자료구조입니다.
 기본 `Set`과 달리, **요소들이 점수(score)에 따라 정렬된 상태로 유지**되며, 범위 검색 및 순위 기반 연산이 가능하도록 설계되었습니다.



 `Sorted Set`은 저장된 데이터 크기에 따라 Listpack, skipList **두 가지 다른 데이터 구조**를 사용하여 최적화됩니다.

* listpack : https://github.com/redis/redis/blob/unstable/src/listpack.c
* zskiplist: https://github.com/redis/redis/blob/unstable/src/t_zset.c

Listpack는 `Sorted Set`의 요소 개수가 적거나, 요소 값과 점수(score)의 길이가 짧을 경우 사용됩니다.

Listpack은 Redis 7.0에서 **Ziplist**를 대체하기 위해 도입된 **메모리 효율적인 압축 데이터 구조**입니다.
 Ziplist가 가지고 있던 단점(메모리 재할당, 데이터 변경 시 성능 저하 등)을 해결하면서도 **리스트(List), 해시(Hash), Sorted Set(ZSet)** 등의 자료구조에서 활용됩니다.





만약 member중 하나라도 특정 크기(65바이트)를 넘어가거나 멤버 수가 129개 이상이면, 

Skip List+ hash table 구조로 변환하여 저장합니다.

스킵 리스트는 멤버들을 점수의 순서대로 정렬하여 저장합니다. 

이 구조 덕분에 범위 검색, 순위 기반 조회, 점수 기반 순서 변경 등을 O(log N) 시간 내에 수행할 수 있습니다.

각 노드는 여러 레벨의 연결 리스트로 구성되어 있으며 다음 정보를 포함합니다. 

- **멤버 데이터 및 점수:** 실제 값과 그에 따른 점수를 저장합니다.
- **forward 포인터 배열:** 여러 레벨에 걸쳐 뒤쪽 노드들을 가리키는 포인터 배열로, 각 레벨마다 건너뛸 수 있는 노드의 수(즉, span)를 함께 저장합니다.
- **backward 포인터:** 현재 노드의 이전 노드를 가리키며, 역방향 탐색에 사용됩니다.

검색 시 높은 레벨에서 시작하여 점프하며 이동 → **O(log N) 탐색 속도** 확보





이중 Hashtable은 각 원소의 점수 조회 및 존재 여부를 빠르게 확인하기 위해 사용되며, Skiplist와 동기화되어 유지됩니다. 요소 값을 키(key), 점수(score)를 값(value)로 저장하여 **O(1) 검색 속도** 제공.

`skiplist`는 순서 보장을 위해 필요하지만, 요소 직접 검색(`ZSCORE`, `ZREM` 등)은 `hashtable`이 수행.



해시테이블에 key로 value(멤버)값을 넣으며, value에는 score와 skiplist 노드 주소를 넣어 

멤버의 점수 조회, 존재 여부 확인을 O(1로) 하고

스킵리스트에 keys는 score를, value로는 value(멤버), 랭킹, 포인터를 넣어 정렬 유지, 순위 계산, 범위 검색을 한다. 



* 삽입
  * **Hashtable 업데이트:**
    - 새로운 멤버가 추가될 때, 먼저 Hashtable(사전)에 해당 멤버를 키로 하여 점수와 skiplist 노드의 포인터를 저장합니다.
    - 이 작업은 평균적으로 O(1) 시간에 이루어집니다.
  * 예를 들어, `"userX"`라는 멤버를 점수 `15.0`으로 삽입한다고 가정하면:
    - Hashtable에는 `"userX"`를 키로, 점수 `15.0`과 해당 skiplist 노드 주소를 저장합니다.
    - Skiplist에서는 헤드 노드부터 시작하여 점수 `15.0`에 맞는 위치(예, `"userA"`와 `"userB"` 사이)를 찾아 새 노드를 삽입하고, 각 레벨의 포인터와 span 값을 업데이트합니다.
* 삭제 : 
  * Hashtable 검색 및 삭제:
    * 삭제할 멤버를 Hashtable에서 O(1) 시간 내에 검색하여, 해당 멤버가 존재하는지 확인합니다.
  * Skiplist 삭제:
    * 검색된 노드를 기준으로 skiplist 내에서 삭제 작업을 수행합니다.
    * 각 레벨에서 삭제할 노드의 전 단계(predecessor) 노드의 forward 포인터를 업데이트하여, 삭제 대상 노드를 건너뛰도록 연결합니다.
    * 각 레벨의 span 값도 재계산하여 리스트의 길이를 올바르게 유지합니다.
  * 예를 들어, `"userY"`라는 멤버를 삭제할 경우:
    * Hashtable에서 `"userY"`를 찾아 제거합니다.
    * Skiplist에서는 `"userY"`의 위치를 찾아 각 레벨에서 연결을 재조정하고 span 값을 수정합니다.

* 업데이트:

  * hastable에서 멤버를 검색하여 점수를 확인 후 skiplist에서 삭제 후 새 점수와 함께 삽입.

    

### 성능 및 장단점

- 성능:
  - 삽입, 삭제, 범위 조회 등의 연산은 Skiplist의 특성상 평균 O(log N) 시간에 수행됨
  - Hashtable 덕분에 특정 원소의 존재 여부나 점수 조회는 매우 빠르게 처리됨
- 장점:
  - 순위 기반 검색, 리더보드, 범위 쿼리 등 점수와 순서를 동시에 관리해야 하는 응용 분야에 최적화됨
  - 두 가지 자료구조의 장점을 결합해 다양한 연산을 효과적으로 지원
- 단점:
  - 내부적으로 두 개의 자료구조를 유지해야 하므로 메모리 사용량이 증가함
  - 구현 복잡도가 상대적으로 높아, 변경이나 확장 시 관리가 까다로울 수 있음

## 5. 해시 (Hash)

### 내부 구현 상세

https://github.com/redis/redis/blob/unstable/src/dict.h

레디스 해시 자료구조는 메모리 효율성과 성능을 위해 각 필드와 값의 길이에 따라  압축 인코딩이라 불리는 listpack 방식과 **해시 테이블(Hashtable)** 방식 중 하나를 선택하여 저장합니다.

해시 객체에 저장된 필드의 수가 일정 임계치를 초과하거나 각 원소의 크기가 클 경우, Redis는 자동으로 인코딩을 해시 테이블 방식으로 전환합니다.



ListPack 방식에서는 모든 필드-값 쌍을 하나의 연속 메모리 블록(초기에는 ziplist, 최신 버전에서는 listpack) 내에 저장합니다.

- 이 인코딩은 각 엔트리마다 길이, 타입, 값 정보를 저장하여 데이터를 압축하여 관리합니다.



HashTable 방식은 일반적인 해시 테이블 구조로, 해시 함수를 기반으로 키를 버킷에 매핑하고, 충돌을 해결하기 위해 체이닝 방법을 사용합니다. 

- 전환 메커니즘:
  - Redis는 데이터 크기나 특성을 지속적으로 모니터링하며, 작은 데이터일 경우 압축 인코딩을, 데이터가 커지면 Hashtable로 전환하여 최적의 성능을 유지합니다.

### 성능 및 장단점

- 성능:
  - 압축 인코딩 방식은 소규모 데이터에서 메모리 효율과 캐시 효율성이 뛰어나지만, 원소 수가 많아지면 순차 탐색에 따른 시간 지연이 발생할 수 있음
  - Hashtable 방식은 평균 O(1) 성능을 보장하여, 많은 항목을 빠르게 조회 가능
- 장점:
  - 동적 전환을 통해 다양한 크기의 해시 데이터를 최적화하여 관리할 수 있음
  - 메모리 사용량 최적화와 빠른 키-값 연산을 동시에 지원
- 단점:
  - 전환 과정에서의 재할당 및 데이터 복사가 발생할 수 있어, 순간적으로 연산 부하가 증가할 가능성이 있음
  - 압축 인코딩 상태에서는 임의 접근 시 선형 탐색의 단점이 존재



## ListPack vs Hashtable

ListPack은 연속된 메모리 공간에 데이터를 압축하여 저장하는 방식으로 작은 해시, 작은 리스트의 내부 구현에 사용됌.

장점으론 오버헤드가 적고, 빠르게 관리 가능하지만 데이터가 순차적으로 저장되기 때문에 최대 조회시간이 O(n)

해시테이블은 일반적인 key-value 방식이며 빠른 조회/삽입 가능.

단점으론 해시 충돌시 성능 저하, 일정 임계치 넘으면 확장해야 하므로 성능 저하 

* 레디스 해시테이블은 내부적으로 체이닝 방식을 사용해 해시 충돌 해결.  소스코드가있음. 
*  한 Bucket 안에 데이터가 많아지면 결국 탐색 속도가 느려집니다. 이를 위해서 Redis는 특정 사이즈가 넘을 때 마다 Bucket을 2 배로 확장하고, Key들을 rehash하게 됌 



## 6. 비트맵 (Bitmap)

Redis의 bitmap 기능은 별도의 독립 자료구조라기보다는, **Redis의 문자열 자료형인 SDS** 위에 비트 단위 연산을 적용하여 제공되는 기능입니다. Redis의 bitmap 명령어들은 내부적으로 문자열 데이터를 비트 배열로 취급하여 동작합니다.

BITOP, BITCOUNT, GETBIT, SETBIT 등의 명령어는 문자열 내부의 각 바이트에 대해 비트 마스킹, 시프트 연산 등을 수행합니다.

**BITGET:**

1. 주어진 오프셋으로 바이트와 비트 인덱스를 계산합니다.
2. SDS의 `buf` 배열에서 해당 바이트를 가져옵니다.
3. 비트 연산(shift 및 AND)을 통해 특정 비트의 값을 추출하여 반환합니다.

**BITSET:**

1. BITGET과 유사하게, 먼저 대상 바이트와 비트 위치를 결정합니다.
2. 만약 SDS의 길이가 부족하면, SDS를 확장하여 해당 인덱스를 포함하도록 만듭니다.
3. 기존 바이트의 값을 읽은 후, 지정한 값(0 또는 1)으로 해당 비트를 설정합니다.
   - 예를 들어, 1로 설정할 때는 해당 위치의 비트 마스크를 OR 연산을 통해 적용하고, 0으로 설정할 때는 AND NOT 연산을 수행합니다.
4. BITSET은 보통 이전 비트 값을 반환합니다.

**BITCOUNT:**

1. 전체 SDS의 `buf` 배열(또는 지정한 범위)을 순회하며, 각 바이트 내 1의 개수를 계산합니다.
2. 이 과정에서는 미리 만들어진 lookup table을 이용하여 빠르게 1의 개수를 센 후, 전체 합계를 반환하기도 합니다.

### 성능 및 장단점

- 성능:
  - 개별 비트 조작 연산은 O(1)에 가까운 시간 내에 수행됨
  - BITCOUNT나 BITOP과 같은 집계 연산은 내부 루프를 통해 매우 최적화된 C 코드로 처리됨
- 장점:
  - 매우 적은 메모리 오버헤드로 수십~수백 MB의 비트 배열을 저장할 수 있음
  - 비트 단위 집계 및 논리 연산이 매우 빠르며, 대량의 상태 정보를 효율적으로 관리할 수 있음
- 단점:
  - 비트 단위의 조작만 가능하여, 복잡한 자료구조나 데이터를 직접 표현하기에는 한계가 있음
  - 데이터를 의미 있는 값으로 해석하기 위해서는 별도의 비트 필드 파싱 로직이 필요

## 7. HyperLogLog

### 내부 구현 상세

- 확률적 카디널리티 추정 알고리즘
  - 레지스터 배열:
    - HyperLogLog는 약 16,384개의 레지스터(일반적으로 2^14)를 사용하며, 각 레지스터는 입력된 원소의 해시값에서 나타나는 선행 0의 최대 개수를 기록합니다.
    - 각 레지스터는 보통 6비트 정도의 크기를 가지며, 전체 메모리 사용량은 고정되어 약 12KB 정도입니다.
  - 해시 함수:
    - 고품질 해시 함수를 사용하여 입력 데이터를 균등하게 32비트 혹은 64비트 정수로 변환한 후, 해시값의 일부 비트를 인덱스, 나머지 비트를 기반으로 선행 0의 수를 계산합니다.
  - 근사 계산:
    - 모든 레지스터의 값을 조합해 하모닉 평균과 바이어스 보정 기법을 적용, 유니크 원소 수를 근사적으로 산출합니다.
  - 병합 기능:
    - 서로 다른 HyperLogLog 인스턴스의 레지스터를 하나씩 비교하여 최대값을 취하는 방식으로 손쉽게 병합할 수 있어, 분산 데이터 집합에도 적합합니다.

### 성능 및 장단점

- 성능:
  - 모든 연산(추가, 병합, 추정)이 상수 시간(O(1)) 내에 처리됨
  - 고정 메모리 사용량으로 대규모 데이터 집합의 카디널리티를 효율적으로 추정
- 장점:
  - 극소 메모리로도 수십억 개의 원소에 대한 근사 유니크 카운트를 제공함
  - 병합이 용이하여 분산 환경에서도 활용 가능
- 단점:
  - 추정치에 표준 오차(약 0.81%)가 존재하므로, 절대 정확한 개수가 필요한 경우에는 부적합함
  - 원소의 실제 값은 저장되지 않으므로, 원소 목록을 복원할 수 없음

------

## 8. 스트림 (Stream)

### 내부 구현 상세

- 복합 자료구조 – Radix Tree와 Listpack의 결합
  - Radix Tree (압축 트리):
    - 스트림 인덱스를 관리하기 위해 사용되며, 키(스트림 ID, 일반적으로 Unix 타임스탬프와 시퀀스 번호의 결합)를 압축하여 저장합니다.
    - 공통 접두사를 압축하는 방식으로 메모리 사용량을 줄이고, 범위 조회 시 빠른 검색을 가능하게 합니다.
  - Listpack:
    - 각 Radix Tree의 리프 노드 내에 여러 스트림 엔트리를 하나의 연속된 메모리 블록으로 저장합니다.
    - 엔트리 구성:
      - 각 엔트리는 고유한 스트림 ID와, 여러 개의 필드-값 쌍을 포함하며, 내부적으로 압축되어 저장됩니다.
  - 추가 메타데이터:
    - 소비자 그룹(Consumer Group) 관련 정보, Pending Entries List(PEL) 등 스트림 처리에 필요한 부가 데이터도 별도의 구조로 관리됩니다.
    - 트리 구조와 Listpack 간의 동기화를 통해, 데이터 삽입, 삭제, 범위 조회 및 스트림 트리밍(trim) 등이 효율적으로 이루어집니다.

### 성능 및 장단점

- 성능:
  - 새로운 엔트리 삽입은 주로 Listpack 내의 연속 메모리 할당과 Radix Tree 업데이트로 O(1) 내지 상수에 가까운 성능을 보임
  - 범위 조회나 특정 ID 검색은 Radix Tree를 통한 이진 탐색(O(log N)) 방식으로 수행됨
- 장점:
  - 시계열 로그, 이벤트 소싱 등 데이터 순서가 중요한 응용 분야에 최적화됨
  - 소비자 그룹 및 PEL 관리 기능을 통해, 분산 환경에서 데이터 처리를 효과적으로 지원함
  - 메모리 압축 및 인덱싱을 통해 대량의 스트림 데이터를 효율적으로 저장
- 단점:
  - 내부 구조가 복합적이어서, 디버깅이나 분석 시 구조 파악이 어려울 수 있음
  - 엔트리 수가 극도로 많아질 경우, 인덱스 업데이트 및 메모리 관리 부담이 증가할 가능성이 있음

## 9. 지리공간 인덱스 (Geospatial Index)

### 내부 구현 상세

- Sorted Set 기반의 지리정보 저장
  - Geohash 인코딩:
    - 경도와 위도 정보를 비트 단위로 교차(interleaving)하여 단일 정수값(geohash)으로 인코딩합니다.
    - 인코딩 과정에서 정밀도(bit 수)가 결정되며, 이를 통해 검색 시 근접한 위치들이 유사한 점수 범위 내에 위치하게 됩니다.
  - Sorted Set 활용:
    - 인코딩된 geohash 값은 Sorted Set의 점수(score)로 저장되고, 원소는 실제 위치의 식별자(예: 장소 이름 또는 좌표 정보)를 포함합니다.
    - Sorted Set의 이진 탐색 및 범위 검색 특성을 활용해, 반경 내 검색이나 사각형 영역 검색을 빠르게 수행할 수 있습니다.
  - 변환 및 검색 알고리즘:
    - 질의 시, 입력된 위도/경도를 geohash로 변환하고, 해당 geohash의 접두사를 기반으로 후보 범위를 산출합니다.
    - 후보 집합에서 실제 거리 계산(예: 하버사인 공식 등)을 적용해 최종 결과를 도출합니다.

### 성능 및 장단점

- 성능:
  - Sorted Set을 사용함에 따라, 범위 검색은 평균 O(log N) 시간 내에 이루어지며, 후보군 추출 후 정밀 계산을 추가로 수행함
  - geohash 계산 및 변환은 매우 빠른 비트 연산으로 처리되어 오버헤드가 적음
- 장점:
  - 별도의 전용 자료구조 없이 기존 Sorted Set 기능을 활용하여 지리정보 검색을 지원함
  - 범위 기반 질의와 근접 검색이 비교적 간단한 구조로 구현되어 있음
  - 인코딩을 통해 지리정보를 숫자형으로 변환하여, 범위 쿼리나 정렬 연산에 최적화됨
- 단점:
  - geohash의 정밀도 한계로 인해 아주 미세한 거리 계산에는 부정확할 수 있음
  - 내부 Sorted Set과 동일한 메모리 오버헤드를 가지며, 정밀도에 따른 추가 계산이 필요함



 각 자료구조의 내부 구현 원리를 이해하면, 실제 애플리케이션에 Redis를 효과적으로 활용하고, 성능 튜닝이나 메모리 관리 측면에서 보다 최적의 전략을 세울 수 있습니다.