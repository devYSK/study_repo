# Redis vs Memcached

## Memcached

Memcached는 무료로 사용할 수 있는 오픈소스이며 분산 메모리 객체 캐시 시스템으로, 웹 어플리케이션에서 자주 사용됩니다. Memcached는 key-value 형태로 데이터를 저장하며, 주로 데이터베이스나 파일 시스템 등에서 데이터를 가져와서 메모리에 캐싱합니다. 이를 통해 빠른 응답 속도를 유지할 수 있습니다.

Memcached는 여러 대의 서버에 데이터를 분산하여 저장하므로, 데이터베이스나 파일 시스템과 같은 중앙 집중형 서버와 달리 확장성이 뛰어납니다. 

### Memcached의 특징

- 데이터를 Key-Value 형태로 메모리에 저장한다.
  - 캐시 용량은 Key는 250byte, Value는 1MB를 지원한다.
- 데이터 타입을 String, Integer만 지원한다.
- 데이터 저장은 오직 메모리에만 저장한다.
- 만약 영구 저장이 필요하다면 해당 데이터를 DB에 저장해 두고, 재부팅 시 DB로부터 데이터를 받아야 한다. (스냅샷 방식)
  - **이러한 이유로 메모리가 부족할 경우 일부 데이터를 삭제하여 메모리를 사용한다.**
  - 메모리에만 저장을 할 수 있기에 복제가 불가능하여 캐시로만 사용을 할 수 있다.
- 멀티쓰레드를 지원한다.
- 수평적 확장이 가능하다.
  - 서버가 몇 대든 상관없이 한 개의 객체만을 활용하여 저장 및 조회할 수 있으므로 대용량의 캐시 시스템을 갖게 된다
-  Consistent hash로 인해 서버가 추가되거나 장애가 일어나더라도 추가되거나 장애가 발생한 캐시 서버의 데이터만 변동이 생길뿐 다른 서버의 변동은 생기지 않게 된다. 
-  Memcahced는 slab 할당자를 이용하여 내부적으로는 메모리 할당을 하지 않고 관리하는 형태를 취한다

## Redis

고성능 키-값 저장소. (Remote Dictionary Server) 

String, list, hash, set, sorted set 등의 자료 구조를 지원하는 In-Memory NoSQL입니다. 

성능은 Memecahced에 버금가면서 다양한 데이터 구조체를 지원함으로써 DB, Cache, Message Queue, Shared Memory 용도로 사용될 수 있습니다. 또한 Redis는 데이터의 지속성을 보장하기 위해 디스크에 데이터를 저장하거나 스냅샷을 생성하는 방법도 제공합니다. 

Redis는 다양한 클라이언트 라이브러리와 함께 사용할 수 있으며, 다양한 언어로 작성된 애플리케이션과 상호작용할 수 있습니다.



# Redis의 특징

- 데이터 타입은 String, Set, List, Sorted set, Hash, Bit arr, HyperLog, Stream을 지원한다.
- 데이터 저장은 메모리를 포함하여 디스크에도 저장을 할 수 있다. 스냅샷을 통해서 디스크에 담을 수 있는데 이를 통해서 비휘발성의 특징도 가지고 있다.
  - **반복적인 스냅샷을 통하여 디스크에 저장해 메모리의 여유 공간을 만들 수 있다.**
- 싱글쓰레드를 지원한다.
- 캐시 용량은 Key와 Value 모두 512MB를 지원한다.
- 데이터를 복제하고, 들어온 데이터를 실시간 업데이트가 가능하여 서버 복제가 가능하다.
  - 이러한 이유로 스토리지로도 사용할 수 있다.
- Lua 익스텐션을 지원해서 로직을 만들어서 적용시킬 수 있다.
- ACID를 유사하게 지원해서 트랜잭션을 걸 수 있다.
- 읽기 성능 증대를 위한 서버 측 리플리케이션을 지원한다.
- 쓰기 성능 증대를 위한 클라이언트 측 샤딩을 지원한다.
- Pub / Sub 메시징 용도로 사용할 수 있다.

* Redis는 jemallo을 사용하는 데, 매번 malloc과 free를 통해서 메모리 할당이 이루어진다.

## Redis vs Memcached

|               | **Redis**                                                    | **Memcached**                                                |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 자료구조      | Strings, Set,, Sorted-Set, Hashes 등 다양한 자료구조 지원. <br />공간 데이터 타입(Geospatial indexs) 지원 | Strings, Intergers 만 지원                                   |
| 데이터 저장   | Memory, Disk                                                 | Memory.                                                      |
| 복제          | Master-Slave, Multi-Master  , 클러스터링, Replication 방식 지원 | Replication지원, <br />Memcached는 클러스터링을 수동으로 구성해야한다 |
| 영속성        | 영속성 데이터 사용. 스냅샷 지원                              | 영구 저장이 필요하다면 해당 데이터를 DB에 저장해 두고, 재부팅 시 DB로부터 데이터를 받아야 한다. 저장하지 않으면 손실된다. 스냅샷 지원 X |
| 파티셔닝      | 샤딩 지원                                                    | 샤딩 지원 X.                                                 |
| 만료시간 지정 | 만료일을 지정하면 만료된 데이터는 캐시처럼 사라짐            | 만료일을 지정하면 만료된 데이터는 캐시처럼 사라짐            |

MemCached

1. 메모리가 삭제되어도 원본 데이터로 복구가 가능하며 장애가 발생하지 않는 경우
2. 단순 조회로 통신 속도만을 향상시키는 목적인 경우
3. 멀티스레드를 활용하여 다중 처리가 필요한 경우

Redis

1. 메모리가 삭제되었을 때 서비스 장애가 발생할 수 있는 경우
2. 다양한 데이터 타입을 활용해서 사용해야 할 경우 



### Redis의 영속성

Redis는 영속성을 보장하기 위해 데이터를 디스크에 저장할 수 있다. 즉, 서버가 내려가더라도 디스크에 저장된 데이터를 읽어서 메모리에 로당하게 된다. 방식은 크게 두 가지가 있다.

- RDB(스냅샷) 방식
  - 순간적으로 메모리에 있는 내용 전체를 디스크에 옮겨 담는 방식
  - 반복적인 스냅샷을 통하여 디스크에 저장해 메모리의 여유 공간을 만들 수 있다.
  - 저장 당시 메모리에 있던 데이터들만 그대로 저장 
  - 자동 저장시 : redis.conf 파일에서 SAVE 옵션으로 시간 기준으로 저장할 수 있다.
  - 수동 저장시 : BGSAVE 커맨드를 이용해 cli 창에서 수동으로 RDB파일을 저장할 수 있다.
- AOF(Append On File) 방식
  - Redis의 모든 wirte/update 연산 자체를 모두 log 파일에 기록하는 형태
  - 데이터 변경 커맨드까지 모두 저장한다.
  - 자동 저장시 : redis.conf 파일에서 auto-aof-rewrite-percentage 옵션으로 크기 기준으로 저장 가능
  - 수동 저장시: BGREWRITEAOF 커맨드를 이용해 CLI창에서 수동으로 AOF 파일 재작성이 가능하다 



### RDB VS AOF 선택 기준

- ﻿﻿백업은 필요하지만 어느 정도의 데이터 손실이 발생해도 괜찮은 경우

    - -> ﻿﻿RDB 단독 사용

    - -> redis.conf 파일에서 SAVE 옵션을 적절히 사용 예) SAVE 900 1

- ﻿﻿장애 상황 직전까지의 모든 데이터가 보장되어야 할 경우

    - ->﻿﻿ AOF 사용(appendonly yes)

    - -> APPENDFSYNC 옵션이 everysec인 경우 최대 1초 사이의 데이터 유실 가능(기본 설정)

- ﻿﻿제일 강력한 내구성이 필요한 경우
    - ﻿﻿RDB & AOF 동시 사용

## Redis 주의점

### 싱글쓰레드 기반이므로 오래 걸리는 연산은 하지 않아야 한다

레디스는 싱글 쓰레드 기반입니다.

그래서 한 번에 딱 하나의 명령어만 실행하기 때문에, 긴 처리시간이 필요한 명령어를 쓰면 불리하고 요청 건을 처리하기 전까지 다른 서비스 요청을 받아들일수 없고 서버가 다운 되는 현상이 일어 날 수 있습니다.

따라서 전체 데이터를 다루는 시간복잡도를 가진 O(N) 명령어 `keys`  `flush`  `getall` 등은 주의해서 사용할 필요가 있습니다.

* KEYS, FLUSHALL, FLUSHDB, Delete COlLECTIONS, Get All Collections, LLEN, SADD, HMSET, ZADD, 



### 메모리 사용량

Redis는 모든 데이터를 메모리에 저장하기 때문에, Redis 인스턴스가 사용하는 메모리 양을 주의해야 합니다. 데이터가 많이 쌓이면 Redis 인스턴스가 다운될 수 있습니다. 따라서 Redis는 메모리 최적화를 고려해야 하며, 필요한 경우 데이터를 디스크에 저장하는 옵션도 제공됩니다.



### Redis 영속성의 문제점

Redis는 fork()를 통해 RDB 형식으로 데이터를 저장할 때, 메모리 복사 비용을 줄이기 위해 COW 기법을 사용합니다. COW 기법은 부모 프로세스와 자식 프로세스가 공유하는 메모리 페이지를 효율적으로 관리하기 위한 기술로, 부모 프로세스의 메모리 페이지를 복제하지 않고, 부모와 자식 프로세스가 공유하다가 한쪽에서 변경이 발생할 때 해당 페이지를 복제합니다.

하지만 이러한 COW 기법으로 인해, Redis에서는 부모 프로세스와 자식 프로세스가 공유하는 메모리 페이지의 내용이 변경될 경우, 해당 페이지를 즉시 복제하지 않고, 변경된 페이지를 변경 전의 상태와 함께 Redis의 background process로 옮겨서 RDB 파일에 저장합니다. 이렇게 함으로써 Redis는 일시적으로 메모리 사용량이 두 배로 늘어나는 문제를 해결합니다.  




Redis의 영속성 문제점은 <u>메모리 사용량이 늘어나는 문제</u> 뿐만 아니라, fork() 호출 시 다른 프로세스와의 충돌 가능성이나, RDB 파일로 저장할 때 Redis의 작업을 일시 중지하고 복사를 시작하므로 대규모 데이터를 다루는 경우에는 <u>I/O 병목 현상이 발생할 수도 있습니다.</u> 

**이러한 문제점을 해결하기 위해 Redis는 AOF(Append Only File) 형식을 제공하고 있습니다.**  



부모 프로세스나 자식 프로세스 중 하나가 데이터를 수정하면 COW 메커니즘으로 인해 해당 데이터의 복사본이 만들어지고, 이는 더 많은 메모리를 필요로합니다. 따라서 write 작업이 많은 경우 Redis 프로세스는 두 배 이상의 메모리를 사용할 수 있습니다. 이는 메모리가 부족할 가능성이 있으므로 여러 개의 Redis 서버를 여러 개의 코어에 배치하는 것이 성능과 안정성 면에서 더 좋은 선택일 수 있습니다.

이렇게 메모리를 두 배를 사용하게 되면 메모리가 부족하게 되어 어떤 문제가 발생할 지 알 수 없게 된다. 그렇기 때문에 하나의 Redis 서버를 하나의 장치에서 사용하는 것보다는 멀티 코어를 활용하기 위해 여러 개의 Redis 서버를 한 서버에 띄우는 것이 좋다.



### Cache stampede

캐시 데이터 만료 직후부터 데이터가 다시 캐싱될 때까지 수많은 조회 요청이 DB로 몰리는 현상

캐시가 만료되어 DB 조회를 하면서 발생하는 문제를 cache stampede라고 한다.

주로 TTL 값이 너무 작게 설정한 경우 발생한다.







### 참조

* https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EA%B0%9C%EB%85%90-%EC%86%8C%EA%B0%9C-%EC%82%AC%EC%9A%A9%EC%B2%98-%EC%BA%90%EC%8B%9C-%EC%84%B8%EC%85%98-%ED%95%9C%EB%88%88%EC%97%90-%EC%8F%99-%EC%A0%95%EB%A6%AC#redis_vs_memcached

* https://studyhardd.tistory.com/94