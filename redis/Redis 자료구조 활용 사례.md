## **Redis 자료구조 활용 사례**

 

### **사례 1 - 좋아요 처리하기**

기본적으로 SNS에서 게시물 좋아요 처리는 한 사용자가 하나의 댓글에 좋아요를 한번씩만 할수 있다.

RDBMS에서 유니크 조건을 걸어서 구현할 수 있지만, 이렇게 insert와 update가 자주 발생하는 경우 RDBMS 성능 저하가 발생하게 된다.

여기서 레디스의 **Set**을 이용하면 간단하게 구현할 수 있으며, 빠른 시간 안에 처리할 수 있다.

**댓글의 번호를 key**로 하고, 해당 댓글에 좋아요를 누른 **회원 ID를 아이템으로 추가**하면 동일한 ID값을 저장할 수 없으므로 한 명의 사용자는 하나의 댓글에 한번 만 좋아요를 누를 수 있게 되는 것이다.

![image-20230401181948985](/Users/ysk/study/study_repo/redis/images//image-20230401181948985.png)

 

 

### **사례 2 - 일일 순 방문자수 구하기**

**순 방문자수** 란 서비스에 사용자가 하루에 여러번 방문했더라도 한번만 카운팅되는 값이다.

간단하게 **중복 방문을 제거한 방문자의 지표**라고 생각하면 된다.

유저는 천만 명이라 가정하고, 일일 방문자 횟수를 집계하며 이 값은 0시를 기준으로 초기화 된다고 하자.

 

실제 서비스에서는 이를 구현하기 위해서는 아래와 같은 방법이 있다.

- Google Analytics와 같은 외부 서비스 이용
- access log 분석
- 접속 정보를 로그파일로 작성하여 배치 프로그램 작성

그러나 밑에 두가지 방법은 실시간으로 데이터를 조회할 수 없다는 단점이 있다.

레디스의 **비트 연산**을 활용하면 간단하게 실시간 순 방문자를 저장하고 조회하는 방법을 구현할 수 있다.

 

사용자 ID는 0부터 순차적으로 증가된다고 가정하고, string의 각 bit를 하나의 사용자로 생각해 보자

그리고 사용자가 서비스에 방문할 때 **사용자 ID에 해당하는 bit를 1로 설정**한다.

1개의 bit가 1명을 의미하므로, 천만 명의 유저는 천만 개의 bit로 표현할 수 있고, 이는 곧 1.2MB정도의 크기이다.

레디스 string의 최대 길이는 512MB이므로 천만 명의 사용자를 나타내는 건 충분하다.

 

2020년 1월 29일에 ID가 7인 사용자가 방문했다고 하자.

그럼 아래 그림처럼 일곱 번째 인덱스를 1로 설정한다.

그러면 이 날에 서비스에 방문한 총방문자 수를 조회하기 위해서는 **이 문자열에서 1로 설정된 bit의 개수**를 구하는 **BITCOUNT** 연산을 사용하면 간단하게 구할수 있게 된다..

> Tip
>
> Redis의 HyperLogLogs 타입으로 이용해도 된다.

![image-20230401181937181](/Users/ysk/study/study_repo/redis/images//image-20230401181937181.png)

> Info
>
> 위 그림을 설명하자면, 만일 15명의 회원이 있다고 하면 비트 15개를 준비하고, 그 회원이 방문하면 회원의 id를 구해 해당 순서 비트를 1로 바꾸고 카운트 한다는 뜻이다.

 

### **사례 3 - 출석 이벤트 구현하기**

**정해진 기간동안 매일 방문한 사용자**를 구하는 서비스를 구현한다면 어떻게 할까?

사례 2번을 이용하여, 구해놓은 string 간의 비트를 비교하는 **BITOP** 커맨드를 사용하면 이 서비스를 구현할 수 있다.

 

2020년 1월 29일부터 31일까지 매일 접속한 사용자는 id가 7인 사용자와 11인 사용자라는 것을 BITOP을 이용한 AND 연산을 통해 쉽게 구할 수 있다.

<img src="/Users/ysk/study/study_repo/redis/images//image-20230401181909424.png" alt="image-20230401181909424" style="zoom:67%;" />

> Info
>
> BITOP AND로 비트 연산 결과값이 1이 나오면 그 회원은 매일 방문 한다는 뜻이된다.

 

 

### **사례 4 - 최근 검색 목록 표시하기**

사내 협업도구의 프로젝트에서 **담당자**를 선택할 때, 매번 멤버를 검색해서 입력해야 하는데, **내가 최근 검색했던 담당자**가 드롭다운 메뉴로 보여지게 만들고 싶다.

![image-20230401181836080](/Users/ysk/study/study_repo/redis/images//image-20230401181836080.png)



만일 ID필드가 123 사용자(나) 가 **최근 검색한 사용자 목록**을 보고 싶다면, RDBMS로는 다음과 같이 쿼리를 날려야 한다.

SQL

```sql
select * from KEYWORD 
where ID = 123 
order by reg_date desc 
limit 5;
```

하지만 이렇게 RDBMS의 테이블을 이용해서 데이터를 저장한다면 중복 제거도 해야 하고, 멤버별로 저장된 데이터의 개수를 확인하고, 오래된 검색어는 삭제하는 작업까지 이루어져야 한다.

 

따라서 애초에 중복이 되지 않고, 정렬되어 있는 레디스의 **sorted set** 을 사용하면 간단하게 구현할 수 있다.

sorted set은 가중치를 기준으로 오름차순으로 정렬되기 때문에, 가중치로 시간을 사용한다면 이 값이 가장 큰, 나중에 입력된 아이템이 맨 마지막 인덱스에 저장된다.

 

멤버 ID가 123인 사람이 최근 검색한 사람은 아래 그림처럼 정렬되어 저장된니.

이때 가중치(score)는 입력 순간의 나노시간을 나타내는데, 가장 처음 검색한 사람의 ID는 46, 가장 마지막 검색한 사람은 50이 되게 구성한다.

![image-20230401181824553](/Users/ysk/study/study_repo/redis/images//image-20230401181824553.png)

 

그러면 만일 내가 ID가 51인 사람을 검색하면 아래처럼 마지막에 데이터가 추가되게 된다.

![image-20230401181807921](/Users/ysk/study/study_repo/redis/images//image-20230401181807921.png) 

단, 항상 다섯 명만 저장한다고 설계했기 때문에, 이를 위해서는 가장 마지막 값을 지워주어야 한다.

그림에서 보면 0번째 인덱스를 지우면 되기는 하는데, 아이템 개수가 6보다 작을 때에는 0번째 인덱스를 삭제하면 안 되기 때문에 매번 아이템의 수를 먼저 확인해야 하는 번거로움이 있게 된다.

 

이때 **sorted set의 음수 인덱스**를 사용하면 된다.

음수 인덱스는 인덱스의 마지막부터 큰 값부터 작은 값으로 매겨지는데, 데이터에 멤버를 추가한 뒤, 항상 -6번째 아이템을 지운다면 특정 개수 이상의 데이터가 저장되는 것을 방지 할 수 있게 된다.

인덱스로 아이템을 지우려면 ZREMRANGEBYRANK 커맨드를 사용하면 된다.

BASH

```shell
> ZREMRANGEBYRANK recent:member:123 -6 -6
```

![image-20230401181742479](/Users/ysk/study/study_repo/redis/images//image-20230401181742479.png)



이렇게 데이터에 멤버를 추가한 뒤, 항상 -6번째 아이템을 지운다면 특정 개수 이상의 데이터가 저장되는 것을 방지할 수 있게 된다.