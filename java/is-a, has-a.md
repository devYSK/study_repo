# 객체지향 관점에서의 is-a, has-a



클래스 간의 관계를 설정할 때 상속 관계를 맺을 지 포함관계를 맺을 지 헷갈리는 경우가 있다.  

* 상속관계 : extends로 상속을 받은 관계
* 포함관계 : 내부 멤버로 갖고 있는 관계 

 

이 때, 클래스간의 관계를 `is-a, has-a` 로 생각을 하면 조금 더 명확하게 구성할 수 있다.



* `is-a` : A is B - A는 B이다 
* `has-a` : A has B - A는 B를 가지고 있다.





## is - a (IS - A, ~는 ~이다. )



is-a는 상속관계에서 사용하는 것이 가장 효율적이다. 

상속을 사용하면 하위 클래스가 상위 클래스에 종속되기 때문에 이질적인 클래스 사이의 관계에서는 상속을 사용하지 않는것이 좋다.

코드를 재사용할 목적으로 서로 관련이 없는 클래스들을 상속관계로 사용하면, 클래스들이 꼬일 수 있다.

  


**is-a**는 추상화(형식이나 클래스와 같은)들 사이의 포함 관계를 의미하며, 한 클래스 A가 다른 클래스 B의 서브클래스(파생클래스)임을 이야기 한다.  타입 A는 타입 B의 명세(*specification*)를 암시한다는 점에서 타입 B의 서브타입이라고도 할 수 있다.

​    


* 원은 **점** 이다.

- 고양이는 **동물**이다.  

  


> is -a 관계는 타입 또는 클래스 간의 has-a 관계와는 대조된다. 
> has - a 및 is - a 관계들 간의 혼동은 실세계 객체 관계 모델에 대한 설계에 있어 자주 발견되는 혼돈점이다. 
>  is - a 관계는 또한 객체 또는 타입 간의 **instance-of** 관계와도 대조된다  .

   


## has - a(HAS - A, ~는 ~를 가지고 있다.)

has-a는 포함, 구성 관계를 의미하며 한 객체가 다른 객체를 포함하고 있는걸 의미한다.  
has-a 관계는 다른 클래스의 기능들 (변수, 메서드)를 받아들여서 자신의 메서드나 변수로 사용한다.    

**has-a**는 포함 관계를 의미하며 한 오브젝트(구성된 객체, 또는 부분/멤버 객체)가 다른 오브젝트에 "속한다(*belongs to*)"를 말한다.

(composite type)    


 단순히 말해, has-a 관계는 객체의 멤버 필드라고 불리는 객체를 말하며, Multiple has-a 관계는 소유 계층구조를 형성하기 위해 결합하는 경우를 말한다





- 자동차는 **타이어**를 가지고 있다.
- 사람은 **눈**을 가지고 있다.
- 전투기는 **날개**를 가지고 있다.



>  또한 포함, 구성 관계는 합성(Composition) 이라는 기법을 사용한다. 



## 예

### 고양이은 동물이다 - is-a

고양이는 동물이기 때문에 동물이라고 해도 이상하지 않다. 

```java
class Animal {}

class Cat extends Animal {}
```



반면에 고양이는 동물을 포함하고 있다 혹은 동물은 고양이을 포함하고 있다는 어울리지 않다. 



```java
class Animal {
  private Cat cat;
}
// 또는

class Cat {
  private Animal animal;
}
// 이 둘은 어울리지 않는다 
```



### 원은 점이다 (Circle - point) - is - a 

원은 점들을 포함하고 있다고 해도 이상하지 않다.

```java
class Circle {
  private Point point;
}
```



반면에 원은 점이다 라고 하면 어울리지 않는다.

```java
class Circle extends Point {}
```



  


---

상속과 클래스의 존재 목적은: 연관성 있는 정보의 묶음이다.

- 그럼 연관성의 기준을 어디까지 잡을 건지? (사람마다 다를 수 있다. 정답은 없다.)  

  


객체지향 프로그래밍에서 모든 클래스를 분석하여 가능한 많은 관계를 맺도록 노력해서 코드의 재사용성을 높일 수 있지만 객체지향에서 클래스간에 관계를 설정하는 일은 쉽지 않다. 상속과 구현, 그리고 합성(포함)에 있어 헷갈리기 때문이다.



  


is~a와 has-a를 이용하여 말이 되도록 구현해 본다면 혼돈하는 부분을 좀 더 명확하게 알 수 있으므로 클래스 설계시에 적용해보자.



> ### 그래도 상속보다는 Composite