# 예외 처리(Exception Handling)

프로그램 실행도중에 발생하는 `에러`는 어쩔 수 없지만, `예외(Exception)`은 프로그래머가 미리 대처를 할 수 있다.

사용자의 원인으로 발생하는 예외는 개발자가 미리 대처를 해줄 수 있다.

  

예외 처리(exception handling)란, 프로그래머가 예기치못한 예외의 발생에 미리 대처하는 코드를 작성하는 것으로, 실행중인 프로그램의 비정상적인 종료를 막고, 상태를 정상상태로 유지하는 것이 목적이다. 



> > 예외처리의 목적
>
> 정의 - 프로그램 실행 시 발생할 수 있는 발생할 수 있는 예외에 대비한 코드를 작성하는것
>
> 목적 - 프로그램의 비정상 종료를 막고 정상적인 실행상태를 유지하는것
>
> * Error(에러클래스) 와 예외(Exception)은 모두 runtime 시에 발생하는 오류이다



발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료되며 처리되지 못한 예외(uncatght exception)는 JVM의 예외처리기(UncaughtExceptionHandler) 가 받아서 예외의 원인을 화면에 출력한다. 



---

### 자바에서 예외 처리 방법 (try, catch, throw, throws, finally)



예외를 처리하기 하기위해서는 try - catch 문을 사용하며 그 구조는 다음과 같다.

* finally 구문로 코드가 실행된 후에 무조건 실행할 코드도 작성할 수 있다.



```java
public static void exceptionHandling(){
    try {
        // do something - 예외가 발생할 수 있는 코드
    } catch (Exception e) {
        // Exception 예외시 처리할 코드
    } catch (OtherException e2) {
        // 위에서 캐치한 Exception과 다른 OtherException 예외시 처리할 코드  
    } catch (AnotherException e3 | AnotherException2 e4) {
        // AnotherException 과 AnotherException2 예외를 같은 동작으로 처리할 코드
    }
  	finally {
        // 예외와 상관없이 항상 실행할 코드
    }
  // try-catch가 종료되면 메소드를 나온다. 
}
```

* try 블럭 ({}) 안에는 예외가 발생할 수 있는 코드를 작성한다. 
* try 블럭 다음 catch 블럭({}) (예외이름, 객체명) 1개 이상의 catch 블럭 이 올 수 있다.
  * 여러 블럭이 올 수 있지만 이중 발생한 예외의 종류와 일치하는 단 한개의 catch블럭만 수행된다. 
* 멀티 catch : `catch (AnotherException e3 | AnotherException2 e4) {`
  * JDK 1.7부터 추가된 기능.
  * " | " 기호를 사양해 여러 catch블럭을 하나로 합칠 수 있으며 합칠 수 있는 예외 클래스의 개수는 제한이 없다.
  * 그러나 같이 catch 되어 있는 예외 클래스가 부모/자식 관계, 즉 상속받은 예외클래스라면 컴파일 에러가 발생 
  * 왜냐하면, 자식 클래스로 잡아낼 수 있는 예외는 부모 클래스로도 잡아낼 수 있기 때문에 코드가 중복된 것이나 마찬가지이기 때문이다. 
  * 또한 멀티캐치는 하나의 블록으로 여러 예외를 처리하는 것이기 때문에 멀티 캐치 블록 내에서는 발생한 예외가 정확이 어디에 속한 것인지 알 수 없다. 그래서 **참조 변수 e에는 ‘|’로 연결된 예외들의 공통 조상 클래스에 대한 정보가 담긴다.**

* try 블럭만 존재할 수 없으며, catch블럭도 세트로 존재한다. 
* if문과 달리 try 블럭이나 catch 블럭 내에 포함된 문장이 하나뿐이여도 괄호{} 를 생략할 수 없다.

* catch 블럭 다음에는 finally가 올 수 있으며, finally 블럭은 예외가 발생하던 발생하지 않던 상관없이 항상 실행할 코드를  작성한다.
* 만약 try문에서 예외가 발생하게 된다면 발생한 라인 밑부분의 코드는 실행이 되지않고 catch문으로 넘어가게 된다. 이와 상관없이 항상 실행할 코드를 finally문에 작성한다

  

> **멀티 catch 문을 작성할때의 주의점**
>
> 상위 예외클래스 블럭이 하위 예외 클래스블럭보다 아래에 위치해야 한다.  
>
> 하위 예외 클래스가 이미 상위 예외 클래스에 속해있기 때문에, 상위 예외 클래스 블럭이 더 앞에있으면 하위 예외 클래스 캐치블럭을 처리하지 않고 상위 예외클래스 캐치블럭이 먼저 처리한다. 

  


> catch 블럭에 있는  Exception Class는 자바에 있는 Exception과 Error의 superClass인 Throwable을 상속한 클래스 중 하나여야만 한다.

  


### finally block

finally block은 try block이 끝난 후 또는 예상치 못한 에러가 발생 했을때도 실행을 보장합니다.

하지만 만약에 JVM이 try catch block을 실행 중에 종료된다면 finally block은 실행되지 않습니다.

마찬가지로 Thread가 try catch block을 실행 중에 interrupt 당하거나 kill 당한다면 finally block은 실행되지 않습니다.

finally block은 cleanup code를 넣어서 resource leak을 막을 용도로 사용하는게 좋습니다.

​     


### printStackTrace(), getMessage()

예외처리를 할 때 발생한 예외의 대한 정보가 담긴 메서드이다.
catch 블럭의 참조변수를 통해 인스턴스에 접근할 수 있다. (Exception `e`) = e가 참조변수이다 

- printStackTrace()
  - 예외 발생 당시에 호출스택(CallStack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.
- getMessage()
  - 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.



> printStaticTrace(PrintStream s) 또는 printStatckTrace(PrintWriter s)를 사용하면 발생한 예외에 대한 정보를 파일에 저장도 가능하다



  


### try-catch문에서의 흐름

* try 블럭 내에서 예외가 발생한 경우
  1. 발생한 예외와 일치하는 catch블럭이 있는지 확인
  2. 일치하는 catch 블럭을 찾게되면 그 catch블럭을 수행하고 try-catch문을 빠져나간다.
  3. 만약 일치하는 catch블럭을 차지 못하면 예외는 처리되지 못하며 메소드 밖으로 던져지게 된다

* try 블럭 내에서 예외가 발생하지 않은 경우
  1. catch블럭을 거치지 않고 finally문으로 넘어가거나, finally 문이 없다면 전체 try-catch문을 빠져나가서 다음 코드를 수행하거나 메소드는 종료된다.





## try-with-resources

- exception시 resources를 자동으로 close() 해준다.
- 사용 로직을 작성할 때 객체는 `AutoCloseable 인터페이스를 구현한 객체`여야 한다.
- java 7 부터 추가됨.

**AutoCloseable 인터페이스**

```java
public interface AutoCloseable{
	void close() throws Exception;
}
```

* 이 인터페이스가 구현되어 있다면 try-with-resources 사용 시 자동으로 open한 리소스를 close() 해준다.  



### **try-catch-finally 예제**

```java
FileOutputStream out = null;
try{
	out = new FIleOutputStream("file.txt");
	// do something
}catch(FileNotFoundException e){
	e.printStackTrace();
}finally{
	if(out != null){
		try{
			out.close();
		}catch(IOException e){
			e.printStackTrace();
		}
	}
}
```

**try-with-resources 예제**

```java
try(FileOutputSTream out = new FileOutpuStream("file.txt")){
	// do something
}catch(IOException e){
	e.printStackTrace()l;
}
```

- 기존의 try-catch-finally 블럭 보다 훨씬 간결하게 처리할 수 있다.





## 예외 발생시키기

`throw` 키워드를 이용해서 개발자가 고의로 직접 예외를 발생시킬 수 있다.

* 연산자 new를 이용해서 발생시키려는 예외클래스의 객체를 만든다음에 키워드 throw 를 통해서 예외를 발생시킨다

```java
Exception e = new Exception("고의 예외");
throw e;

// 또는
throw new Exception("고의 예외");
```

* RuntimeException과 UncheckedException 은 처리 하지 않아도 실행은 되지만, CheckedException은 처리하지 않으면 컴파일이 되지 않는다.

 

## 메서드에 예외 선언해서 try-catch문 사용하지 않고 예외 던지기

throws 키워드를 통해 메서드에 예외를 선언할 수 있다. 여러 개의 메서드를 쉼표로 구분해서 선언할 수 있다. 형태는 다음과 같다.

```java
void method() throws Exception1, Exception2, … ExceptionN {
    // 메서드 내용/
}
```

throws는 메서드 선언부에 예외를 선언해둠으로써,  해당 메서드를 사용하는 사람들이 어떤 예외를 처리해야 하는 지를 알려주는 역할을 한다.



만일, 아래와 같이 모든 예외의 최고 조상인 Exception 클래스를 메서드에  throws로 선언하면 이 메서드는 모든 종류의 예외가 발생할 가능성이 있다는 뜻이다.

```java
void someMethod() throws Exception {
  // 메서드 내용  
}
```

* 이렇게 예외를 선언하면 이 예외뿐만 아니라 그 자손타입의 예외까지도 발생할 수 있다는 점에 주의해야한다.  
   


throws 자체는 예외의 처리와는 관계가 없다.   

throws는 해당 메서드에서 예외를 처리하지 않고, 해당 메서드를 사용하는 쪽이 예외를 처리하도록 책임을 전가하는 역할을 한다.

* 이 메서드를 사용하는 쪽에서는 이에 대한 처리를 강제함으로써 견고한 프로그램 코드를 작성할 수 있도록 도와준다.

```java
public class Test {
  
  public void someMethod() throws Exception {
	  // 메서드 내용  
	}
  
  public void OtherMethod() {
    try {
      someMethod(); // 이 메소드 호출 시 예외처리를 하지 않는다면 컴파일 에러. 
    } catch(Exception e) {
      // 예외 처리
    }
  }
  
}
```

* 만약 OtherMethod에서도 예외 처리를 하지 않고 밖으로 던진다면 다음과 같이 메소드에 throws를 추가해주면 된다

```java
public void OtherMethod() throws Exception {
  someMethod();
}
```



> **throws를 사용하는 것은 주의하고 한번 더 생각해보자.**
>
> 물론 메서드안에서 try/catch문을 사용하면 예외처리를 함으로써 메서드가 복잡해져 읽기 어렵고, 추가적인 예외가 발생할 수 있다.
>
> 이런 상황에서 throws를 사용하면 다른 팀원들이 메서드를 사용하는 상황에 맞게 예외처리를 할 수 있어진다.
> 또한 메서드 이름 옆에 발생할 수 있는 예외가 명시적으로 작성이 되므로 코드작성에 주의를 할 수 도 있다.
>
> 하지만 throws를 계속해서 사용하다보면 main 메서드까지 가게 되는데,
> main 메서드 또한 예외를 throws 하게 된다면 JVM이 대신 처리하게 된다.
> 결국 예외를 처리하지 않은 것과 다름없다..
>
> 때문에 그저 예외처리가 귀찮아서 throws를 사용하는 것은 금물이다.



# 예외 전파

## 예외의 전파



아래와 같은 코드에서 doSomething() 메서드 수행 시 Exception이 발생하면 어떻게 될까?

try 의 별도 catch 문이 존재하지 않아서 Exception은 상위로 throw 가 될까? 아니면 skip 될까?

```java
try{
	doSomething();
}finally{
	System.out.println("finally");
}
```



### **Call Stack**

* https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html

![image-20221127022029415](/Users/ysk/study/study_repo/java/images//image-20221127022029415.png)



JVM에서  메소드가 실행되면 메모리의 stack 영역에 Stack Frame이 쌓이게 된다.

( Execution Stack , Call Stack)

- 메서드의 작업에 필요한 메모리 공간을 제공
- 메서드 호출시 호출 스택에 호출된 메서드를 위한 메모리가 할당되며, 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함) 들과 연산의 중간결과등을 저장하는데 사용됨
- 메소드 작업이 끝나면 할당되었던 메모리공간은 반환되어 비워짐
- 특징
  - 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당
  - 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거
  - 호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드
  - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드



>  즉, stack 영역은 Stack Frame 을 저장하는 Stack 이며, JVM은 오직 Stack Frame을 Push 하고 Pop 하는 작업만 하게 된다.



* Java에서는 Exception 이 발생했을 경우 Exception Handler 가 처리한다. 

  * 메서드에서 Exception이 발생하면 해당 메서드는 **Exception Object(exception의 이름과 설명, 프로그램의 현재 상태, exception 발생 위치의 메서드 리스트[call stack]를 포함)**를 생성하고 JVM에 넘긴다. 

  * 이러한 과정을 `Exception을 던진다(throwing an Exception)`라고 표현한다.



1. Exception이 발생했을 때, Exception Handler는  Exception Handler 를 call stack 을 이용하여 역방향으로 Exception Handler를 탐색한다. 
   * 즉 예외가 발생한 메서드를 실행시키기 위해 실행했던 모든 메서드를 반대 순서대로 찾는다는 것이다. 



2. 탐색하면서 Exception Handler 가 처리할 수 있는 Exception 타입인지 체크 한 뒤 맞다면 처리하고 아니라면 상위로 전달된다. 
   * 즉, 발생한 Exception 에 대해서 처리가 가능한 Handler 를 찾을 때까지 상위로 전달되면서 찾아가게 된다.



3. 적절한 Handler 를 찾지 못한다면 JVM 까지 전달되며, 최종적으로 JVM `default exception handler`가   Exception 을 처리하게 되는데,  모든 call stack을 찾아도 적절한 handler를 찾지 못했다면 default exception handler가 실행된다.

4. default exception handler는 exception 정보를 노출하며 해당 thread를 중지시킨다.





---



# 예외처리 비용

### 예외처리 비용

- 예외를 사용한다는 것 자체가 비용이 비싸다.
  - try-catch를 동작 하면서 발생하는 검사들도 하나의 원인이겠지만,
  - Throwable 생성자의 fillInStackTrace() 메서드가 주 원인이다.
  - 이 메서드는 예외가 발생한 메서드의 **Stack Trace** 를 모두 출력해주기 때문이다.
- 충분히 로직으로 사용할 수 있는 것이라면 Exception보다 Return Type이나 입력 값 등을 통해 작업하는 것이 좋다.



메소드가 실행되면 `메모리의 [STACK]` 영역에 `**Stack Frame**`이 쌓이게 된다.

즉, STACK 영역은 Stack Frame 을 저장하는 Stack 이며, JVM은 오직 Stack Frame을 Push 하고 Pop 하는 작업만 하게 된다.

여기서, **예외가 발생되면** 예외의 내용을 보여주는 Stack Trace의 각 라인은 하나의 **Stack Frame**을 표현하는 것이며, **메모리 영역의 Stack 에 쌓여있는 Stack Frame 들을 pop 하여 출력한다.**



---









# 커스텀 예외 구현 시 고려사항

* https://dzone.com/articles/implementing-custom-exceptions-in-java?fromrel=true

자바 커스텀 예외 구현하기 기사 번역(완료)

우리는 이미 이 블로그에서 예외처리에 대해 많은 대화를 해왔으며 checked exceptions와 unchecked exceptions의 차이를 기술했고 베스트 프렉티스들과 가발자가 흔히하는 실수들이 대해서도 기술했다. 여러분이 이 포스트들을 읽었다면 아마도 여러분은 한가지 패턴을 인식했을 것이다. 여러분은 예외를 발생시킨 상황에 대한 상세 정보를 제공해야 하고 호출자에게 유용할지도 모르는 어떠한 정보도 제외시켜서는 안된다는 것이다.

여러분은 잘 작성한 메시지를 만들어서 표준 예외들을 사용할 수 있다. 자바의 Exception클래스는 이벤트의 종류를 기술하며 메세지는 그 이벤트에 대한 상세정보를 제공해준다. 여러분은 나중에 커스텀 예외를 사용하여 이 개념을 한단계 더 발전시킬 수 있다.

커스텀 예외들은 표준 자바 예외의 부분이 아닌 속성정보들과 메소드들을 추가할 수 있는 유연성을 제공한다. 이러한 특징은 특정 애플리케에션 사용하는 에러코드같은 부가적인 정보를 저장할 수 있게 해주며 또는 사용자에게 발생한 예외를 처리하거나 보여주기 위해 사용될 수 있는 유틸리티 메소드를 제공할 수 있다.

##### 4 Best Practices for Custom Exceptions

여러분이 커스텀 예외 클래스를 구현할 때 따르면 참고하면 좋을 4가지 베스트 프랙티스가 있다. 이 추천사항들은 여러분의 코드와 API를 더 이해하기 쉽게 만들어 주며 작성해야 할 문서의 양도 줄여준다. 또한 여러 개발자가 같은 애플리케이션을 개발하거나 새로운 팀멤버가 여러분의 프로젝트에 참여하거나 그리고 외부의 소프트웨어 벤더가 여러분의 API를 사용하기로 했을 때 빠르게 성과를 내준다.

###### 1. Always Provide a Benefit

이전에 설명했던 부가적인 속성들이나 메소드들에 대한 예제들이 커스텀 예외의 의도를 보여 주었는데 그것은 자바의 표준 예외들에 포함되지 않는 정보나 기능을 제공하는 것이다.

이 것이 가장 중요한 추천사항이다. 그렇게 하지 않을 경우 JDK가 이미 제공하고 있는 방대한 수의 예외들과 비교했을 때 여러분의 커스텀 예외는 어떠한 장점도 제공하지 못하게 된다.

이렇게 여러분이 어떠한 장점 제공할 수 없는 예외를 만드는 것 보다는  오히려 UnsupportedOperationException 이나 IllegalArgumentException 와 같이 표준예외들 중 에서 하나를 사용하는 것이 낫다. 모든 자바 개발자들은 이 예외를 알고 있으며 여러분의 코드와 API를 다 쉽게 이해할 수 있도록 해준다.

###### 2. Follow the Naming Convention

JDK가 제공하는 예외 클래스들을 보면 클래스의 이름들이 모두  “Exception”으로 끝난다는 것을 알 수 있다. 일반적인 네이민 규칙으로 자바 생태계 전체에서 사용되는 규칙이다. 여러분들의 예외 클래스들도 이 규칙을 따르는 것이 좋다.

###### 3. Provide Javadoc Comments for Your Exception Class

이 추천 사항은 말할 필요도 없는 부분이지만 많은 커스텀 예외들이 어떠한 Javadoc코멘트도 없이 만들어진 경우를 많이 보았다.

여러분의 API의 모든 클래스, 맴버변수, 생성자들에 대해서는 문서화 하는 것이 일반적인 베스트프렉티스다. 여러분도 잘 알것이다. 문서화되지 않은 API들은 사용하기 매우 어렵다는 것을 말이다.

예외 클래스들은 여러분의 API에 크게 드러나지 않는 부분 일 수도 있으나 실상은 그렇지 않다. 클라이언트와 직접 관련된 메소드들 중 하나가 예외를 던지면 그 예외는 바로 예외의 일부가 된다. 그렇다는 것은 잘 만들어진 JavaDoc와 문서화가 필요하다는 뜻이다.

Javadoc은 예외가 발생할 수도 있는 상황과 예외의 일반적인 의미를 기술한다. 목적은 다른 개발자들이 여러분의 API를 이해하도록 하고 일반적인 에러상황들을 피하도록 돕는것이다.

/** * The MyBusinessException wraps all checked standard Java exception and enriches them with a custom error code. * You can use this code to retrieve localized error messages and to link to our online documentation. *  * @author TJanssen */ public class MyBusinessException extends Exception { ... }

###### 4. Provide a Constructor That Sets the Cause

여러분의 코드는 커스텀 예외를 던지기 전에 표준예외을 캐치하는 케이스가 꽤 많다. 이 사실을 간과하지 말자. 보통 캐치된 예외에는 여러분이 제품에 발생한 오류를 분석하는데 필요한 중요한 정보가 포함되어 있다. 

아래의 예제를 보면 NumberFormatException은 에러에 대한 상세 정보를 제공한다. MyBusinessException의 cause처럼 cause정보를 설정하지 않으면 이 정보를 잃을 것이다.

public void wrapException(String input) throws MyBusinessException {    try {        // do something    } catch (NumberFormatException e) {        throw new MyBusinessException("A message that describes the error.", e, ErrorCode.INVALID_PORT_CONFIGURATION);    } }

Exception과 RuntimeException은 예외의
원인을 기술하고 있는 Throwable을 받을 수 있는 생성자 메소드를 제공한다. 여러분의 예외도 이렇게 하는 것이 좋다. 발생한 Throwable를 파라미터를 통해 가져올 수 있는 생성자를 최소한 하나를 구현하고 수퍼클래스에 Throwable를 전달해줘야 한다.

public class MyBusinessException extends Exception {    public MyBusinessException(String message, Throwable cause, ErrorCode code) {            super(message, cause);            this.code = code;        }        ... }

여기까지가 커스텀예외를 구현하는데 가장 중요한 베스트프랙티스들이다. 더 많은 팁과 추천사항들을 찾고 있다면 저자가 블로그에 포스트한 “featuring 9 best practices and 7 common mistakes when working with Java exceptions.” 글을 보자.

###### Implementing a Custom Exception

커스텀 checked 예외 생성은 간단하다. 여러분은 이미 저자가 “4 best practices for implementing custom exceptions”을 설명할 때 본 것 들이다

여러분이 checked 예외를 구현하기 위해서는 Exception 클래스를 상속받아야 하는데 커스텀 예외를 구현하기 위해 필요한 유일한 필수 사항이다. 하지만 저자가 초반에 설명했듯이 발생한 예외를 생성자에 주입하기 위한 생성자 메소드를 제공해야 하며 표준 예외보다 비교적 더 나은 이점들을 제공해야 한다.

아래의 예제가 설명해온 것 들을 보여준다. 여러분이 보는 것 처럼 저자는 예외를 기술하는 Javadoc 주석을 추가했으며 수퍼클래스에 발생한 예외를 주입하는 생성자 메소드도 구현했다. 또한 표준 예외보다 나은 장점을 제공하기위해 MyBusinessException은 문제 식별을 위한 에러코드를 저장하는 커스텀 enumeration을 사용한다.클라이언트들은 에러메시지를 보여주기위해 이코드를 사용할 수 있으며 사용자에게  support ticket내에 이 코드를 포함하라고 말해 줄 수 있다.

/** * The MyBusinessException wraps all checked standard Java exception and enriches them with a custom error code. * You can use this code to retrieve localized error messages and to link to our online documentation. *  * @author TJanssen */ public class MyBusinessException extends Exception {    private static final long serialVersionUID = 7718828512143293558 L;    private final ErrorCode code;    public MyBusinessException(ErrorCode code) {        super();        this.code = code;    }    public MyBusinessException(String message, Throwable cause, ErrorCode code) {        super(message, cause);        this.code = code;    }    public MyBusinessException(String message, ErrorCode code) {        super(message);        this.code = code;    }    public MyBusinessException(Throwable cause, ErrorCode code) {        super(cause);        this.code = code;    }    public ErrorCode getCode() {        return this.code;    } }


이 것들이 여러분이 checked 예외 구현을 위해 필요한 것들이다. 여러분은 여러분의 코드에서 MyBusinessException을 던질 수 도 있고 또는 메소드 시그니쳐에 표기할 수 도 있고 try-cache절에서 처리할 수도 있다.

public void handleExceptionInOneBlock() {    try {        wrapException(new String("99999999"));    } catch (MyBusinessException e) {        // handle exception        log.error(e);    } } private void wrapException(String input) throws MyBusinessException {    try {        // do something    } catch (NumberFormatException e) {        throw new MyBusinessException("A message that describes the error.", e, ErrorCode.INVALID_PORT_CONFIGURATION);    } }

###### Implementing an Unchecked Exception

커스텀 unchecked 예외 구현은 checked 예외 구현과 동일하다. 이 글 초반에 설명한대로 동일한 추천사항들을 따라서 만들자. 차이가 하는 있는데  Exception 을 확장하는게 아닌 RuntimeException을 확장한다는 것이다. 

/** * The MyUncheckedBusinessException wraps all unchecked standard Java exception and enriches them with a custom error code. * You can use this code to retrieve localized error messages and to link to our online documentation. *  * @author TJanssen */ public class MyUncheckedBusinessException extends RuntimeException {    private static final long serialVersionUID = -8460356990632230194 L;    private final ErrorCode code;    public MyUncheckedBusinessException(ErrorCode code) {        super();        this.code = code;    }    public MyUncheckedBusinessException(String message, Throwable cause, ErrorCode code) {        super(message, cause);        this.code = code;    }    public MyUncheckedBusinessException(String message, ErrorCode code) {        super(message);        this.code = code;    }    public MyUncheckedBusinessException(Throwable cause, ErrorCode code) {        super(cause);        this.code = code;    }    public ErrorCode getCode() {        return this.code;    } }

다른 unchecked예외를 사용하는 것 처럼 MyUncheckedBusinessException를 사용할 수 있다. 여러분의 코드에서 이 예외를 던질 수 있으며 캐치절에서 이 예외를 사용할 수있다. 여러분의 메소드가 이 예외를 던진다고 기술 할 수도 있지만 굳이 그럴 필요는 없다.

private void wrapException(String input) {    try {        // do something    } catch (NumberFormatException e) {        throw new MyUncheckedBusinessException("A message that describes the error.", e, ErrorCode.INVALID_PORT_CONFIGURATION);    } }

###### Summary

포스트에서 설명했듯이 커스텀 예외구현은 쉽다. 여러분은 커스텀 checked예외를 구현할 때는 Exception를 확장하면 되며 커스텀 unchecked 예외를 구현하려면 RuntimeException을 확장하면 된다.

여기에 추가적으로 여러분의 코드를 더 읽기 쉽게하며 여러분의 API를 더 사용하기 쉽게 해주는 몇가지 베스트 프랙티스들을 따르는 것이 좋다. 다음은 Java로 커스텀 예외를 구현하기 위한 4가지 가장 중요한 베스트 프렉티스이다.

\1. Java표준 예외를 사용하는 것보다 커스텀 예외를 사용하는게 더 많은 이익을 얻는다고 생각할 경우에만 커스텀 예외를 구현하자.
\2. 여러분의 예외클래스의 이름의 끝은 Exception으로 끝나도록 하자.
\3. API 메소드가 어떤 하나의 예외를 기술 하고 있다면, 그 예외는 API의 한부분이 되는 것이며 여러분은 그 예외를 문서화 해야 한다.
\4. 예외의 cause를 설정할 수 있는 생성자를 제공해야 한다. 


출처: https://dzone.com/articles/implementing-custom-exceptions-in-java?fromrel=true



























## 반복문 내에서는 Checked Exception에 대한 처리는 지양해야한다

```
for (String item : items) {
    try {
        insert(item);
    }catch (SQLException e) {
        e.printStackTrace();
    }
}
```

- 반복문 내에서 Checked Exception에 대한 예외처리 구문이 들어가게 되면 성능은 2배 3배 떨어지게 된다. 이러한 경우에는 insert에서 예외 발생 시, RuntimeException으로 한번 Wrapping하여 Exception이 발생 되도록 하고 반복문 내에서는 최대한 예외처리에 대한 코드를 제거하는 것이 성능 상 유리하다.





## 커스텀 예외 만들기

(참고. https://m.blog.naver.com/sthwin/221144722072, https://dzone.com/articles/implementing-custom-exceptions-in-java?fromrel=true)

### 커스텀 예외를 만들때 참고해야 할 4가지 Best Practices

### 1. Always Provide a Benefit

자바 표준 예외들에는 포함되어 있는 다양한 장점을 가지는 기능들이 있다.

이미 JDK가 제공하고 있는 방대한 수의 예외들과 비교했을 때 만들고자 하는 커스텀 예외는 어떠한 장점도 제공하지 못한다면? 커스텀 예외를 만드는 이유를 다시 생각해볼 필요가 있다.

어떠한 장점을 제공할 수 없는 예외를 만드는 것 보다 오히려 UnsupportedOperationException 이나, IllegalArugmentException 과 같은 표준 예외 중 하나를 사용하는 것이 낫다.

### 2. Follow the Naming Convention

JDK가 제공하는 예외 클래스들을 보면 클래스의 이름이 모두 "Exception" 으로 끝나는 것을 알 수 있다.

이러한 네이밍 규칙은 자바 생태계 전체에 사용되는 규칙이다.

즉, 만들고자 하는 커스텀 예외 클래스도 이 네이밍 규칙을 따르는 것이 좋다.

### 3. Provide javadoc Comments for Your Exception Class

많은 커스텀 예외들이 어떠한 javadoc 코멘트도 없이 만들어진 경우들이 있다.

기본적으로 API의 모든 클래스, 멤버변수, 생성자들에 대해서는 문서화 하는 것이 일반적인 Best Practices 이다.

잘 알겠지만 문서화되지 않은 API들은 사용하기 매우 어렵다.

예외 클래스들은 API에 크게 드러나지 않는 부분일 수 있으나 사실상 그렇지 않다.

클라이언트와 직접 관련된 메소드들 중 하나가 에외를 던지면 그 예외는 바로 예외의 일부가 된다.

그렇다는 것은 잘 만들어진 JavaDoc와 문서화가 필요하다는 뜻이다.

JavaDoc은 예외가 발생할 수도 있는 상황과 예외의 일반적인 의미를 기술한다.

목적은 다른 개발자들이 API를 이해하고 일반적인 에러상황들을 피하도록 돕는 것이다.

```java
/**
 * The MyBusinessException wraps all checked standard Java exception and enriches them with a custom error code.
 * You can use this code to retrieve localized error messages and to link to our online documentation.
 * 
 * @author TJanssen
 */
public class MyBusinessException extends Exception { ... }
```

### 4. Provide a Constructor That Sets the Cause

커스텀 예외를 던지기 전에 표준 예외를 Catch 하는 케이스가 꽤 많다.

이 사실을 관과하지 말자.

보통 캐치된 예외에는 제품에 발생한 오류를 분석하는데 필요한 중요한 정보가 포함되어 있다.

아래 예제를 보면 NumberFormatException은 에러에 대한 상세 정보를 제공한다.

MyBusinessException의 cause 처럼 cause 정보를 설정하지 않으면 중요한 정보를 잃을 것이다.

```java
public void wrapException(String input) throws MyBusinessException {
    try {
        // do something
    } catch (NumberFormatException e) {
        throw new MyBusinessException("A message that describes the error.", e, ErrorCode.INVALID_PORT_CONFIGURATION);
    }
}
```

### Exception과 RuntimeException

Exception과 RuntimeException은 **`예외의 원인을 기술하고 있는 Throwable`** 을 받을 수 있는 생성자 메소드를 제공한다.

만들고자 하는 커스텀 예외도 이렇게 하는 것이 좋다.

**발생한 Throwable 를 파라미터를 통해 가져올 수 있는 생성자를 최소한 하나를 구현하고 수퍼클래스에 Throwable을 전달해줘야 한다.**

```java
public class MyBusinessException extends Exception {
    public MyBusinessException(String message, Throwable cause, ErrorCode code) {
            super(message, cause);
            this.code = code;
        }
        ...
}
```

### Implementing a Custom Exception (Checked Exception)

Custom Checked Exception 의 생성은 간단하다.

`**Checked Exception**`을 구현하기 위해서는 **Exception 클래스를 상속받아야 하는데, 커스텀 예외를 구현하기 위해 필요한 유일한 필수사항이다.**

하지만 위에 4가지 Best Practices에서 설명했듯이 발생한 예외를 생성자에 주입하기 위한 생성자 메소드를 제공해야 하며, 표준 예외보다 더 나은 이점들을 제공해야 한다.

아래 예제는 설명해 온 것들을 보여준다.

- 예외를 기술하는 Javadoc 주석을 추가했으며,
- 수퍼클래스에 발생한 예외를 주입하는 생성자 메소드를 구현했다.
- 또한 표준 예외보다 더 나은 장점을 제공하기 위해 MyBusinessException은 문제 식별을 위한 에러코드를 저장하는 커스텀 enumeration을 사용한다.
- 클라이언트들은 에러메세지를 보여주기 위해 이 코드를 사용할 수 있으며, support ticket 내에 이 코드를 포함하도록 유도할 수 있다.

```java
/**
 * The MyBusinessException wraps all checked standard Java exception and enriches them with a custom error code.
 * You can use this code to retrieve localized error messages and to link to our online documentation.
 * 
 * @author TJanssen
 */
public class MyBusinessException extends Exception {
    private static final long serialVersionUID = 7718828512143293558 L;
    private final ErrorCode code;
    public MyBusinessException(ErrorCode code) {
        super();
        this.code = code;
    }
    public MyBusinessException(String message, Throwable cause, ErrorCode code) {
        super(message, cause);
        this.code = code;
    }
    public MyBusinessException(String message, ErrorCode code) {
        super(message);
        this.code = code;
    }
    public MyBusinessException(Throwable cause, ErrorCode code) {
        super(cause);
        this.code = code;
    }
    public ErrorCode getCode() {
        return this.code;
    }
}
```

이 것들이 Checked 예외 구현을 위해 필요한 것들이다.

사용자는 코드에서 MyBusinessException 을 던질 수 도 있고 또는 메소드 시그니쳐에 표기할 수도 있고 try-catch 절에서 처리할 수 있다.

```java
public void handleExceptionInOneBlock() {
    try {
        wrapException(new String("99999999"));
    } catch (MyBusinessException e) {
        // handle exception
        log.error(e);
    }
}
private void wrapException(String input) throws MyBusinessException {
    try {
        // do something
    } catch (NumberFormatException e) {
        throw new MyBusinessException("A message that describes the error.", e, ErrorCode.INVALID_PORT_CONFIGURATION);
    }
}
```

### Implementing an Unchecked Exception

`**Custom Unchecked Exception**` 예외 구현은 checked exception 예외 구현가 동일하다.

한가지 차이가 있는데 **"Exception"을 확장하는 것이 아닌 "RuntimeException"을 확장한다.**

```java
/**
 * The MyUncheckedBusinessException wraps all unchecked standard Java exception and enriches them with a custom error code.
 * You can use this code to retrieve localized error messages and to link to our online documentation.
 * 
 * @author TJanssen
 */
public class MyUncheckedBusinessException extends RuntimeException {
    private static final long serialVersionUID = -8460356990632230194 L;
    private final ErrorCode code;
    public MyUncheckedBusinessException(ErrorCode code) {
        super();
        this.code = code;
    }
    public MyUncheckedBusinessException(String message, Throwable cause, ErrorCode code) {
        super(message, cause);
        this.code = code;
    }
    public MyUncheckedBusinessException(String message, ErrorCode code) {
        super(message);
        this.code = code;
    }
    public MyUncheckedBusinessException(Throwable cause, ErrorCode code) {
        super(cause);
        this.code = code;
    }
    public ErrorCode getCode() {
        return this.code;
    }
}
```

다른 Unchecked 예외를 사용하는 것 처럼 MyUncheckedBusinessException 을 사용할 수 있다.

코드에서 이 예외를 던질 수 있으며 Catch 절에서 이 예외를 사용할 수 있다.

작성한 메소드가 이 예외를 던진다고 기술 할 수도 있지만 굳이 그럴 필요는 없다.

```java
private void wrapException(String input) {
    try {
        // do something
    } catch (NumberFormatException e) {
        throw new MyUncheckedBusinessException("A message that describes the error.", e, ErrorCode.INVALID_PORT_CONFIGURATION);
    }
}
```

### 커스텀 예외 만들기 정리

`Checked` Exception을 구현할 때는 `Exception` 을 확장

`Unchecked` Exception을 구현할 때는 `RuntimeException` 을 확장.

추가적으로 4가지 Best Practices를 따르는 것이 좋다.

1. Java 표준 예외를 사용하는 것 보다 작성한 Custom 예외를 사용하는게 더 많은 이익을 얻는다고 생각할 경우에만 Custom Exception을 구현하자.
2. 작성한 Custom Exception 클래스의 이름의 끝은 "Exception"으로 끝나도록 하자.
3. API 메소드가 어떤 하나의 예외를 기술하고 있다면, 그 예외는 API의 한 부분이 되는 것이며 그 예외를 문서화 해야 한다.
4. 예외의 Cause 를 설정할 수 있는 생성자를 제공해야 한다.











# 자바가 제공하는 기본예외들



### Arithmetic Exception

산술연산에서 예외 조건이 발생했을 때 발생

- 대표적인 / by zero

### ArrayIndexOutOfBounds Exception

잘못된 인덱스로 Array에 엑세스 했을 경우 발생.

인덱스가 음수이거나 배열 크기보다 크거나 같을 때 발생

### ClassNotFoundException

정의한 클래스를 찾을 수 없을 때 발생하는 예외

### FileNotFoundException

파일에 엑세수 할 수 없거나 열리지 않을 경우 발생

### IOException

입출력 작업이 실패하거나 중단될 때 발생

### InterruptedException

Thread가 waiting, sleeping 또는 어던 처리를 하고 있을 떄 interrupt가 되면 발생하는 예외

### NoSuchMethodException

찾을 수 없는 메서드에 엑세스 할 때 이 예외가 발생

### NullPointerException

null 객체의 멤버를 참조할 때 발생

### NumberFormatException

메서드가 문자열을 숫자 형식으로 변환할 수 없는 경우 발생

### StringIndexOutOfBoundsException

문자열에 엑세스 하는 인덱스가 문자열보다 큰 경우거나

음수일 때 발생











# Spring MVC 예외처리

### 커스텀한 예외 만드는 방법

```java
public static class MyException extends Exception{
        private final Integer code;

        public MyException(String message, Integer code) {
            super(message);
            this.code = code;
        }

        @Override
        public synchronized Throwable getCause() {
            System.err.println("code = " + code);
            return super.getCause();
        }
    }

    public static void exception3() throws MyException {
        // 특정 조건 발생시 -> ex) 5 / 0
        throw new MyException("some-message", 500);
    }
}
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ade2aaa-b3e4-49e3-acef-0a8c40fc5d3d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ade2aaa-b3e4-49e3-acef-0a8c40fc5d3d/Untitled.png)

- Spring

```java
@RestControllerAdvice
public static class ExceptionHandlers {
    @ExceptionHandler(RuntimeException.class)
    ResponseEntity<ErrorResponse> handleConstraintViolationException(RuntimeException e) {
        final ErrorResponse response = ErrorResponse.of(ErrorCode.MEMID_NOT_FOUNDED);
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
}
```

Exception이 발생했을 경우 이를 캐치해줄 ExceptionHandler를 만들어준다

여기서는 RuntimeException이 발생한 경우 내가 커스텀한 Response로 예외를 뿌려주게 된다

```java
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class ErrorResponse {

    private String message;
    private int status;
    private String code;

    private ErrorResponse(final ErrorCode code) {
        this.message = code.getMessage();
        this.status = code.getStatus();
        this.code = code.getCode();
    }

    public static ErrorResponse of(final ErrorCode code) {
        return new ErrorResponse(code);
    }

}
```

리턴할 ResponseEntity에 담아줄 ErrorResponse 객체를 만들준다

```java
public enum ErrorCode {
    MEMID_NOT_FOUNDED(400, "member.memId", "memId는 반드시 입력되어야 합니다."),
		MEMCODE_NOT_FOUNDED(401, "member.memCode", "memCode는 반드시 입력되어야 합니다.");

    private final String code;
    private final String message;
    private final int status;

    ErrorCode(final int status, final String code, final String message) {
        this.status = status;
        this.message = message;
        this.code = code;
    }

    public String getMessage() {
        return this.message;
    }

    public String getCode() {
        return code;
    }

    public int getStatus() {
        return status;
    }
}
```

enum을 만들어 각 CASE에 대한 값을 지정해 넣어준다.

```java
public static class NoResultMemCodeException extends RuntimeException{
        public NoResultMemCodeException(String message) {
            super(message);
        }

        public NoResultMemCodeException() {
            super();
        }
    }
```

마지막으로 커스텀 Exception을 만들어 준다





