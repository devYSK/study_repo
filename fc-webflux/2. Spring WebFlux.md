# Part2 Spring Webflux

[toc]





## Spring Servlet Stack

![image-20231009022029301](./images//image-20231009022029301.png)

- ﻿﻿Thread-per-request 모델을 사용하여 요청이 들어올때마다 쓰레드를 할당하여 여러 클라이언트 요청을 동시에 처리
- ﻿﻿SecurityContext를 ThreadLocal에 저장
  - Thread가 바뀌는 리액티브 환경에서는?
- ﻿﻿쓰레드당 하나의 db 요청을 처리
- ﻿-> 요청이 들어올때마다 할당된 쓰레드는
   spring mvc flow, 비즈니스 로직 수행 response 생성, SecurityContext 관리, db 요청, http 요청 등 긴 활동주기를 갖는다



## C10K 문제 (Client 10K)

- ﻿﻿만약 1만개 혹은 그 이상의 클라이언트 요청이 동시에 들어온다면?
- ﻿﻿Servlet container의 쓰레드풀 크기 제한
- ﻿﻿동기 blocking한 연산들로 인해서 작업을 완료 하고 반환되는 쓰레드 수보다 요청 수가 더 많아진다

쓰레드풀을 사용하지 않는다면?

- ﻿﻿쓰레드풀을 사용하지 않고 매번 쓰레드를 만든 다면?
- ﻿﻿쓰레드를 생성하고 제거하는 비용이 비싸다. 시스템 자원 소모가 커지고 성능 저하 발생
- ﻿﻿쓰레드마다 할당되는 스택 메모리로 인해서 메모리 부족 문제가 발생
- ﻿﻿더 많은 쓰레드가 cpu를 점유하기 위해서 컨텍스트 스위칭을 하게 된다



# Spring Reactive Stack

<img src="./images//image-20231009022151164.png" width = 400 height = 650>



# Netty

<img src="./images//image-20231009022433494.png" width = 800 height = 500>

- ﻿﻿비동기 이벤트 기반의 네트워크 어플리케이션 프레임워크
- ﻿﻿HTTP 뿐만 아니라 다양한 프로토콜 지원
- ﻿﻿Java lO, NIO, selector 기반으로 적은 리소스 로 높은 성능 보장
- ﻿﻿불필요한 메모리 copy를 최소한으로
- ﻿﻿유연하며 확장 가능한 이벤트 모델 기반
- ﻿﻿서버와 클라이언트 모두 지원



# EventLoop

<img src="./images//image-20231009154443387.png">

**NIOEventLoop**

* EventExecutor, TaskQueue, Selector를 포 함
*  EventExecutor: task를 실행하는 쓰레드풀
*  TaskQueue: task를 저장하는 queue. 
* eventExecutor가 즉시 task를 수행하지 않고 taskQueue에 넣은 후, 나중에 꺼내서 처리 가능
*  Selector: I/O Multiplexing을 지원

**NIOEventLoop의 task**

*  I/O task와 Non I/O task로 구분
*  I/O task: register를 통해서 내부의 selector에 channel을 등록하고 I/O 준비 완료 이벤트가 발생하면 channel의 pipeline 실행
*  Non I/O task: task queue에서 Runnable 등 실행 가능한 모든 종류의 task를 꺼내서 실행

**NIOEventLoop와 IoRatio**

- ﻿﻿ioRatio를 설정하여 각각 `task 수행에 얼마나 시간을 쓸지` 정할 수 있다
- ﻿﻿기본값은 50
- ﻿﻿I/0 task와 Non I/O task에 가능한한 동일한 시간을 소모
- ﻿﻿1000면 시간을 측정하지 않고 task 수행

**NIOEventLoop의 I/O task**

- ﻿﻿NIOEventLoop를 직접 생성할 수 없기 때문에 NIOEventLoopGroup 사용
- ﻿﻿Nio를 수행하는 `ServerSocketChannel`을 생 성하고 accept network I/0 이벤트를eventLoop에 등록
- ﻿﻿하나의 eventLoopGroup에 여러 개의channel 등록 가능
- ﻿﻿I/0 이벤트 완료시 channel의 pipeline 실행

**EventLoopGroup**

* EventLoop를 포함하는 group
* 생성자를 통해서 내부에 몇 개의 EventLoop를 포함할지 설정 가능

- ﻿﻿group에서 execute는 eventLoopGroup 내의 eventLoop를 순회하면서 execute 실행
- ﻿﻿각각의 eventLoop에 순차적으로 task가 추가 되고 실행하기 때문에 eventExecutor 단위로 놓고 보면 순서가 보장

```java
EventLoopGroup eventLoopGroup = new NioEventLoopGroup(5);

for (int i = 0; i < 12; i!++) {
	final int idx = i;
  
  eventLoopGroup.execute(() -> {
    log.info("i: {}", idx);
  });
}

eventLoopGroup.shutdownGracefully();
```

## Channel

**ChannelFuture**

- ﻿﻿Channel I/O 작업이 완료되면 isDone이 true 가 되는 Future
- ﻿﻿futureListener 등록/삭제를 지원하여 비동기 가능
- ﻿﻿addListener: Channel I/0 작업이 완료되면 수행할 futureListener 등록
- ﻿﻿removeListener: 등록된 futureListener 제거
- ﻿﻿sync: 작업이 완료될때까지 blocking

**NioServerSocketChannel**

<img src="./images//image-20231009160850957.png" width= 550 height = 650>

- `netty에서는 java nio의 Channel을 사용하지 않고 거의 자체 구현`
- ﻿﻿Channel, ServerSocketChannel 모두 자체 구현
- ﻿﻿AbstractChannel: ChannelPipeline를 갖는다
- ﻿﻿AbstractNioChannel: 내부적으로 java.nio.ServerSocketChannel을 저장하고 register할 때 java nio Selector에 등록

**ChannelPipeline**

<img src="./images//image-20231009160958872.png" width = 650 height = 400>

Channel의 I/O 이벤트가 준비되면, EventLoop가 pipeline 실행

*  I/O task에 해당
*  pipeline에서는 결과로 I/O 작업을 수행

전파되는(inbound) I/O 이벤트와 수행하는 (outbound) I/O 작업은 여러 가지 종류가 있 지만..
대부분의 경우  ChannelPipeline으로 I/O read 이벤트가 전파되고
ChannelPipeline은 I/O write 작업을 수행 한다

**ChannelPipeline의 내부** 

![image-20231009161745385](./images//image-20231009161745385.png)

* pipeline는 ChannelHandlerContext의 연속
*  Head context와 Tail context 기본적으로 포함
*  각각의 context는 LinkedList 형태로 next, prev를 통해서 이전 혹은 다음 context에 접 근 가능
*  모든 inbound I/O 이벤트는 next로
*  모든 outbound I/O 작업은 prev로

**ChannelHandlerContext 내부**

![image-20231009161828705](./images//image-20231009161828705.png)

ChannelHandlerContext는 EventExecutor와 ChannelHandler를 포함

ChannelHandler는 I/O 이벤트를 받아서

다음 context에게 넘겨줄 수도 있고,  다음 context에게 넘겨주지 않고 I/O 작업 을 수행할 수도 있다

### ChannelHandlerContext에서 별도의 EventExecutor를 지원하는 이유?
ChannelHandlerContext와 EventExecutor

ChannelHandler에서 시간이 오래 걸리는 연산을 진행한다면?

* EventLoop 쓰레드에서 해당 ChannelHandler에서 blocking
* EventLoop에 등록된 다른 Channel의 I/O 처리 또한 blocking
* 해당 ChannelHandler에서는 EventLoop 쓰레드가 아닌 다른 쓰레드풀을 사용한다면?

이를 위해서 ChannelHandlerContext에 등록된 EventExecutor가 있다면

*  next context가 다른 쓰레드풀에서 동작해야하는구나 라고 판단
*  직접 이벤트 처리를 호출하지 않고 executor.execute로 taskQueue에 넣고 EventLoop 쓰레드는 복귀

### ChannelHandler

Channel의 I/O 이벤트를 처리하거나 I/O 작업 을 수행하는 handler

*  ChannelInboundHandler와 ChannelOutboundHandler
  *  ChannelInboundHandler: Channel I/O 이벤트를 수행
  *  ChannelOutboundHandler: Channel I/O 작업을 수행
  *  ChannelDuplexHandler: ChannelInboundHandler와 ChannelOutboundHandler 모두 구현



#### ChannelInboundHandler

<img src="./images//image-20231009164233289.png" width = 400 height = 650>



inbound I/O 이벤트를 처리하기 위한 handler

*  channelRegistered: channel이 eventLoop에 등록되는 경우
*  channelUnregistered: channel이 eventLoop에서 제거되는 경우
*  channelActive: channel이 active되는 경우
*  channelInactive: channel이 inactive되고 close되는 경우
*  channelRead: channel로부터 메시지를 읽을 준비가 된 경우
*  channelReadComplete: channelRead를 통해서 모든 메시지를 읽은 경우
*  userEventTriggered: user event가 트리거된 경우
*  channelWritabilityChanged: channel이 쓸 수 있는 상태가 변경된 경우. 딱 한번 호출

#### ChannelOutboundHandler

outbound I/O 작업을 가로채서 처리하는 handler

* bind: serverSocketChannel에 bind 요청 시 호출
* connect: socketChannel이 connect 요청 시 호출
* disconnect: socketChannel이 disconnect 요청 시 호출
* deregister: eventLoop로부터 deregister되면 호출
* read: channel에 대한 read 요청 시 호출
* write: channel에 대한 write 요청 시 호출. 나중에 작업하는 handler 가 이전 메세지를 다른 값으로 변경할 수 있다
* flush: flush 작업이 수행된 경우 호출
* close: channel이 닫히면 호출





# Server Sent Event (SSE)

Server Sent Event

*  Chunked Transfer-Encoding 기반
*  chunk 단위로 여러 줄로 구성된 문자열을 전달
*  new line으로 이벤트를 구분
*  문자열은 일반적으로 `<field>: <value>` 형태로 구성

```
id:0
event:add
:comment-i
data:data-0

id:1
event:add
:comment-i
data:data-1

id:2
event:add
:comment-i
data:data-2

id:3
event:add
:comment-i
data:data-3

id:4
event:add
:comment-i
data:data-4
```

* id: 이벤트의 id를 가리킨다
  *  `client에서는 이벤트의 id를 저장하고`
  * `Last-Event-ID 헤더에 첨부하여 가장 마지막으로받은 이벤트가 무엇인지 전달`
  * `이를 이용해서 서버는 lastEventId 보다 큰 이벤트만 전달 가능`
* event: 이벤트의 타입을 표현
* data: 이벤트의 data를 표현
  *  여러 줄의 data 필드를 이용하면 multi line data를 표현 가능
* retry: reconnection을 위한 대기 시간을 클라이언트에게 전달
* comment: field 부분이 빈 케이스. 기능을 한다기보다는 정보를 남기기 위한 역할

