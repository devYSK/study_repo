# 자료구조



# Array & ArrayList & LinkedList 

- [Array](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Array.md)

- [LinkedList](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Linked List.md)

- [Data Structure\] Array vs LinkedList](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Array vs LinkedList.md)

  

- [Array vs Linked List](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#array-vs-linked-list)

* [Array & ArrayList & LinkedList](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Array vs ArrayList vs LinkedList.md)

  

연결리스트와 배열의 차이 84



벡터와 push_back()의 시간복잡도가 O(1)인 이유 85

# 스택 & 큐

- [스택(Stack) & 큐(Queue)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Stack%20%26%20Queue.md)
- [[Data Structure\] Stack과 Queue](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Stack과 Queue.md)

* [Stack and Queue](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#stack-and-queue)

스택과 큐의 차이 86

# 힙

- [힙(Heap)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Heap.md)
- [Data Structure\] Heap](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Heap.md)

* [Binary Heap](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#binary-heap)

# 트리

- [트리(Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Tree.md)

* [트리](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#tree)

* [Data Structure\] Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Tree.md)

* [[Data Structure\] B Tree & B+ Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] B Tree %26 B%2B Tree.md)

* [B-Tree & B+Tree](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/B Tree %26 B%2B Tree.md)

- [이진탐색트리(Binary Search Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Binary Search Tree.md)
- [[Data Structure\] 이진 탐색 트리](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] 이진 탐색 트리.md)

* [red-black-tree](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#red-black-tree)

그래프와 트리, 그리고 BST 87
균형잡힌 트리 : AVL 트리, 레드블랙트리 88

# 그래프

* [Graph](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#graph)

# 해시

- [해시(Hash)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Hash.md)

* [[Data Structure\] Hash(해시)](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Hash(해시).md)

* [hash-table](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#hash-table)

해시테이블 88

# 트라이

- [트라이(Trie)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Trie.md)

* [[Data Structure\] Trie(트라이) 자료구조](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/Trie(트라이).md)

- [[Data Structure\] Tree Map](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master)

---

---

---







# Array & ArrayList & LinkedList 

## 빅오표기법, 시간복잡도와 공간복잡도

- 빅오 표기법 : ‘가장 영향을 많이 끼치는 높은 승수를 가진’ 항의 상수 인자를 빼고 나머지
항을 빼서 나타낸 복잡도표기법
- 공간 복잡도 : 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- 시간 복잡도 : ‘문제를 해결하는 데 걸리는 시간과 입력의 함수 관계

## Array(배열)

같은 타입의 연관된 data를 메모리상에 연속적이며 순차적으로 미리 할당되어 정해진 크기만큼 저장하는 자료구조

논리적 저장 순서와 물리적 저장 순서가 일치하고 index로 해당 element(원소)에 접근할 수 있다.

* 인덱스를 알고있다면 O(1)의 시간 복잡도로 원소에 random access 접근이 가능하다 .
* 삽입 또는 삭제 과정에서 해당 원소에 접근하여 작업을 완료한 뒤, shift(이동) 해야하므로 O(n)의 시간복잡도가 든다. 
  * 삭제 기능에 대한 worst case = O(n)

* Array 특징

  - 고정된 저장 공간(fixed-size)

  - 순차적인 데이터 저장(order)
  - Array의 장점은 조회와 추가가 빠름. 따라서 조회를 자주 해야되는 작업에서는 Array 자료구조를 많이 사용
  - Array의 단점은 고정된 저장공간을 가지므로 선언시에 Array의 크기를 미리 정함. 
    - 이는 메모리 낭비나 추가적인 overhead가 발생할 수 있다.

* 시간복잡도
  * 조회, 접근(access) : O(1)
  * 추가(append) : O(1)
  * 마지막 원소 삭제(delete) : O(1)
  * 삽입(insertion) : O(n) -> 모든 원소들의 인덱스를 shift하기 떄문
  * 삭제 (deletion) : O(n) -> 삽입과 마찬가지
  * 검색(search) : O(n) -> 모든 원소를 조회해야하므로



* 미리 예상하여 정해진 크기보다 더 많은 수의 데이터를 넘어서게 되면 어떻게 해결할 것인가?
  * 동적으로 배열의 크기를 늘리는 자료구조를 사용한다.
  * 기존  size보다 큰 Array를 선언하여 데이터를 옮긴다.
    * 모든 데이터를 옮기고 나서 기존 Array는 삭제.
  * -> Dynamic Array
    * 고정된 사이즈인 array의 한계점을 극복하고자 고안한 자료구조
    * 저장공간이 가득차면 resize를 하여 size를 조절한다. 
    *  resize : data를 계속 추가하다가 기존에 할당된 memory를 초과하게 되면, size를 늘린 array를 선언하고 그곳으로 모든 데이터를 옮김으로써 늘어난 크기의 size를 가진 array가 된다.
    * resize 방법
      1. doubling : 데이터를 추가하다가 크기를 초과하면 기존 array의 사이즈를 2배 높힌 큰 array를 선언하고 그곳으로 모든 데이터를 옮김 -> O(n)

> append의 총 과정을 살펴보면 데이터를 마지막 인덱스에 추가하는(O(1))작업이 대다수, 
>
> size를 넘어설 때는 size를 두 배 늘리고 데이터를 일일이 옮기는 과정 (resize O(n))이 아주 가끔 발생합니다. 
>
> append의 전체적인 시간복잡도는 O(1),  좀 더 정확히 말하면 **amortized** O(1
>
> 가끔 발생하는 O(n)의 resize하는 시간을, 자주 발생하는 O(1)의 작업들이 분담해서 나눠 가짐으로써,
>
> 전체적으로 O(1)의 시간이 걸림.



## LinkedList

Node라는 데이터와 다음 Node의 주소를 가리키는 구조체들로 이루어진 list

물리적인 메모리에서는 array와 다르게 비연속적으로 저장되지만, 자기자신의 다음 노드의 주소를 저장함으로써 

논리적인 연속성을 가진 자료구조



연결리스트에는 단일, 다중 등 여러가지가 존재한다.

종류가 무엇이든, **한 노드에 연결될 노드의 포인터 위치를 가리키는 방식**으로 되어있다.

> 단일은 뒤에 노드만 가리키고, 다중은 앞뒤 노드를 모두 가리키는 차이



* 시간복잡도 -> 자기 자신 다음의 주솟값을 저장함으로써 삭제와 삽입은 O(1)
  * 검색(search) -> O(n)
  * 삽입, 추가 -> O(1)
  * 삭제 -> O(1) 
  * 그러나  원하는 원소를 찾고 삭제해야 하기 때문에 . 삭제 자체에는 O(1) 시간이 걸리지만, 조회하는데 O(n)이 든다
    * 결국 삽입과 삭제에 모두 O(n)이 든다. 

### Array와 LinkedList의 비교

- Array
  - 배열이며, 논리적 저장순서와 물리적 저장순서가 일치한다.
  - 특정 자료형들이 메모리 공간 상에서 연속적으로 이루어져 있다.
  - immutable하다.
  - 인덱스로 해당 원소에 접근할 수 있으며, 인덱스를 알고 있다면 O(1)의 시간 복잡도로 원소에 접근이 가능하다.
    -  즉, `Random Access`가 가능하다.
  - 삭제 또는 삽입 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤, shift해줘야 하므로 비용이 발생한다. O(n)
  - 메모리 공간 활용에 제약이 있다.
- LinkedList
  - 메모리 공간 상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있으며, 각각의 노드가 자신의 다음 노드의 위치를 알고 있는 형태이다.
  - 데이터 검색 시 처음 노드부터 순회해야 한다. 이유는 논리적 저장 순서와 물리적 저장 순서가 다르기 때문이다. O(n)
  - 각 노드들이 메모리 공간 상의 어디에 위치하는지는 각각의 노드들만 알고 있고, 사용자는 제일 첫 번째 노드의 위치만 알고 있는 상태이다.
  - 어떤 원소를 삽입, 삭제 시 그 원소를 찾기 위해 O(n)의 시간이 발생하고 추가적으로 작업을 완료하는 시간까지 O(n)의 시간이 걸린다.
  - 결국, LinkedList는 검색과 삽입, 삭제 과정 모두 O(n)의 시간 복잡도를 갖는다.



* 따라서 얼마만큼의 데이터를 저장할지 미리 알고있고, 조회를 많이 한다면 Array를 사용하는 것이 유리. 
* 반면에 몇개의 데이터를 저장할 지 불확실하고 삽입 삭제가 잦다면 Linked list를 사용하는 것이 유리.



* Array와 Linked List의 memory 할당은 언제 일어나며, 메모리의 어느 영역을 할당?
  * Array : 컴파일 단계에서 할당이 일어나고, 정적 메모리 할당, Stack memory영역에 할당 
  * Linked List : 런타임 단계에서 노드가 추가될 때마다 메모리 할당이 일어나고 동적 메모리 할당. Heap 영역

# 스택 & 큐

- [스택(Stack) & 큐(Queue)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Stack%20%26%20Queue.md)
- [[Data Structure\] Stack과 Queue](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Stack과 Queue.md)

* [Stack and Queue](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#stack-and-queue)

스택과 큐의 차이 86



## 스택(Stack)

선형 자료구조의 일종으로 LIFO(Last In First Out) 특징을 가지고 있다. -> 나중에 들어온것이 먼저 나오고, 

FILO(First In Last Out) 먼저 들어간 원소가 나중에 나온다.

차곡차곡 쌓이는 구조로 먼저 들어간 원소는 밑에 깔리게 된다. 

재귀적인 특징이 있다.

*  언제 사용?
  * 함수의 콜 스택, 깊이 우선 탐색(DFS), 문자열 역순 출력, 후위 표기법, 웹 브라우저 방문 기록 

* 스택의 연산
  * 삽입 : push()
  * 데이터 최상위 값삭제 : pop()
  * 비어있는지 확인 : isEmpty()
  * 꽉차있는지 확인 : isFull()

* push pop할 때는 해당 위치를 알고 있어야 하므로 SP(Stack Pointer)가 필요하다. 기본값은 -1


<details>
<summary>스택 - 자료구조 - 접기/펼치기</summary>

* 스택 포인터는 다음 값이 들어갈 위치를 가리키고 있음 (처음 기본값은 -1)
```java
private int sp = -1;
```

* push
```java
public void push(Object o) {
    if(isFull(o)) {
    return;
    }
    stack[++sp] = o;
}
```
* 스택 포인터가 최대 크기와 같으면 return , 아니면 스택의 최상위 위치에 값을 넣음


* pop
```java
public Object pop() {

    if(isEmpty(sp)) {
        return null;
    }
    
    Object o = stack[sp--];
    return o;

}
```
* 스택 포인터가 0이 되면 null로 return; 아니면 스택의 최상위 위치 값을 꺼내옴

* isEmpty
```java
private boolean isEmpty(int cnt) {
    return sp == -1 ? true : false;
}
```
* 입력 값이 최초 값과 같다면 true, 아니면 false


* isFull
```java
private boolean isFull(int cnt) {
    return sp + 1 == MAX_SIZE ? true : false;
}
```
* 스택 포인터 값+1이 MAX_SIZE와 같으면 true, 아니면 false

### 동적 배열 스택

* 최대 크기가 없는 스택을 만드려면?
  * arraycopy를 활용한 동적배열 사용

```java
public void push(Object o) {
    if(isFull(sp)) {
        Object[] arr = new Object[MAX_SIZE * 2];
        System.arraycopy(stack, 0, arr, 0, MAX_SIZE);
        stack = arr;
        MAX_SIZE *= 2; // 2배로 증가
    }
    
    stack[sp++] = o;
}
```
* 기존 스택의 2배 크기만큼 임시 배열(arr)을 만들고
* arraycopy를 통해 stack의 인덱스 0부터 MAX_SIZE만큼을 arr 배열의 0번째부터 복사한다
* 복사 후에 arr의 참조값을 stack에 덮어씌운다
* 마지막으로 MAX_SIZE의 값을 2배로 증가시켜주면 된다.


#### 스택을 연결리스트로 구현해서도 동적 배열 구현 가능 

```java
public class Node {
    public int data;
    public Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}
```

```java
public class Stack {
    private Node head;
    private Node top;

    public Stack() {
        head = top = null;
    }

    private Node createNode(int data) {
        return new Node(data);
    }

    private boolean isEmpty() {
        return top == null ? true : false;
    }

    public void push(int data) {
        if (isEmpty()) { // 스택이 비어있다면
            head = createNode(data);
            top = head;
        }
        else { //스택이 비어있지 않다면 마지막 위치를 찾아 새 노드를 연결시킨다.
            Node pointer = head;

            while (pointer.next != null)
                pointer = pointer.next;

            pointer.next = createNode(data);
            top = pointer.next;
        }
    }

    public int pop() {
        int popData;
        if (!isEmpty()) { // 스택이 비어있지 않다면!! => 데이터가 있다면!!
            popData = top.data; // pop될 데이터를 미리 받아놓는다.
            Node pointer = head; // 현재 위치를 확인할 임시 노드 포인터

            if (head == top) // 데이터가 하나라면
                head = top = null;
            else { // 데이터가 2개 이상이라면
                while (pointer.next != top) // top을 가리키는 노드를 찾는다.
                    pointer = pointer.next;

                pointer.next = null; // 마지막 노드의 연결을 끊는다.
                top = pointer; // top을 이동시킨다.
            }
            return popData;
        }
        return -1; // -1은 데이터가 없다는 의미로 지정해둠.

    }

}
```


</details>



## 큐(queue)

선형 자료구조. FIFO(First In First Out) 먼저 들어간 데이터가 먼저 나온다.

스택과는 반대로 동작한다. 

* 시간복잡도, 공간복잡도 : O(n)
  * 삽입 및 삭제 : O(1) -> 맨뒤에 데이터를 추가하거나, 맨앞에서 꺼내기만 하면 됌
  * 탐색 : O(n)
* 언제 사용?
  * Cache, 프로세스, 스레드 행렬, 너비우선탐색(bfs), 버퍼(buffer) 등 

* 큐의 연산

  * 삽입 : enqueue()
  * 삭제 및 추출 : dequeue()

  * 비어있는지 확인 : isEmpty()

  * 꽉차있는지 확인 : isFull()



데이터를 넣고 뺄 때 해당 값의 위치를 기억해야 하므로 스택의 스택포인터와 비슷한 역할을 하는 애들이다.

* front : dequeue 할 위치를 기억하는 변수
* rear : enqueue 할 위치를 기억하는 변수

* 구현 방법
  * Array-Based : 배열을 기반으로 구현. 
    * 배열을 기반으로 구현하면 인큐, 디큐 하는 과정에서 남는 메모리가 생기고 낭비가 생긴다.
    * 낭비를 줄이기 위해 Circular Queue(원형 큐) 형식으로 구현할 수 있다.
  * List-Based : Linked List 방식으로 구현하면 재할당이나 메모리 낭비를 방지할 수 있다.

<details>
<summary>Queue 구현방법 Code - 접기/펼치기</summary>

기본값
```java
class Queue {
  private int size = 0;
  private int rear = -1;
  private int front = -1;
  private Object[] queue;
  
  Queue(int size) {
    this.size = size;
    this.queue = new Object[size];
  }

}
```

* enQueue

```java
public void enQueue(Object o) {
    if(isFull()) {
        return;
    }
    queue[++rear] = o;
}
```
* enQueue 시, 가득 찼다면 꽉 차 있는 상태에서 enQueue를 했기 때문에 overflow
* 아니면 rear에 값 넣고 1 증가


* deQueue
```java
public Object deQueue(Object o) {

    if(isEmpty()) { 
        return null;
    }
    
    Object o = queue[front];
    queue[front++] = null;
    return o;
}
```
* deQueue를 할 때 공백이면 underflow
* front에 위치한 값을 object에 꺼낸 후, 꺼낸 위치는 null로 채워줌


* isEmpty
```java
public boolean isEmpty() {
    return front == rear;
}
```
* front와 rear가 같아지면 비어진 것


* isFull
```java
public boolean isFull() {
    return (rear == queueSize-1);
}
```
* rear가 사이즈-1과 같아지면 가득찬 것


* `일반 큐의 단점 : 큐에 빈 메모리가 남아 있어도, 꽉 차있는것으로 판단할 수도 있음`
  * (rear가 끝에 도달했을 때)


#### `이를 개선한 것이 '원형 큐'`

* 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주함!

* 원형 큐는 초기 공백 상태일 때 front와 rear가 0

* 공백, 포화 상태를 쉽게 구분하기 위해 자리 하나를 항상 비워둠

* (index + 1) % size로 순환시킨다
```java
class Queue {
  private int size = 0;
  private int rear = -1;
  private int front = -1;
  private Object[] queue;
  
  Queue(int size) {
    this.size = size;
    this.queue = new Object[size];
  }

}
```

* enQueue
```java
public void enQueue(Object o) {
    if(isFull()) {
        return;
    }
    
    rear = (++rear) % size;
    queue[rear] = o;
}
```

* enQueue 시, 가득 찼다면 꽉 차 있는 상태에서 enQueue를 했기 때문에 overflow


* deQueue
```java
public Object deQueue(Object o) {
    if(isEmpty()) { 
        return null;
    }
    front = (++front) % size;
    Object o = queue[front];
    return o;
}
```

* deQueue를 할 때 공백이면 underflow


* isEmpty
```java
public boolean isEmpty() {
    return front == rear;
}
```

* front와 rear가 같아지면 비어진 것


* isFull
````java
public boolean isFull() {
  return ((rear+1) % size == front);
}
````

* rear + 1 % size가 front와 같으면 가득찬 것

* 원형 큐의 단점 : 메모리 공간은 잘 활용하지만, 배열로 구현되어 있기 때문에 큐의 크기가 제한

### 이를 개선한 것이 '연결리스트 큐'

* 연결리스트 큐는 크기가 제한이 없고 삽입, 삭제가 편리

* enqueue 구현
```java
public void enqueue(E item) {
    Node oldlast = tail; // 기존의 tail 임시 저장
    tail = new Node; // 새로운 tail 생성
    tail.item = item;
    tail.next = null;
    if(isEmpty()) head = tail; // 큐가 비어있으면 head와 tail 모두 같은 노드 가리킴
    else oldlast.next = tail; // 비어있지 않으면 기존 tail의 next = 새로운 tail로 설정
}
```

* 데이터 추가는 끝 부분인 tail에 한다.
* 기존의 tail는 보관하고, 새로운 tail 생성
* 큐가 비었으면 head = tail를 통해 둘이 같은 노드를 가리키도록 한다.
* 큐가 비어있지 않으면, 기존 tail의 next에 새로만든 tail를 설정해준다.


* dequeue 구현
```java
public T dequeue() {
    // 비어있으면
    if(isEmpty()) {
        tail = head;
        return null;
    }
    // 비어있지 않으면
    else {
        T item = head.item; // 빼낼 현재 front 값 저장
        head = head.next; // front를 다음 노드로 설정
        return item;
    }
}
```

* 데이터는 head로부터 꺼낸다. (가장 먼저 들어온 것부터 빼야하므로)
* head의 데이터를 미리 저장해둔다.
* 기존의 head를 그 다음 노드의 head로 설정한다.
* 저장해둔 데이터를 return 해서 값을 빼온다.

* 이처럼 삽입은 tail, 제거는 head로 하면서 삽입/삭제를 스택처럼 O(1)에 가능하도록 구현이 가능하다.

</details>



* 조금 확장한 자료구조들로는 양쪽에서 enqueue와 dequeue가 가능한 deque(double-ended queue)와 
* 시간순서가 아닌 우선순위가 높은 순서로 dequeue할 수 있는 `priority queue`가 있다


<details>
<summary>Queue 두개를 이용한 Stack - 접기/펼치기</summary>

* queue 두 개를 사용하여 stack의 push와 pop를 구현하는 것에 초점을 맞춰서 문제를 해결하면 됩니다
* 편의상 push()에 사용할 queue는 q1이라고 부르고 pop()에 사용할 queue를 q2라고 칭하겠습니다. 
두 개의 queue로 stack을 구현하는 방법은 다음과 같습니다.
  1. push() :: q1으로 enqueue()를 하여 데이터를 저장합니다.
  2. pop() ::
    1. q1에 저장된 데이터의 갯수가 1 이하로 남을 때까지 dequeue()를 한 후, 추출된 데이터를 q2에 enqueue()합니다. 결과적으로 가장 최근에 들어온 데이터를 제외한 모든 데이터는 q2로 옮겨진다.
    2. q1에 남아 있는 하나의 데이터를 dequeue()해서 가장 최근에 저장된 데이터를 반환한다.(LIFO)
    3. 다음에 진행될 pop()을 위와 같은 알고리즘으로 진행하기 위해 q1과 q2의 이름을 swap한다.

* 시간복잡도
  * push() : q1.enqueue()를 한번만 하면 되기 때문에 O(1)의 시간 복잡도.
  * pop() : q1에 저장되어잇는 n개의 원소중 n-1개를 q2로 옮겨야 하므로 O(n)



</details>



<details>
<summary>Queue vs priority queue 비교 설명 - 접기/펼치기</summary>  
* Queue는 먼저 집어 넣은 데이터가 먼저 나오는 선입 선출 (FIFO) 자료구조
* Priority Queue(우선순위 큐)는 들어간 순서에 상관 없이 우선순위가 높은 데이터가 먼저 나온다.

* 시간복잡도
  * Queue : enqueue - O(1), dequeue - O(1)
  * Priority Queue : Push - O(log N), Pop - O(log N)
* 우선순위 큐는 Heap으로 구현할 수 있다.
  * Heap 자료구조는 이진 완전 트리를 활용하는것.

* Heap - [링크](##힙(Heap))
  * 우선순위 큐의 구현과 일치
  * 완전 이진 트리 조건
  * 힙이 되기 위한 조건
    * 각 node에 저장된 값은 child node(자식 노드)들에 저장된 값보다 작거나 같다 -> 최소힙(min heap)
      * 루트 노드가 가장 작은 값이 된다.
    * ![image-20220808215613897](/Users/ysk/study/study_repo/cs/자료구조/images//image-20220808215613897.png) 
      * [이미지 출처](https://dsbook.tistory.com/255)
    * 반대로 각 node에 저장된 값이 child node들에 저장된 값보다 크면 최대 힙(max  heap)

​		

* Heap 구현
  * 트리는 보통 Linked list로 구현
  * 그러나 Heap은 tree임에도 불구하고 배열을 기반으로 구현.
    * 새로운 노드를 힙의 마지막 위치에 추가해야 하는데 그 과정이 수월해짐.
  * 구현의 편의를 위해 보통 0번째 인덱스는 사용하지 않는다.
  * 완전 이진트리의 특성을 활용하여 배열의 index만으로 부모 자식 관계를 정의
    * n번째 node의 왼쪽 자식 노드 = 2n
    * n번째 node의 오른쪽 자식 노드 = 2n + 1
    * n번째 노드의 부모 노드 = n / 2

</details>



<details>
<summary>Stack 두개를 이용한 Queue 구현 - 접기/펼치기</summary>
* ![image-20220808220154301](/Users/ysk/study/study_repo/cs/자료구조/images//image-20220808220154301.png)
* [이미지 출처](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Structure%5D%20Stack%EA%B3%BC%20Queue.md)

1. inbox에 데이터를 삽입 - Push -> 순서는 A, B
2. inbox에 있는 데이터를 Pop 하여 outbox에 Push -> 순서는 B, A가 된다.
3. outbox에 있는 데이터를 pop 하면 -> A, B 순으로 나오게 된다 

* A 스택에 데이터를 쌓고, Pop 하면서 B스택에 데이터를 쌓는데, B스택에서 데이터를 pop 하면 순서대로 나오게 된다.

```java

import java.util.Stack;

/**
 * created by victory_woo on 2020/05/06
 * Stack 2개를 이용해서 Queue 구현하기.
 */
public class StackWithQueue {
    public static void main(String[] args) {
        StackQueue<String> queue = new StackQueue<>();
        queue.enQueue("A");
        queue.enQueue("B");
        queue.enQueue("C");

        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
    }

    static class StackQueue<T> {
        private Stack<T> inBox;
        private Stack<T> outBox;

        StackQueue() {
            inBox = new Stack<>();
            outBox = new Stack<>();
        }

        void enQueue(T item) {
            inBox.push(item);
        }

        Object deQueue() {
            if (outBox.isEmpty()) {
                while (!inBox.isEmpty()) {
                    outBox.push(inBox.pop());
                }
            }

            return outBox.pop();
        }
    }
}
```



</details>



* 공부해볼것
  * Stack을 사용하여 미로찾기 구현
  * Stack으로 괄호 유효성 체크 코드 구현 




# 힙(Heap)

- [힙(Heap)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Heap.md)
- [Data Structure\] Heap](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Heap.md)

* [Binary Heap](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#binary-heap)





# 트리

- [트리(Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Tree.md)

* [트리](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#tree)

* [Data Structure\] Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Tree.md)

* [[Data Structure\] B Tree & B+ Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] B Tree %26 B%2B Tree.md)

* [B-Tree & B+Tree](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/B Tree %26 B%2B Tree.md)

- [이진탐색트리(Binary Search Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Binary Search Tree.md)
- [[Data Structure\] 이진 탐색 트리](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] 이진 탐색 트리.md)

* [red-black-tree](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#red-black-tree)

그래프와 트리, 그리고 BST 87
균형잡힌 트리 : AVL 트리, 레드블랙트리 88

# 그래프

* [Graph](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#graph)

# 해시

- [해시(Hash)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Hash.md)

* [[Data Structure\] Hash(해시)](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Hash(해시).md)

* [hash-table](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#hash-table)

해시테이블 88

# 트라이

- [트라이(Trie)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Trie.md)

* [[Data Structure\] Trie(트라이) 자료구조](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/Trie(트라이).md)

- [[Data Structure\] Tree Map](