# 자료구조



# Array & ArrayList & LinkedList 

- [Array](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Array.md)

- [LinkedList](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Linked List.md)

- [Data Structure\] Array vs LinkedList](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Array vs LinkedList.md)

  

- [Array vs Linked List](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#array-vs-linked-list)

* [Array & ArrayList & LinkedList](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Array vs ArrayList vs LinkedList.md)

  

연결리스트와 배열의 차이 84



벡터와 push_back()의 시간복잡도가 O(1)인 이유 85

# 스택 & 큐

- [스택(Stack) & 큐(Queue)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Stack%20%26%20Queue.md)
- [[Data Structure\] Stack과 Queue](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Stack과 Queue.md)

* [Stack and Queue](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#stack-and-queue)

스택과 큐의 차이 86

# 힙

- [힙(Heap)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Heap.md)
- [Data Structure\] Heap](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Heap.md)

* [Binary Heap](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#binary-heap)

# 트리

- [트리(Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Tree.md)

* [트리](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#tree)

* [Data Structure\] Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Tree.md)

* [[Data Structure\] B Tree & B+ Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] B Tree %26 B%2B Tree.md)

* [B-Tree & B+Tree](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/B Tree %26 B%2B Tree.md)

- [이진탐색트리(Binary Search Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Binary Search Tree.md)
- [[Data Structure\] 이진 탐색 트리](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] 이진 탐색 트리.md)

* [red-black-tree](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#red-black-tree)

그래프와 트리, 그리고 BST 87
균형잡힌 트리 : AVL 트리, 레드블랙트리 88

# 그래프

* [Graph](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#graph)

# 해시

- [해시(Hash)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Hash.md)

* [[Data Structure\] Hash(해시)](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Hash(해시).md)

* [hash-table](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#hash-table)

해시테이블 88

# 트라이

- [트라이(Trie)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Trie.md)

* [[Data Structure\] Trie(트라이) 자료구조](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/Trie(트라이).md)

- [[Data Structure\] Tree Map](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master)

---

---

---







# Array & ArrayList & LinkedList 

## 빅오표기법, 시간복잡도와 공간복잡도

- 빅오 표기법 : ‘가장 영향을 많이 끼치는 높은 승수를 가진’ 항의 상수 인자를 빼고 나머지
항을 빼서 나타낸 복잡도표기법
- 공간 복잡도 : 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- 시간 복잡도 : ‘문제를 해결하는 데 걸리는 시간과 입력의 함수 관계

## Array(배열)

같은 타입의 연관된 data를 메모리상에 연속적이며 순차적으로 미리 할당되어 정해진 크기만큼 저장하는 자료구조

논리적 저장 순서와 물리적 저장 순서가 일치하고 index로 해당 element(원소)에 접근할 수 있다.

* 인덱스를 알고있다면 O(1)의 시간 복잡도로 원소에 random access 접근이 가능하다 .
* 삽입 또는 삭제 과정에서 해당 원소에 접근하여 작업을 완료한 뒤, shift(이동) 해야하므로 O(n)의 시간복잡도가 든다. 
  * 삭제 기능에 대한 worst case = O(n)

* Array 특징

  - 고정된 저장 공간(fixed-size)

  - 순차적인 데이터 저장(order)
  - Array의 장점은 조회와 추가가 빠름. 따라서 조회를 자주 해야되는 작업에서는 Array 자료구조를 많이 사용
  - Array의 단점은 고정된 저장공간을 가지므로 선언시에 Array의 크기를 미리 정함. 
    - 이는 메모리 낭비나 추가적인 overhead가 발생할 수 있다.

* 시간복잡도
  * 조회, 접근(access) : O(1)
  * 추가(append) : O(1)
  * 마지막 원소 삭제(delete) : O(1)
  * 삽입(insertion) : O(n) -> 모든 원소들의 인덱스를 shift하기 떄문
  * 삭제 (deletion) : O(n) -> 삽입과 마찬가지
  * 검색(search) : O(n) -> 모든 원소를 조회해야하므로



* 미리 예상하여 정해진 크기보다 더 많은 수의 데이터를 넘어서게 되면 어떻게 해결할 것인가?
  * 동적으로 배열의 크기를 늘리는 자료구조를 사용한다.
  * 기존  size보다 큰 Array를 선언하여 데이터를 옮긴다.
    * 모든 데이터를 옮기고 나서 기존 Array는 삭제.
  * -> Dynamic Array
    * 고정된 사이즈인 array의 한계점을 극복하고자 고안한 자료구조
    * 저장공간이 가득차면 resize를 하여 size를 조절한다. 
    *  resize : data를 계속 추가하다가 기존에 할당된 memory를 초과하게 되면, size를 늘린 array를 선언하고 그곳으로 모든 데이터를 옮김으로써 늘어난 크기의 size를 가진 array가 된다.
    * resize 방법
      1. doubling : 데이터를 추가하다가 크기를 초과하면 기존 array의 사이즈를 2배 높힌 큰 array를 선언하고 그곳으로 모든 데이터를 옮김 -> O(n)

> append의 총 과정을 살펴보면 데이터를 마지막 인덱스에 추가하는(O(1))작업이 대다수, 
>
> size를 넘어설 때는 size를 두 배 늘리고 데이터를 일일이 옮기는 과정 (resize O(n))이 아주 가끔 발생합니다. 
>
> append의 전체적인 시간복잡도는 O(1),  좀 더 정확히 말하면 **amortized** O(1
>
> 가끔 발생하는 O(n)의 resize하는 시간을, 자주 발생하는 O(1)의 작업들이 분담해서 나눠 가짐으로써,
>
> 전체적으로 O(1)의 시간이 걸림.



## LinkedList

Node라는 데이터와 다음 Node의 주소를 가리키는 구조체들로 이루어진 list

물리적인 메모리에서는 array와 다르게 비연속적으로 저장되지만, 자기자신의 다음 노드의 주소를 저장함으로써 

논리적인 연속성을 가진 자료구조



연결리스트에는 단일, 다중 등 여러가지가 존재한다.

종류가 무엇이든, **한 노드에 연결될 노드의 포인터 위치를 가리키는 방식**으로 되어있다.

> 단일은 뒤에 노드만 가리키고, 다중은 앞뒤 노드를 모두 가리키는 차이



* 시간복잡도 -> 자기 자신 다음의 주솟값을 저장함으로써 삭제와 삽입은 O(1)
  * 검색(search) -> O(n)
  * 삽입, 추가 -> O(1)
  * 삭제 -> O(1) 
  * 그러나  원하는 원소를 찾고 삭제해야 하기 때문에 . 삭제 자체에는 O(1) 시간이 걸리지만, 조회하는데 O(n)이 든다
    * 결국 삽입과 삭제에 모두 O(n)이 든다. 

### Array와 LinkedList의 비교

- Array
  - 배열이며, 논리적 저장순서와 물리적 저장순서가 일치한다.
  - 특정 자료형들이 메모리 공간 상에서 연속적으로 이루어져 있다.
  - immutable하다.
  - 인덱스로 해당 원소에 접근할 수 있으며, 인덱스를 알고 있다면 O(1)의 시간 복잡도로 원소에 접근이 가능하다.
    -  즉, `Random Access`가 가능하다.
  - 삭제 또는 삽입 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤, shift해줘야 하므로 비용이 발생한다. O(n)
  - 메모리 공간 활용에 제약이 있다.
- LinkedList
  - 메모리 공간 상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있으며, 각각의 노드가 자신의 다음 노드의 위치를 알고 있는 형태이다.
  - 데이터 검색 시 처음 노드부터 순회해야 한다. 이유는 논리적 저장 순서와 물리적 저장 순서가 다르기 때문이다. O(n)
  - 각 노드들이 메모리 공간 상의 어디에 위치하는지는 각각의 노드들만 알고 있고, 사용자는 제일 첫 번째 노드의 위치만 알고 있는 상태이다.
  - 어떤 원소를 삽입, 삭제 시 그 원소를 찾기 위해 O(n)의 시간이 발생하고 추가적으로 작업을 완료하는 시간까지 O(n)의 시간이 걸린다.
  - 결국, LinkedList는 검색과 삽입, 삭제 과정 모두 O(n)의 시간 복잡도를 갖는다.



* 따라서 얼마만큼의 데이터를 저장할지 미리 알고있고, 조회를 많이 한다면 Array를 사용하는 것이 유리. 
* 반면에 몇개의 데이터를 저장할 지 불확실하고 삽입 삭제가 잦다면 Linked list를 사용하는 것이 유리.



* Array와 Linked List의 memory 할당은 언제 일어나며, 메모리의 어느 영역을 할당?
  * Array : 컴파일 단계에서 할당이 일어나고, 정적 메모리 할당, Stack memory영역에 할당 
  * Linked List : 런타임 단계에서 노드가 추가될 때마다 메모리 할당이 일어나고 동적 메모리 할당. Heap 영역

# 스택 & 큐

- [스택(Stack) & 큐(Queue)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Stack%20%26%20Queue.md)
- [[Data Structure\] Stack과 Queue](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Stack과 Queue.md)

* [Stack and Queue](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#stack-and-queue)

스택과 큐의 차이 86



## 스택(Stack)

선형 자료구조의 일종으로 LIFO(Last In First Out) 특징을 가지고 있다. -> 나중에 들어온것이 먼저 나오고, 

FILO(First In Last Out) 먼저 들어간 원소가 나중에 나온다.

차곡차곡 쌓이는 구조로 먼저 들어간 원소는 밑에 깔리게 된다. 

재귀적인 특징이 있다.

*  언제 사용?
  * 함수의 콜 스택, 깊이 우선 탐색(DFS), 문자열 역순 출력, 후위 표기법, 웹 브라우저 방문 기록 

* 스택의 연산
  * 삽입 : push()
  * 데이터 최상위 값삭제 : pop()
  * 비어있는지 확인 : isEmpty()
  * 꽉차있는지 확인 : isFull()

* push pop할 때는 해당 위치를 알고 있어야 하므로 SP(Stack Pointer)가 필요하다. 기본값은 -1


<details>
<summary>스택 - 자료구조 - 접기/펼치기</summary>

* 스택 포인터는 다음 값이 들어갈 위치를 가리키고 있음 (처음 기본값은 -1)
```java
private int sp = -1;
```

* push
```java
public void push(Object o) {
    if(isFull(o)) {
    return;
    }
    stack[++sp] = o;
}
```
* 스택 포인터가 최대 크기와 같으면 return , 아니면 스택의 최상위 위치에 값을 넣음


* pop
```java
public Object pop() {

    if(isEmpty(sp)) {
        return null;
    }
    
    Object o = stack[sp--];
    return o;

}
```
* 스택 포인터가 0이 되면 null로 return; 아니면 스택의 최상위 위치 값을 꺼내옴

* isEmpty
```java
private boolean isEmpty(int cnt) {
    return sp == -1 ? true : false;
}
```
* 입력 값이 최초 값과 같다면 true, 아니면 false


* isFull
```java
private boolean isFull(int cnt) {
    return sp + 1 == MAX_SIZE ? true : false;
}
```
* 스택 포인터 값+1이 MAX_SIZE와 같으면 true, 아니면 false

### 동적 배열 스택

* 최대 크기가 없는 스택을 만드려면?
  * arraycopy를 활용한 동적배열 사용

```java
public void push(Object o) {
    if(isFull(sp)) {
        Object[] arr = new Object[MAX_SIZE * 2];
        System.arraycopy(stack, 0, arr, 0, MAX_SIZE);
        stack = arr;
        MAX_SIZE *= 2; // 2배로 증가
    }
    
    stack[sp++] = o;
}
```
* 기존 스택의 2배 크기만큼 임시 배열(arr)을 만들고
* arraycopy를 통해 stack의 인덱스 0부터 MAX_SIZE만큼을 arr 배열의 0번째부터 복사한다
* 복사 후에 arr의 참조값을 stack에 덮어씌운다
* 마지막으로 MAX_SIZE의 값을 2배로 증가시켜주면 된다.


#### 스택을 연결리스트로 구현해서도 동적 배열 구현 가능 

```java
public class Node {
    public int data;
    public Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}
```

```java
public class Stack {
    private Node head;
    private Node top;

    public Stack() {
        head = top = null;
    }

    private Node createNode(int data) {
        return new Node(data);
    }

    private boolean isEmpty() {
        return top == null ? true : false;
    }

    public void push(int data) {
        if (isEmpty()) { // 스택이 비어있다면
            head = createNode(data);
            top = head;
        }
        else { //스택이 비어있지 않다면 마지막 위치를 찾아 새 노드를 연결시킨다.
            Node pointer = head;

            while (pointer.next != null)
                pointer = pointer.next;

            pointer.next = createNode(data);
            top = pointer.next;
        }
    }

    public int pop() {
        int popData;
        if (!isEmpty()) { // 스택이 비어있지 않다면!! => 데이터가 있다면!!
            popData = top.data; // pop될 데이터를 미리 받아놓는다.
            Node pointer = head; // 현재 위치를 확인할 임시 노드 포인터

            if (head == top) // 데이터가 하나라면
                head = top = null;
            else { // 데이터가 2개 이상이라면
                while (pointer.next != top) // top을 가리키는 노드를 찾는다.
                    pointer = pointer.next;

                pointer.next = null; // 마지막 노드의 연결을 끊는다.
                top = pointer; // top을 이동시킨다.
            }
            return popData;
        }
        return -1; // -1은 데이터가 없다는 의미로 지정해둠.

    }

}
```


</details>



## 큐(queue)

선형 자료구조. FIFO(First In First Out) 먼저 들어간 데이터가 먼저 나온다.

스택과는 반대로 동작한다. 

* 시간복잡도, 공간복잡도 : O(n)
  * 삽입 및 삭제 : O(1) -> 맨뒤에 데이터를 추가하거나, 맨앞에서 꺼내기만 하면 됌
  * 탐색 : O(n)
* 언제 사용?
  * Cache, 프로세스, 스레드 행렬, 너비우선탐색(bfs), 버퍼(buffer) 등 

* 큐의 연산

  * 삽입 : enqueue()
  * 삭제 및 추출 : dequeue()

  * 비어있는지 확인 : isEmpty()

  * 꽉차있는지 확인 : isFull()



데이터를 넣고 뺄 때 해당 값의 위치를 기억해야 하므로 스택의 스택포인터와 비슷한 역할을 하는 애들이다.

* front : dequeue 할 위치를 기억하는 변수
* rear : enqueue 할 위치를 기억하는 변수

* 구현 방법
  * Array-Based : 배열을 기반으로 구현. 
    * 배열을 기반으로 구현하면 인큐, 디큐 하는 과정에서 남는 메모리가 생기고 낭비가 생긴다.
    * 낭비를 줄이기 위해 Circular Queue(원형 큐) 형식으로 구현할 수 있다.
  * List-Based : Linked List 방식으로 구현하면 재할당이나 메모리 낭비를 방지할 수 있다.

<details>
<summary>Queue 구현방법 Code - 접기/펼치기</summary>

기본값
```java
class Queue {
  private int size = 0;
  private int rear = -1;
  private int front = -1;
  private Object[] queue;
  
  Queue(int size) {
    this.size = size;
    this.queue = new Object[size];
  }

}
```

* enQueue

```java
public void enQueue(Object o) {
    if(isFull()) {
        return;
    }
    queue[++rear] = o;
}
```
* enQueue 시, 가득 찼다면 꽉 차 있는 상태에서 enQueue를 했기 때문에 overflow
* 아니면 rear에 값 넣고 1 증가


* deQueue
```java
public Object deQueue(Object o) {

    if(isEmpty()) { 
        return null;
    }
    
    Object o = queue[front];
    queue[front++] = null;
    return o;
}
```
* deQueue를 할 때 공백이면 underflow
* front에 위치한 값을 object에 꺼낸 후, 꺼낸 위치는 null로 채워줌


* isEmpty
```java
public boolean isEmpty() {
    return front == rear;
}
```
* front와 rear가 같아지면 비어진 것


* isFull
```java
public boolean isFull() {
    return (rear == queueSize-1);
}
```
* rear가 사이즈-1과 같아지면 가득찬 것


* `일반 큐의 단점 : 큐에 빈 메모리가 남아 있어도, 꽉 차있는것으로 판단할 수도 있음`
  * (rear가 끝에 도달했을 때)


#### `이를 개선한 것이 '원형 큐'`

* 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주함!

* 원형 큐는 초기 공백 상태일 때 front와 rear가 0

* 공백, 포화 상태를 쉽게 구분하기 위해 자리 하나를 항상 비워둠

* (index + 1) % size로 순환시킨다
```java
class Queue {
  private int size = 0;
  private int rear = -1;
  private int front = -1;
  private Object[] queue;
  
  Queue(int size) {
    this.size = size;
    this.queue = new Object[size];
  }

}
```

* enQueue
```java
public void enQueue(Object o) {
    if(isFull()) {
        return;
    }
    
    rear = (++rear) % size;
    queue[rear] = o;
}
```

* enQueue 시, 가득 찼다면 꽉 차 있는 상태에서 enQueue를 했기 때문에 overflow


* deQueue
```java
public Object deQueue(Object o) {
    if(isEmpty()) { 
        return null;
    }
    front = (++front) % size;
    Object o = queue[front];
    return o;
}
```

* deQueue를 할 때 공백이면 underflow


* isEmpty
```java
public boolean isEmpty() {
    return front == rear;
}
```

* front와 rear가 같아지면 비어진 것


* isFull
````java
public boolean isFull() {
  return ((rear+1) % size == front);
}
````

* rear + 1 % size가 front와 같으면 가득찬 것

* 원형 큐의 단점 : 메모리 공간은 잘 활용하지만, 배열로 구현되어 있기 때문에 큐의 크기가 제한

### 이를 개선한 것이 '연결리스트 큐'

* 연결리스트 큐는 크기가 제한이 없고 삽입, 삭제가 편리

* enqueue 구현
```java
public void enqueue(E item) {
    Node oldlast = tail; // 기존의 tail 임시 저장
    tail = new Node; // 새로운 tail 생성
    tail.item = item;
    tail.next = null;
    if(isEmpty()) head = tail; // 큐가 비어있으면 head와 tail 모두 같은 노드 가리킴
    else oldlast.next = tail; // 비어있지 않으면 기존 tail의 next = 새로운 tail로 설정
}
```

* 데이터 추가는 끝 부분인 tail에 한다.
* 기존의 tail는 보관하고, 새로운 tail 생성
* 큐가 비었으면 head = tail를 통해 둘이 같은 노드를 가리키도록 한다.
* 큐가 비어있지 않으면, 기존 tail의 next에 새로만든 tail를 설정해준다.


* dequeue 구현
```java
public T dequeue() {
    // 비어있으면
    if(isEmpty()) {
        tail = head;
        return null;
    }
    // 비어있지 않으면
    else {
        T item = head.item; // 빼낼 현재 front 값 저장
        head = head.next; // front를 다음 노드로 설정
        return item;
    }
}
```

* 데이터는 head로부터 꺼낸다. (가장 먼저 들어온 것부터 빼야하므로)
* head의 데이터를 미리 저장해둔다.
* 기존의 head를 그 다음 노드의 head로 설정한다.
* 저장해둔 데이터를 return 해서 값을 빼온다.

* 이처럼 삽입은 tail, 제거는 head로 하면서 삽입/삭제를 스택처럼 O(1)에 가능하도록 구현이 가능하다.

</details>



* 조금 확장한 자료구조들로는 양쪽에서 enqueue와 dequeue가 가능한 deque(double-ended queue)와 
* 시간순서가 아닌 우선순위가 높은 순서로 dequeue할 수 있는 `priority queue`가 있다


<details>
<summary>Queue 두개를 이용한 Stack - 접기/펼치기</summary>

* queue 두 개를 사용하여 stack의 push와 pop를 구현하는 것에 초점을 맞춰서 문제를 해결하면 됩니다
* 편의상 push()에 사용할 queue는 q1이라고 부르고 pop()에 사용할 queue를 q2라고 칭하겠습니다. 
두 개의 queue로 stack을 구현하는 방법은 다음과 같습니다.
  1. push() :: q1으로 enqueue()를 하여 데이터를 저장합니다.
  2. pop() ::
    1. q1에 저장된 데이터의 갯수가 1 이하로 남을 때까지 dequeue()를 한 후, 추출된 데이터를 q2에 enqueue()합니다. 결과적으로 가장 최근에 들어온 데이터를 제외한 모든 데이터는 q2로 옮겨진다.
    2. q1에 남아 있는 하나의 데이터를 dequeue()해서 가장 최근에 저장된 데이터를 반환한다.(LIFO)
    3. 다음에 진행될 pop()을 위와 같은 알고리즘으로 진행하기 위해 q1과 q2의 이름을 swap한다.

* 시간복잡도
  * push() : q1.enqueue()를 한번만 하면 되기 때문에 O(1)의 시간 복잡도.
  * pop() : q1에 저장되어잇는 n개의 원소중 n-1개를 q2로 옮겨야 하므로 O(n)



</details>



<details>
<summary>Queue vs priority queue 비교 설명 - 접기/펼치기</summary>  
* Queue는 먼저 집어 넣은 데이터가 먼저 나오는 선입 선출 (FIFO) 자료구조
* Priority Queue(우선순위 큐)는 들어간 순서에 상관 없이 우선순위가 높은 데이터가 먼저 나온다.

* 시간복잡도
  * Queue : enqueue - O(1), dequeue - O(1)
  * Priority Queue : Push - O(log N), Pop - O(log N)
* 우선순위 큐는 Heap으로 구현할 수 있다.
  * Heap 자료구조는 이진 완전 트리를 활용하는것.

* Heap - [링크](##힙(Heap))
  * 우선순위 큐의 구현과 일치
  * 완전 이진 트리 조건
  * 힙이 되기 위한 조건
    * 각 node에 저장된 값은 child node(자식 노드)들에 저장된 값보다 작거나 같다 -> 최소힙(min heap)
      * 루트 노드가 가장 작은 값이 된다.
    * ![image-20220808215613897](/Users/ysk/study/study_repo/cs/자료구조/images//image-20220808215613897.png) 
      * [이미지 출처](https://dsbook.tistory.com/255)
    * 반대로 각 node에 저장된 값이 child node들에 저장된 값보다 크면 최대 힙(max  heap)

​		

* Heap 구현
  * 트리는 보통 Linked list로 구현
  * 그러나 Heap은 tree임에도 불구하고 배열을 기반으로 구현.
    * 새로운 노드를 힙의 마지막 위치에 추가해야 하는데 그 과정이 수월해짐.
  * 구현의 편의를 위해 보통 0번째 인덱스는 사용하지 않는다.
  * 완전 이진트리의 특성을 활용하여 배열의 index만으로 부모 자식 관계를 정의
    * n번째 node의 왼쪽 자식 노드 = 2n
    * n번째 node의 오른쪽 자식 노드 = 2n + 1
    * n번째 노드의 부모 노드 = n / 2

</details>



<details>
<summary>Stack 두개를 이용한 Queue 구현 - 접기/펼치기</summary>
* ![image-20220808220154301](/Users/ysk/study/study_repo/cs/자료구조/images//image-20220808220154301.png)
* [이미지 출처](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Structure%5D%20Stack%EA%B3%BC%20Queue.md)

1. inbox에 데이터를 삽입 - Push -> 순서는 A, B
2. inbox에 있는 데이터를 Pop 하여 outbox에 Push -> 순서는 B, A가 된다.
3. outbox에 있는 데이터를 pop 하면 -> A, B 순으로 나오게 된다 

* A 스택에 데이터를 쌓고, Pop 하면서 B스택에 데이터를 쌓는데, B스택에서 데이터를 pop 하면 순서대로 나오게 된다.

```java

import java.util.Stack;

/**
 * created by victory_woo on 2020/05/06
 * Stack 2개를 이용해서 Queue 구현하기.
 */
public class StackWithQueue {
    public static void main(String[] args) {
        StackQueue<String> queue = new StackQueue<>();
        queue.enQueue("A");
        queue.enQueue("B");
        queue.enQueue("C");

        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
    }

    static class StackQueue<T> {
        private Stack<T> inBox;
        private Stack<T> outBox;

        StackQueue() {
            inBox = new Stack<>();
            outBox = new Stack<>();
        }

        void enQueue(T item) {
            inBox.push(item);
        }

        Object deQueue() {
            if (outBox.isEmpty()) {
                while (!inBox.isEmpty()) {
                    outBox.push(inBox.pop());
                }
            }

            return outBox.pop();
        }
    }
}
```



</details>



* 공부해볼것
  * Stack을 사용하여 미로찾기 구현
  * Stack으로 괄호 유효성 체크 코드 구현 



# 트리

- [트리(Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Tree.md)

* [트리](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#tree)

* [Data Structure\] Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Tree.md)

* [[Data Structure\] B Tree & B+ Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] B Tree %26 B%2B Tree.md)

* [B-Tree & B+Tree](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/B Tree %26 B%2B Tree.md)

- [이진탐색트리(Binary Search Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Binary Search Tree.md)
- [[Data Structure\] 이진 탐색 트리](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] 이진 탐색 트리.md)

* [red-black-tree](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#red-black-tree)

그래프와 트리, 그리고 BST 87
균형잡힌 트리 : AVL 트리, 레드블랙트리 88

* 트리는 스택이나 큐, 어레이 같은 선형 자료구조가 아닌 비선형 자료구조.
* 계층적 관계(hierarchical RelationShip)을 표현하는 자료구조 
  * 트리는 `표현`에 집중한다 무엇인가를 저장하고 꺼내야한다는 사고에서 벗어나 트리라는 자료구조를 보자 

* 트리를 구성하고 있는 요소들 
  * Node (노드) : 트리를 구성하는 각각의 요소
  * Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선 
  * Root Node(루트 노드) : 최상위에 있는 노드
  * Leaf Node(Terminal Node, 단말 노드) : 하위에 자식 노드가 연결되어 있지 않은 노드
  * 내부 노드(Internal Node, 비단말 노드) : 단말 노드를 제외한 모드 노드, 루트 노드를 포함. 자식이 있는 노드
* 트리의 특징
  * 부모, 자식 계층 구조를 가짐
  * `트리에는 사이클이 존재할 수 없다 (사이클이 존재하면 트리가 아닌 그래프다 )`
  * 노드의 개수가 N개면 간선은 N-1개. (V - 1 = E)
  * 임의의 두 노드 사이에 경로는 유일무이하게 존재하며, 경로는 유일한 한 경로 뿐이다.
* <img src="/Users/ysk/study/study_repo/cs/자료구조/images//image-20220808222054373.png" alt="image-20220808222054373" style="zoom:67%;" />

* 트리를 순회하는 방식 - 4가지
  1. 전위 순회 (pre-order)
     * 각 루트를 순차적으로 먼저 방문하는 방식
     * root -> 왼쪽자식 오른쪽자식 
     * 1 -> 2 -> 4 -> 8 -> 9 -> 5 -> 10 -> 11 -> 3 -> 6 -> 13 -> 7 -> 14
  2. 중위 순회 (in-order)
     * 왼쪽 하위 트리를 방문한 후 루트를 방문하는 방식
     * 왼쪽자식 -> root -> 오른쪽 자식
     * 8 -> 4 -> 9 -> 2 -> 10 -> 5 -> 11 -> 1 -> 6 -> 13 -> 3 -> 14 -> 7
  3. 후위 순회 (post-order)
     * 왼쪽 하위 트리부터 하위를 모두 방문 후 루트를 방문하는 방식
     * 왼쪽자식 -> 오른쪽자식 -> 부모
     * 8 -> 9 -> 4 -> 2 -> 10 -> 11 -> 5 -> 13 -> 6 -> 14 -> 7 -> 3 -> 1
  4. 레벨 순회(level-order)
     * 루트(부모) 부터 계층 별로 방문하는 방식
     * 1 -> 2- > 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 13 -> 14 



<details>
<summary> 트리 구현 자바 코드 - 접기/펼치기</summary>

```java
public class Tree<T> {
    private Node<T> root;

    public Tree(T rootData) {
        root = new Node<T>();
        root.data = rootData;
        root.children = new ArrayList<Node<T>>();
    }

    public static class Node<T> {
        private T data;
        private Node<T> parent;
        private List<Node<T>> children;
    }
}
```

</details>



## 이진 트리(Binary Tree)

* <img src="/Users/ysk/study/study_repo/cs/자료구조/images//image-20220808222623936.png" alt="image-20220808222623936" style="zoom:80%;" />
  * [이미지 출처](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Structure%5D%20Tree.md)

* 루트 노드를 중심으로 두 개의 서브 트리로 나누어짐 -> 자식이 두개여야만 함

  * 나누어진 서브 트리도 모두 이진 트리여야 한다.
  * 노드가 하나 뿐인 트리도 이진 트리의 정의에 만족한다

* 각 층별로 숫자를 매겨서 이를 트리의 레벨이라고 한다.

  * 레벨은 1부터 시작하고 루트 노드의 레벨은 1.
  * 트리의 최고 레벨을 가르켜 트리의 높이라고 한다. 
    * 루트로부터 밑에 3개가 더있으면 1, 2, 3, 4 -> 4레벨 

* 종류

  * 포화 이진 트리 (Full Binary Tree) : 모든 레벨이 꽉꽉 찬 이진 트리 -> 자식은 2개씩 

    * 레벨별로 노드의 개수가 1, 2, 4, 8, 16 으로 늘어난다 
    * 각 레벨별 최대 노드의 갯수는 2 ^ ( k - 1 )개 (k는 레벨)
    * 레벨 별 노드는 공비가 2인 등비 수열로 볼 수 있다, 
    * 그러므로 높이가 h 인 이진트리가 가질 수 있는 최대 노드 수는 2 ^ h - 1 (h는 높이, 레벨)

    

  * 완전 이진 트리 (Complete Binary tree) : 왼쪽에서 오른쪽으로 차곡차곡 채워진 이진 트리

    * 노드를 삽입할 때 왼쪽부터 차례대로 삽입하는 트리. 왼쪽이 비고 오른쪽이 들어가있는 트리는 완전 이진트리가 아님
    * 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 트리 = 정 이진 트리

  

  * 편향 이진 트리(Skewed Binary Tree) : 모든 노드가 부모의 왼쪽으로 편향되어있거나 오른쪽으로 편향되어 있는 트리

* 규칙

  * 배열로 구성된 이진 트리는 노드의 개수가 n개이고 root가 0이 아닌 1 index에서 시작한다면
    * i 번째 노드에 대해서 parent(i) = i / 2
    * left child(i) = 2i
    * right child(i) = 2i + 1 의 index 값을 갖는다  



## 이진 탐색 트리(BST, Binary Search Tree)

효율적인 탐색을 위해서는 어떻게 찾을까만 고민해서는 안된다.

효율적인 탐색을 위한 효율적인 저장방법이 무엇일까를 고민해야 한다.

이진 탐색 트리는 이진 트리의 일종이다.

이진 탐색 트리는 부모의 오른쪽 하위에는 부모 값보다 큰값인 노드만 저장되고, 왼쪽 하위에느 노드 값보다 작은 값만이 들어간다.

이진 탐색 트리의 목적은 이진 탐색의 장점과 연결리스트의 장점을 합친 것 -> 이진 탐색 + 연결 리스트

BST는 저장과 동시에 정렬을 하는 자료구조.

 따라서 새로운 데이터를 저장할 때 일정한 규칙에 따라 저장을 하게 됩니다. 



* 이진 탐색 - 탐색 소요 시간 O(log N) 
  * 그러나 삽입 삭제가 불가능
* 연결리스트 -> 삽입, 삭제의 시간 복잡도는 O(1) 그러나 탐색 소요 시간이 O(n)
* 효율적인 탐색 소요시간 + 삽입 삭제도 빠르게 만들자는 목적 



### 특징

* 각 노드의 자식이 2개 이하.
* 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 커야함
* 각 노드의 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.
* 데이터의 중복이 반드시 없어야 한다. - 노드에 저장된 키(데이터)값은 유일하다.
  * 검색 목적 자료구조인데, 중복이 많은 경우 트리를 사용하여 검색 속도를 느리게 할 필요가 없다.
    * 트리에 삽입하는 것보다 노드에 count를 가지게 하여 처리하는것이 효율적 

* 이진 탐색 트리의 순회는 중위순회(in-order)방식 (왼쪽 - 루트 - 오른쪽)
  * 중위 순서로 정렬된 순서를 얻을 수 있다.



### 연산

* 검색(탐색) - O(log N) 제일 말단 노드에 원하는 값이 있을경우 높이(h)만큼의 노드를 탐색 -> O(n)
* 삽입
* 삭제
* 트리 생성
* 트리 삭제

### 시간 복잡도

* 균등 트리

* 삽입/삭제/찾기 연산 각각에 대해 모두 평균 시간복잡도는 O(logN), 최악의 시간복잡도는 O(N)
* 검색과 저장, 삭제의 시간복잡도는 모두 O(logn)이고, worst case는 한쪽으로 치우친 tree가 됐을 때 O(n)
  * 계속 작은 값만 들어오는 경우나, 계속 큰 값만 들어오는 경우
* 편향된 트리(정렬된 상태 값을 트리로 만들면 한쪽으로만 뻗음)는 시간복잡도가 O(N)이므로 트리를 사용할 이유가 사라짐 
  * 배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생
* → 이를 바로 잡도록 도와주는 개선된 트리가 AVL Tree, RedBlack Tree

* [참고하면 좋다. 정리가 잘되어있다](https://mommoo.tistory.com/101)



# 힙(Heap)

- [힙(Heap)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Heap.md)
- [Data Structure\] Heap](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Heap.md)

* [Binary Heap](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#binary-heap)



# 그래프

* [Graph](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#graph)

# 해시

- [해시(Hash)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Hash.md)

* [[Data Structure\] Hash(해시)](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Hash(해시).md)

* [hash-table](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#hash-table)

해시테이블 88

# 트라이

- [트라이(Trie)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Trie.md)

* [[Data Structure\] Trie(트라이) 자료구조](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/Trie(트라이).md)

- [[Data Structure\] Tree Map](