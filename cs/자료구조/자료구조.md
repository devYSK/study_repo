# 자료구조



# Array & ArrayList & LinkedList 

- [Array](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Array.md)

- [LinkedList](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Linked List.md)

- [Data Structure\] Array vs LinkedList](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Array vs LinkedList.md)

  

- [Array vs Linked List](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#array-vs-linked-list)

* [Array & ArrayList & LinkedList](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Array vs ArrayList vs LinkedList.md)



# 스택 & 큐

- [스택(Stack) & 큐(Queue)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Stack%20%26%20Queue.md)
- [[Data Structure\] Stack과 Queue](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Stack과 Queue.md)

* [Stack and Queue](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#stack-and-queue)

스택과 큐의 차이 86

# 힙

- [힙(Heap)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Heap.md)
- [Data Structure\] Heap](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Heap.md)

* [Binary Heap](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#binary-heap)

# 트리

- [트리(Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Tree.md)

* [트리](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#tree)

* [Data Structure\] Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Tree.md)

* [[Data Structure\] B Tree & B+ Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] B Tree %26 B%2B Tree.md)

* [B-Tree & B+Tree](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/B Tree %26 B%2B Tree.md)

- [이진탐색트리(Binary Search Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Binary Search Tree.md)
- [[Data Structure\] 이진 탐색 트리](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] 이진 탐색 트리.md)

* [red-black-tree](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#red-black-tree)

그래프와 트리, 그리고 BST 87
균형잡힌 트리 : AVL 트리, 레드블랙트리 88

# 그래프

* [Graph](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#graph)

# 해시

- [해시(Hash)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Hash.md)

* [[Data Structure\] Hash(해시)](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Hash(해시).md)

* [hash-table](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#hash-table)

해시테이블 88

# 트라이

- [트라이(Trie)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Trie.md)

* [[Data Structure\] Trie(트라이) 자료구조](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/Trie(트라이).md)

- [[Data Structure\] Tree Map](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master)

---

---

---







# Array & ArrayList & LinkedList 

## 빅오표기법, 시간복잡도와 공간복잡도

- 빅오 표기법 : ‘가장 영향을 많이 끼치는 높은 승수를 가진 항의 상수 인자를 빼고 나머지 항을 빼서 나타낸 복잡도표기법
- 공간 복잡도 : 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양
- 시간 복잡도 : ‘문제를 해결하는 데 걸리는 시간과 입력의 함수 관계

## Array(배열)

같은 타입의 연관된 data를 메모리상에 연속적이며 순차적으로 미리 할당되어 정해진 크기만큼 저장하는 자료구조

논리적 저장 순서와 물리적 저장 순서가 일치하고 index로 해당 element(원소)에 접근할 수 있다.

* 인덱스를 알고있다면 O(1)의 시간 복잡도로 원소에 random access 접근이 가능하다 .
* 삽입 또는 삭제 과정에서 해당 원소에 접근하여 작업을 완료한 뒤, shift(이동) 해야하므로 O(n)의 시간복잡도가 든다. 
  * 삭제 기능에 대한 worst case = O(n)

* Array 특징

  - 고정된 저장 공간(fixed-size)

  - 순차적인 데이터 저장(order)
  - Array의 장점은 조회와 추가가 빠름. 따라서 조회를 자주 해야되는 작업에서는 Array 자료구조를 많이 사용
  - Array의 단점은 고정된 저장공간을 가지므로 선언시에 Array의 크기를 미리 정함. 
    - 이는 메모리 낭비나 추가적인 overhead가 발생할 수 있다.

* 시간복잡도
  * 조회, 접근(access) : O(1)
  * 추가(append) : O(1)
  * 마지막 원소 삭제(delete) : O(1)
  * 삽입(insertion) : O(n) -> 모든 원소들의 인덱스를 shift하기 떄문
  * 삭제 (deletion) : O(n) -> 삽입과 마찬가지
  * 검색(search) : O(n) -> 모든 원소를 조회해야하므로



* 미리 예상하여 정해진 크기보다 더 많은 수의 데이터를 넘어서게 되면 어떻게 해결할 것인가?
  * 동적으로 배열의 크기를 늘리는 자료구조를 사용한다.
  * 기존  size보다 큰 Array를 선언하여 데이터를 옮긴다.
    * 모든 데이터를 옮기고 나서 기존 Array는 삭제.
  * -> Dynamic Array
    * 고정된 사이즈인 array의 한계점을 극복하고자 고안한 자료구조
    * 저장공간이 가득차면 resize를 하여 size를 조절한다. 
    *  resize : data를 계속 추가하다가 기존에 할당된 memory를 초과하게 되면, size를 늘린 array를 선언하고 그곳으로 모든 데이터를 옮김으로써 늘어난 크기의 size를 가진 array가 된다.
    * resize 방법
      1. doubling : 데이터를 추가하다가 크기를 초과하면 기존 array의 사이즈를 2배 높힌 큰 array를 선언하고 그곳으로 모든 데이터를 옮김 -> O(n)

> append의 총 과정을 살펴보면 데이터를 마지막 인덱스에 추가하는(O(1))작업이 대다수, 
>
> size를 넘어설 때는 size를 두 배 늘리고 데이터를 일일이 옮기는 과정 (resize O(n))이 아주 가끔 발생합니다. 
>
> append의 전체적인 시간복잡도는 O(1),  좀 더 정확히 말하면 **amortized** O(1
>
> 가끔 발생하는 O(n)의 resize하는 시간을, 자주 발생하는 O(1)의 작업들이 분담해서 나눠 가짐으로써,
>
> 전체적으로 O(1)의 시간이 걸림.



## LinkedList

Node라는 데이터와 다음 Node의 주소를 가리키는 구조체들로 이루어진 list

물리적인 메모리에서는 array와 다르게 비연속적으로 저장되지만, 자기자신의 다음 노드의 주소를 저장함으로써 

논리적인 연속성을 가진 자료구조



연결리스트에는 단일, 다중 등 여러가지가 존재한다.

종류가 무엇이든, **한 노드에 연결될 노드의 포인터 위치를 가리키는 방식**으로 되어있다.

> 단일은 뒤에 노드만 가리키고, 다중은 앞뒤 노드를 모두 가리키는 차이



* 시간복잡도 -> 자기 자신 다음의 주솟값을 저장함으로써 삭제와 삽입은 O(1)
  * 검색(search) -> O(n)
  * 삽입, 추가 -> O(1)
  * 삭제 -> O(1) 
  * 그러나  원하는 원소를 찾고 삭제해야 하기 때문에 . 삭제 자체에는 O(1) 시간이 걸리지만, 조회하는데 O(n)이 든다
    * 결국 삽입과 삭제에 모두 O(n)이 든다. 

### Array와 LinkedList의 비교

- Array
  - 배열이며, 논리적 저장순서와 물리적 저장순서가 일치한다.
  - 특정 자료형들이 메모리 공간 상에서 연속적으로 이루어져 있다.
  - immutable하다.
  - 인덱스로 해당 원소에 접근할 수 있으며, 인덱스를 알고 있다면 O(1)의 시간 복잡도로 원소에 접근이 가능하다.
    -  즉, `Random Access`가 가능하다.
  - 삭제 또는 삽입 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤, shift해줘야 하므로 비용이 발생한다. O(n)
  - 메모리 공간 활용에 제약이 있다.
- LinkedList
  - 메모리 공간 상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있으며, 각각의 노드가 자신의 다음 노드의 위치를 알고 있는 형태이다.
  - 데이터 검색 시 처음 노드부터 순회해야 한다. 이유는 논리적 저장 순서와 물리적 저장 순서가 다르기 때문이다. O(n)
  - 각 노드들이 메모리 공간 상의 어디에 위치하는지는 각각의 노드들만 알고 있고, 사용자는 제일 첫 번째 노드의 위치만 알고 있는 상태이다.
  - 어떤 원소를 삽입, 삭제 시 그 원소를 찾기 위해 O(n)의 시간이 발생하고 추가적으로 작업을 완료하는 시간까지 O(n)의 시간이 걸린다.
  - 결국, LinkedList는 검색과 삽입, 삭제 과정 모두 O(n)의 시간 복잡도를 갖는다.



* 따라서 얼마만큼의 데이터를 저장할지 미리 알고있고, 조회를 많이 한다면 Array를 사용하는 것이 유리. 
* 반면에 몇개의 데이터를 저장할 지 불확실하고 삽입 삭제가 잦다면 Linked list를 사용하는 것이 유리.



* Array와 Linked List의 memory 할당은 언제 일어나며, 메모리의 어느 영역을 할당?
  * Array : 컴파일 단계에서 할당이 일어나고, 정적 메모리 할당, Stack memory영역에 할당 
  * Linked List : 런타임 단계에서 노드가 추가될 때마다 메모리 할당이 일어나고 동적 메모리 할당. Heap 영역

# 스택 & 큐

- [스택(Stack) & 큐(Queue)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Data%20Structure/Stack%20%26%20Queue.md)
- [[Data Structure\] Stack과 Queue](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Stack과 Queue.md)

* [Stack and Queue](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#stack-and-queue)

스택과 큐의 차이 86



## 스택(Stack)

선형 자료구조의 일종으로 LIFO(Last In First Out) 특징을 가지고 있다. -> 나중에 들어온것이 먼저 나오고, 

FILO(First In Last Out) 먼저 들어간 원소가 나중에 나온다.

차곡차곡 쌓이는 구조로 먼저 들어간 원소는 밑에 깔리게 된다. 

재귀적인 특징이 있다.

*  언제 사용?
  * 함수의 콜 스택, 깊이 우선 탐색(DFS), 문자열 역순 출력, 후위 표기법, 웹 브라우저 방문 기록 

* 스택의 연산
  * 삽입 : push()
  * 데이터 최상위 값삭제 : pop()
  * 비어있는지 확인 : isEmpty()
  * 꽉차있는지 확인 : isFull()

* push pop할 때는 해당 위치를 알고 있어야 하므로 SP(Stack Pointer)가 필요하다. 기본값은 -1


<details>
<summary>스택 - 자료구조 - 접기/펼치기</summary>

* 스택 포인터는 다음 값이 들어갈 위치를 가리키고 있음 (처음 기본값은 -1)
```java
private int sp = -1;
```

* push
```java
public void push(Object o) {
    if(isFull(o)) {
    return;
    }
    stack[++sp] = o;
}
```
* 스택 포인터가 최대 크기와 같으면 return , 아니면 스택의 최상위 위치에 값을 넣음


* pop
```java
public Object pop() {

    if(isEmpty(sp)) {
        return null;
    }
    
    Object o = stack[sp--];
    return o;

}
```
* 스택 포인터가 0이 되면 null로 return; 아니면 스택의 최상위 위치 값을 꺼내옴

* isEmpty
```java
private boolean isEmpty(int cnt) {
    return sp == -1 ? true : false;
}
```
* 입력 값이 최초 값과 같다면 true, 아니면 false


* isFull
```java
private boolean isFull(int cnt) {
    return sp + 1 == MAX_SIZE ? true : false;
}
```
* 스택 포인터 값+1이 MAX_SIZE와 같으면 true, 아니면 false

### 동적 배열 스택

* 최대 크기가 없는 스택을 만드려면?
  * arraycopy를 활용한 동적배열 사용

```java
public void push(Object o) {
    if(isFull(sp)) {
        Object[] arr = new Object[MAX_SIZE * 2];
        System.arraycopy(stack, 0, arr, 0, MAX_SIZE);
        stack = arr;
        MAX_SIZE *= 2; // 2배로 증가
    }
    
    stack[sp++] = o;
}
```
* 기존 스택의 2배 크기만큼 임시 배열(arr)을 만들고
* arraycopy를 통해 stack의 인덱스 0부터 MAX_SIZE만큼을 arr 배열의 0번째부터 복사한다
* 복사 후에 arr의 참조값을 stack에 덮어씌운다
* 마지막으로 MAX_SIZE의 값을 2배로 증가시켜주면 된다.

#### 스택을 연결리스트로 구현해서도 동적 배열 구현 가능 



```java
public class Node {
    public int data;
    public Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}
```

```java
public class Stack {
    private Node head;
    private Node top;

    public Stack() {
        head = top = null;
    }

    private Node createNode(int data) {
        return new Node(data);
    }

    private boolean isEmpty() {
        return top == null ? true : false;
    }

    public void push(int data) {
        if (isEmpty()) { // 스택이 비어있다면
            head = createNode(data);
            top = head;
        }
        else { //스택이 비어있지 않다면 마지막 위치를 찾아 새 노드를 연결시킨다.
            Node pointer = head;

            while (pointer.next != null)
                pointer = pointer.next;

            pointer.next = createNode(data);
            top = pointer.next;
        }
    }

    public int pop() {
        int popData;
        if (!isEmpty()) { // 스택이 비어있지 않다면!! => 데이터가 있다면!!
            popData = top.data; // pop될 데이터를 미리 받아놓는다.
            Node pointer = head; // 현재 위치를 확인할 임시 노드 포인터

            if (head == top) // 데이터가 하나라면
                head = top = null;
            else { // 데이터가 2개 이상이라면
                while (pointer.next != top) // top을 가리키는 노드를 찾는다.
                    pointer = pointer.next;

                pointer.next = null; // 마지막 노드의 연결을 끊는다.
                top = pointer; // top을 이동시킨다.
            }
            return popData;
        }
        return -1; // -1은 데이터가 없다는 의미로 지정해둠.

    }

}
```


</details>



## 큐(queue)

선형 자료구조. FIFO(First In First Out) 먼저 들어간 데이터가 먼저 나온다.

스택과는 반대로 동작한다. 

* 시간복잡도, 공간복잡도 : O(n)
  * 삽입 및 삭제 : O(1) -> 맨뒤에 데이터를 추가하거나, 맨앞에서 꺼내기만 하면 됌
  * 탐색 : O(n)
* 언제 사용?
  * Cache, 프로세스, 스레드 행렬, 너비우선탐색(bfs), 버퍼(buffer) 등 

* 큐의 연산

  * 삽입 : enqueue()
  * 삭제 및 추출 : dequeue()

  * 비어있는지 확인 : isEmpty()

  * 꽉차있는지 확인 : isFull()



데이터를 넣고 뺄 때 해당 값의 위치를 기억해야 하므로 스택의 스택포인터와 비슷한 역할을 하는 애들이다.

* front : dequeue 할 위치를 기억하는 변수
* rear : enqueue 할 위치를 기억하는 변수

* 구현 방법
  * Array-Based : 배열을 기반으로 구현. 
    * 배열을 기반으로 구현하면 인큐, 디큐 하는 과정에서 남는 메모리가 생기고 낭비가 생긴다.
    * 낭비를 줄이기 위해 Circular Queue(원형 큐) 형식으로 구현할 수 있다.
  * List-Based : Linked List 방식으로 구현하면 재할당이나 메모리 낭비를 방지할 수 있다.

<details>
<summary>Queue 구현방법 Code - 접기/펼치기</summary>

기본값
```java
class Queue {
  private int size = 0;
  private int rear = -1;
  private int front = -1;
  private Object[] queue;
  
  Queue(int size) {
    this.size = size;
    this.queue = new Object[size];
  }

}
```

* enQueue

```java
public void enQueue(Object o) {
    if(isFull()) {
        return;
    }
    queue[++rear] = o;
}
```
* enQueue 시, 가득 찼다면 꽉 차 있는 상태에서 enQueue를 했기 때문에 overflow
* 아니면 rear에 값 넣고 1 증가


* deQueue
```java
public Object deQueue(Object o) {

    if(isEmpty()) { 
        return null;
    }
    
    Object o = queue[front];
    queue[front++] = null;
    return o;
}
```
* deQueue를 할 때 공백이면 underflow
* front에 위치한 값을 object에 꺼낸 후, 꺼낸 위치는 null로 채워줌


* isEmpty
```java
public boolean isEmpty() {
    return front == rear;
}
```
* front와 rear가 같아지면 비어진 것


* isFull
```java
public boolean isFull() {
    return (rear == queueSize-1);
}
```
* rear가 사이즈-1과 같아지면 가득찬 것


* `일반 큐의 단점 : 큐에 빈 메모리가 남아 있어도, 꽉 차있는것으로 판단할 수도 있음`
  * (rear가 끝에 도달했을 때)


#### `이를 개선한 것이 '원형 큐'`

* 논리적으로 배열의 처음과 끝이 연결되어 있는 것으로 간주함!

* 원형 큐는 초기 공백 상태일 때 front와 rear가 0

* 공백, 포화 상태를 쉽게 구분하기 위해 자리 하나를 항상 비워둠

* (index + 1) % size로 순환시킨다
```java
class Queue {
  private int size = 0;
  private int rear = -1;
  private int front = -1;
  private Object[] queue;
  
  Queue(int size) {
    this.size = size;
    this.queue = new Object[size];
  }

}
```

* enQueue
```java
public void enQueue(Object o) {
    if(isFull()) {
        return;
    }
    
    rear = (++rear) % size;
    queue[rear] = o;
}
```

* enQueue 시, 가득 찼다면 꽉 차 있는 상태에서 enQueue를 했기 때문에 overflow


* deQueue
```java
public Object deQueue(Object o) {
    if(isEmpty()) { 
        return null;
    }
    front = (++front) % size;
    Object o = queue[front];
    return o;
}
```

* deQueue를 할 때 공백이면 underflow


* isEmpty
```java
public boolean isEmpty() {
    return front == rear;
}
```

* front와 rear가 같아지면 비어진 것


* isFull
````java
public boolean isFull() {
  return ((rear+1) % size == front);
}
````

* rear + 1 % size가 front와 같으면 가득찬 것

* 원형 큐의 단점 : 메모리 공간은 잘 활용하지만, 배열로 구현되어 있기 때문에 큐의 크기가 제한

### 이를 개선한 것이 '연결리스트 큐'

* 연결리스트 큐는 크기가 제한이 없고 삽입, 삭제가 편리

* enqueue 구현
```java
public void enqueue(E item) {
    Node oldlast = tail; // 기존의 tail 임시 저장
    tail = new Node; // 새로운 tail 생성
    tail.item = item;
    tail.next = null;
    if(isEmpty()) head = tail; // 큐가 비어있으면 head와 tail 모두 같은 노드 가리킴
    else oldlast.next = tail; // 비어있지 않으면 기존 tail의 next = 새로운 tail로 설정
}
```

* 데이터 추가는 끝 부분인 tail에 한다.
* 기존의 tail는 보관하고, 새로운 tail 생성
* 큐가 비었으면 head = tail를 통해 둘이 같은 노드를 가리키도록 한다.
* 큐가 비어있지 않으면, 기존 tail의 next에 새로만든 tail를 설정해준다.


* dequeue 구현
```java
public T dequeue() {
    // 비어있으면
    if(isEmpty()) {
        tail = head;
        return null;
    }
    // 비어있지 않으면
    else {
        T item = head.item; // 빼낼 현재 front 값 저장
        head = head.next; // front를 다음 노드로 설정
        return item;
    }
}
```

* 데이터는 head로부터 꺼낸다. (가장 먼저 들어온 것부터 빼야하므로)
* head의 데이터를 미리 저장해둔다.
* 기존의 head를 그 다음 노드의 head로 설정한다.
* 저장해둔 데이터를 return 해서 값을 빼온다.

* 이처럼 삽입은 tail, 제거는 head로 하면서 삽입/삭제를 스택처럼 O(1)에 가능하도록 구현이 가능하다.

</details>





* 조금 확장한 자료구조들로는 양쪽에서 enqueue와 dequeue가 가능한 deque(double-ended queue)와 
* 시간순서가 아닌 우선순위가 높은 순서로 dequeue할 수 있는 `priority queue`가 있다








<details>
<summary>Queue 두개를 이용한 Stack - 접기/펼치기</summary>

* queue 두 개를 사용하여 stack의 push와 pop를 구현하는 것에 초점을 맞춰서 문제를 해결하면 됩니다
* 편의상 push()에 사용할 queue는 q1이라고 부르고 pop()에 사용할 queue를 q2라고 칭하겠습니다. 
두 개의 queue로 stack을 구현하는 방법은 다음과 같습니다.
  1. push() :: q1으로 enqueue()를 하여 데이터를 저장합니다.
  2. pop() ::
    1. q1에 저장된 데이터의 갯수가 1 이하로 남을 때까지 dequeue()를 한 후, 추출된 데이터를 q2에 enqueue()합니다. 결과적으로 가장 최근에 들어온 데이터를 제외한 모든 데이터는 q2로 옮겨진다.
    2. q1에 남아 있는 하나의 데이터를 dequeue()해서 가장 최근에 저장된 데이터를 반환한다.(LIFO)
    3. 다음에 진행될 pop()을 위와 같은 알고리즘으로 진행하기 위해 q1과 q2의 이름을 swap한다.

* 시간복잡도
  * push() : q1.enqueue()를 한번만 하면 되기 때문에 O(1)의 시간 복잡도.
  * pop() : q1에 저장되어잇는 n개의 원소중 n-1개를 q2로 옮겨야 하므로 O(n)



</details>



<details>
<summary>Queue vs priority queue 비교 설명 - 접기/펼치기</summary>  
* Queue는 먼저 집어 넣은 데이터가 먼저 나오는 선입 선출 (FIFO) 자료구조
* Priority Queue(우선순위 큐)는 들어간 순서에 상관 없이 우선순위가 높은 데이터가 먼저 나온다.

* 시간복잡도
  * Queue : enqueue - O(1), dequeue - O(1)
  * Priority Queue : Push - O(log N), Pop - O(log N)
* 우선순위 큐는 Heap으로 구현할 수 있다.
  * Heap 자료구조는 이진 완전 트리를 활용하는것.

* Heap - [링크](##힙(Heap))
  * 우선순위 큐의 구현과 일치
  * 완전 이진 트리 조건
  * 힙이 되기 위한 조건
    * 각 node에 저장된 값은 child node(자식 노드)들에 저장된 값보다 작거나 같다 -> 최소힙(min heap)
      * 루트 노드가 가장 작은 값이 된다.
    * <img src="https://blog.kakaocdn.net/dn/JB3rQ/btrJGUBw9Wy/H5XAgumlhsBIOPl6zpQGv0/img.png"> 
      * [이미지 출처](https://dsbook.tistory.com/255)
    * 반대로 각 node에 저장된 값이 child node들에 저장된 값보다 크면 최대 힙(max  heap)

​		

* Heap 구현
  * 트리는 보통 Linked list로 구현
  * 그러나 Heap은 tree임에도 불구하고 배열을 기반으로 구현.
    * 새로운 노드를 힙의 마지막 위치에 추가해야 하는데 그 과정이 수월해짐.
  * 구현의 편의를 위해 보통 0번째 인덱스는 사용하지 않는다.
  * 완전 이진트리의 특성을 활용하여 배열의 index만으로 부모 자식 관계를 정의
    * n번째 node의 왼쪽 자식 노드 = 2n
    * n번째 node의 오른쪽 자식 노드 = 2n + 1
    * n번째 노드의 부모 노드 = n / 2

</details>



<details>
<summary>Stack 두개를 이용한 Queue 구현 - 접기/펼치기</summary>

 

* <img src="https://blog.kakaocdn.net/dn/cXuMym/btrJFO2BqV8/okRoKnvoqy0js4omqkvBhk/img.png" align = "left">





* [이미지 출처](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Structure%5D%20Stack%EA%B3%BC%20Queue.md)



1. inbox에 데이터를 삽입 - Push -> 순서는 A, B
2. inbox에 있는 데이터를 Pop 하여 outbox에 Push -> 순서는 B, A가 된다.
3. outbox에 있는 데이터를 pop 하면 -> A, B 순으로 나오게 된다 

* A 스택에 데이터를 쌓고, Pop 하면서 B스택에 데이터를 쌓는데, B스택에서 데이터를 pop 하면 순서대로 나오게 된다.

```java

import java.util.Stack;

/**
 * created by victory_woo on 2020/05/06
 * Stack 2개를 이용해서 Queue 구현하기.
 */
public class StackWithQueue {
    public static void main(String[] args) {
        StackQueue<String> queue = new StackQueue<>();
        queue.enQueue("A");
        queue.enQueue("B");
        queue.enQueue("C");

        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
    }

    static class StackQueue<T> {
        private Stack<T> inBox;
        private Stack<T> outBox;

        StackQueue() {
            inBox = new Stack<>();
            outBox = new Stack<>();
        }

        void enQueue(T item) {
            inBox.push(item);
        }

        Object deQueue() {
            if (outBox.isEmpty()) {
                while (!inBox.isEmpty()) {
                    outBox.push(inBox.pop());
                }
            }

            return outBox.pop();
        }
    }
}
```



</details>



* 공부해볼것
  * Stack을 사용하여 미로찾기 구현
  * Stack으로 괄호 유효성 체크 코드 구현 



# 트리

- [트리(Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Tree.md)

* [트리](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#tree)

* [Data Structure\] Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Tree.md)

* [[Data Structure\] B Tree & B+ Tree](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] B Tree %26 B%2B Tree.md)

* [B-Tree & B+Tree](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/B Tree %26 B%2B Tree.md)

- [이진탐색트리(Binary Search Tree)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Binary Search Tree.md)
- [[Data Structure\] 이진 탐색 트리](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] 이진 탐색 트리.md)

* [red-black-tree](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#red-black-tree)

그래프와 트리, 그리고 BST 87
균형잡힌 트리 : AVL 트리, 레드블랙트리 88

* 트리는 스택이나 큐, 어레이 같은 선형 자료구조가 아닌 비선형 자료구조.
* 계층적 관계(hierarchical RelationShip)을 표현하는 자료구조 
  * 트리는 `표현`에 집중한다 무엇인가를 저장하고 꺼내야한다는 사고에서 벗어나 트리라는 자료구조를 보자 

* 트리를 구성하고 있는 요소들 
  * Node (노드) : 트리를 구성하는 각각의 요소
  * Edge (간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선 
  * Root Node(루트 노드) : 최상위에 있는 노드
  * Leaf Node(Terminal Node, 단말 노드) : 하위에 자식 노드가 연결되어 있지 않은 노드
  * 내부 노드(Internal Node, 비단말 노드) : 단말 노드를 제외한 모드 노드, 루트 노드를 포함. 자식이 있는 노드
* 트리의 특징
  * 부모, 자식 계층 구조를 가짐
  * `트리에는 사이클이 존재할 수 없다 (사이클이 존재하면 트리가 아닌 그래프다 )`
  * 노드의 개수가 N개면 간선은 N-1개. (V - 1 = E)
  * 임의의 두 노드 사이에 경로는 유일무이하게 존재하며, 경로는 유일한 한 경로 뿐이다.
* <img src="https://blog.kakaocdn.net/dn/v7iyn/btrJEMDZXxt/GZwL4Lkwzss57f95bvKGn1/img.png" style="zoom:67%;" align = ""/>



* 트리를 순회하는 방식 - 4가지
  1. 전위 순회 (pre-order)
     * 각 루트를 순차적으로 먼저 방문하는 방식
     * root -> 왼쪽자식 오른쪽자식 
     * 1 -> 2 -> 4 -> 8 -> 9 -> 5 -> 10 -> 11 -> 3 -> 6 -> 13 -> 7 -> 14
  2. 중위 순회 (in-order)
     * 왼쪽 하위 트리를 방문한 후 루트를 방문하는 방식
     * 왼쪽자식 -> root -> 오른쪽 자식
     * 8 -> 4 -> 9 -> 2 -> 10 -> 5 -> 11 -> 1 -> 6 -> 13 -> 3 -> 14 -> 7
  3. 후위 순회 (post-order)
     * 왼쪽 하위 트리부터 하위를 모두 방문 후 루트를 방문하는 방식
     * 왼쪽자식 -> 오른쪽자식 -> 부모
     * 8 -> 9 -> 4 -> 2 -> 10 -> 11 -> 5 -> 13 -> 6 -> 14 -> 7 -> 3 -> 1
  4. 레벨 순회(level-order)
     * 루트(부모) 부터 계층 별로 방문하는 방식
     * 1 -> 2- > 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 13 -> 14 



<details>
<summary> 트리 구현 자바 코드 - 접기/펼치기</summary>

```java
public class Tree<T> {
    private Node<T> root;

    public Tree(T rootData) {
        root = new Node<T>();
        root.data = rootData;
        root.children = new ArrayList<Node<T>>();
    }

    public static class Node<T> {
        private T data;
        private Node<T> parent;
        private List<Node<T>> children;
    }
}
```

</details>



## 이진 트리(Binary Tree)

* <img src="https://blog.kakaocdn.net/dn/tdbLY/btrJGVf8zYk/qHhKNl3p2gISASz6hFRYqK/img.png" style="zoom:80%;" />
  * [이미지 출처](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Structure%5D%20Tree.md)

* 루트 노드를 중심으로 두 개의 서브 트리로 나누어짐 -> 자식이 두개여야만 함

  * 나누어진 서브 트리도 모두 이진 트리여야 한다.
  * 노드가 하나 뿐인 트리도 이진 트리의 정의에 만족한다

* 각 층별로 숫자를 매겨서 이를 트리의 레벨이라고 한다.

  * 레벨은 1부터 시작하고 루트 노드의 레벨은 1.
  * 트리의 최고 레벨을 가르켜 트리의 높이라고 한다. 
    * 루트로부터 밑에 3개가 더있으면 1, 2, 3, 4 -> 4레벨 

* 종류

  * 포화 이진 트리 (Full Binary Tree) : 모든 레벨이 꽉꽉 찬 이진 트리 -> 자식은 2개씩 

    * 레벨별로 노드의 개수가 1, 2, 4, 8, 16 으로 늘어난다 
    * 각 레벨별 최대 노드의 갯수는 2 ^ ( k - 1 )개 (k는 레벨)
    * 레벨 별 노드는 공비가 2인 등비 수열로 볼 수 있다, 
    * 그러므로 높이가 h 인 이진트리가 가질 수 있는 최대 노드 수는 2 ^ h - 1 (h는 높이, 레벨)

    

  * 완전 이진 트리 (Complete Binary tree) : 왼쪽에서 오른쪽으로 차곡차곡 채워진 이진 트리

    * 노드를 삽입할 때 왼쪽부터 차례대로 삽입하는 트리. 왼쪽이 비고 오른쪽이 들어가있는 트리는 완전 이진트리가 아님
    * 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 트리 = 정 이진 트리

  

  * 편향 이진 트리(Skewed Binary Tree) : 모든 노드가 부모의 왼쪽으로 편향되어있거나 오른쪽으로 편향되어 있는 트리

* 규칙

  * 배열로 구성된 이진 트리는 노드의 개수가 n개이고 root가 0이 아닌 1 index에서 시작한다면
    * i 번째 노드에 대해서 parent(i) = i / 2
    * left child(i) = 2i
    * right child(i) = 2i + 1 의 index 값을 갖는다  



## 이진 탐색 트리(BST, Binary Search Tree)

효율적인 탐색을 위해서는 어떻게 찾을까만 고민해서는 안된다.

효율적인 탐색을 위한 효율적인 저장방법이 무엇일까를 고민해야 한다.

이진 탐색 트리는 이진 트리의 일종이다.

이진 탐색 트리는 부모의 오른쪽 하위에는 부모 값보다 큰값인 노드만 저장되고, 왼쪽 하위에느 노드 값보다 작은 값만이 들어간다.

이진 탐색 트리의 목적은 이진 탐색의 장점과 연결리스트의 장점을 합친 것 -> 이진 탐색 + 연결 리스트

BST는 저장과 동시에 정렬을 하는 자료구조.

 따라서 새로운 데이터를 저장할 때 일정한 규칙에 따라 저장을 하게 됩니다. 



* 이진 탐색 - 탐색 소요 시간 O(log N) 
  * 그러나 삽입 삭제가 불가능
* 연결리스트 -> 삽입, 삭제의 시간 복잡도는 O(1) 그러나 탐색 소요 시간이 O(n)
* 효율적인 탐색 소요시간 + 삽입 삭제도 빠르게 만들자는 목적 



### 특징

* 각 노드의 자식이 2개 이하.
* 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 커야함
* 각 노드의 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.
* 데이터의 중복이 반드시 없어야 한다. - 노드에 저장된 키(데이터)값은 유일하다.
  * 검색 목적 자료구조인데, 중복이 많은 경우 트리를 사용하여 검색 속도를 느리게 할 필요가 없다.
    * 트리에 삽입하는 것보다 노드에 count를 가지게 하여 처리하는것이 효율적 

* 이진 탐색 트리의 순회는 중위순회(in-order)방식 (왼쪽 - 루트 - 오른쪽)
  * 중위 순서로 정렬된 순서를 얻을 수 있다.



### 연산

* 검색(탐색) - O(log N) 제일 말단 노드에 원하는 값이 있을경우 높이(h)만큼의 노드를 탐색 -> O(n)
* 삽입
* 삭제
* 트리 생성
* 트리 삭제

### 시간 복잡도

* 균등 트리

* 삽입/삭제/찾기 연산 각각에 대해 모두 평균 시간복잡도는 O(logN), 최악의 시간복잡도는 O(N)
* 검색과 저장, 삭제의 시간복잡도는 모두 O(logn)이고, worst case는 한쪽으로 치우친 tree가 됐을 때 O(n)
  * 계속 작은 값만 들어오는 경우나, 계속 큰 값만 들어오는 경우
* 편향된 트리(정렬된 상태 값을 트리로 만들면 한쪽으로만 뻗음)는 시간복잡도가 O(N)이므로 트리를 사용할 이유가 사라짐 
  * 배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생
* → 이를 바로 잡도록 도와주는 개선된 트리가 AVL Tree, RedBlack Tree

* [참고하면 좋다. 정리가 잘되어있다](https://mommoo.tistory.com/101)



## Red-Black Tree

Binary Search Tree를 기반으로 하는 자료구조.

동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어.

![레드-블랙트리](https://blog.kakaocdn.net/dn/citWfI/btrptgRQlFi/vd9FwY1WQKUpKDkjZWIGD1/img.png)



### 연산

* 삽입 insert : O(lon N)
* 조회 search : O(log N)
* 삭제 delete : O(log N)

## 정의 

레드 블랙 트리는 다음의 성질들을 만족하는 BST(이진 탐색 트리) 이다.

1. 모든 노드는 `Red(빨강)` or `Black(검정)` 의 색을 갖는다.
2. 루트 노드는 `검정색`이다. 
3. 모든 리프 노드들은 `검정색`이다.

4. `레드` 노드의 자식은 모두 ` 검정색`이다

5. 모든 리프 노드에서 Black Depth는 같다.

   * ```
      리프노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수가 같다.
     ```

6. 각 노드에 대해서 노드로부터 descendant leaves 까지의 단순 경로는 모두 같은 수의 black nodes 들을 포함하고 있다. 
   1. 이를 해당 노드의 `Black-Height` 혹은 `Black Depth`라고 한다.
   2. Black-Height: 노드 x 로부터 노드 x 를 포함하지 않은 leaf node 까지의 simple path 상에 있는 black nodes 들의 개수*

### 특징

1. Binary Search Tree 이므로 BST 특징을 모두 갖는다. 
2. 루트 노드로부터 리프 노드까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다.
   * 이러한 상태를 `balanced` 상태 라고 한다

3. 노드의 자식(child)가 없을 경우 child를 가리키는 포인터는 NIL(NULL)값을 저장한다. 
   * 이러한 NIL 들을 리프 노드로 간주한다.



### 삽입

* 우선 BST 특성을 유지하면서 노드를 삽입한다.
* 삽입된 노드의 색을 Red로 지정한다.
  * Red로 지정하는 이유는 Black-Height(Black Depth) 변경을 최소화 하기 위해
* 삽입하려는 위치의 부모가 블랙 일경우 아무 문제 없이 삽입된다.

* 삽입 결과 레드블랙트리의 특성 위배(부모 노드의 색이 레드 일경우) 시 노드의 색깔을 조정하고 Black-Height가 위배 되었다면 회전을 통해 Height를 조절한다.

* ![Double-Red](https://blog.kakaocdn.net/dn/blkAJy/btrpiHjqbii/tj9F3pQv8oZwVgD7ffX4w1/img.png) [참조](https://code-lab1.tistory.com/62)

레드 블랙 트리에 새로운 노드를 삽입할 떄 새 노드는 항상 빨간색이다.

레드 노드의 자식은 모두 검정색인데 이렇게되면 `레드 노드의 자식은 모두 검정색이다` 라는 조건을 위배한다.

* Double Red : 빨간색 노드가 연속으로 2번 나타나는것.

* 이 Double Red 문제를 해결하기 위해 2가지 전략을 사용한다. 

![Solution of Double Red](https://blog.kakaocdn.net/dn/bYG3yV/btrpoxGRp6g/fBAd1VvrqdWy6QRRSKTX3k/img.png) 

* * [참조](https://code-lab1.tistory.com/62

1. N (New) : 새로 삽입할 노드

2. P (Parent) : 부모 노드
3. G (Grand Parent) : 조상 노드
4. U (Uncle) : 삼촌 노드



* 삼촌 노드가 검은색이라면 -> Restructuring (구조 재조정, Rotate 회전이라고도 함) 수행
* 삼촌 노드가 빨간색이라면 -> ReColoring (컬러 재설정) 수행 



## Resturcturing (구조재조정 = Rotate  )

### `삼촌 노드가 검은색일때만 Resturcturing을 한다.`

```
1. 나(z)와 내 부모(v), 내 부모의 부모(Grand Parent)를 오름차순으로 정렬
2. 무조건 가운데 있는 값을 부모로 만들고 나머지 둘을 자식으로 만든다.
3. 중간값(부모, 부모가 된 중간 값)을 검정(Black)으로 만들고 그 두자식들을 빨강(Red)로 만든다. 
```

* 삽입의 회전에는 좌 회전, 우 회전이 있다. 
  * `우회전`은 부모의 부모 (조상, 할아버지) 와 부모의 왼쪽 자식과 위칙을 바꾸는것
    * 우회전을 할 때에는 왼쪽 자식노드의 오른쪽 자식 노드를 부모 노드의 왼쪽 자식으로 붙여줘야 한다.
  * `좌회전`은 부모의 부모 (조상, 할아버지)와  부모의 왼쪽 자식과 위치를 바꾸는것
    * 오른쪽 자식 노드의 왼쪽 자식 노드를 부모 노도의 오른쪽 자식으로 연결한다.





* 삽입하려는 노드와, 부모와, 할아버지의 중간값을 부모로 만들고, 부모가 된 중간값을 블랙 노드로 
* 부모가 되지 않은 남은 두 노드(셋중에 누가 중간값? 누가 부모가 될지 모름) 더 작은값을 왼쪽자식, 큰값을 오른쪽 자식으로 변경
*  부모가 되지않은 두 노드의 색을 빨강으로 만든다.

* 시각화 : https://www.cs.usfca.edu/~galles/visualization/RedBlack.html



## ReColoring( 컬러 재설정)

### `삼촌 노드가 빨간색(Red) 라면 ReColoring 수행`

* 핵심은, ReColoring 시에 블랙 노드가 2번 연속으로 나와도 된다. 
  * `레드 노드(빨강)` 만 연속으로 2번 나오지만 않으면 된다.

* 루트 노드는 무조건 검은색이여야 한다.
  * 리컬러링을 수행하고, 루트노드가 레드가 되면, 
    * 루트노드를 블랙으로 바꾸고, 바로 두 자식 노드도 블랙으로 바꿔도 된다.

## 삭제

만약 삭제하려는 노드가 Red면 그 노드만 삭제하고 부모랑 연결하고,

삭제하려는 노드가 Black 이고 child Node가 red 라면 해당 Black 노드를 삭제해주고 자식을 Black으로 바꿔준다 



그러나 삭제하려는 노드와 그 자식 노드가 모두 Black일 경우 문제가 된다.

다음 규칙 을 위반하기 때문. 

``` 
 리프노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수가 같다.
```



* https://velog.io/@youngcheon/자료구조-Red-Black-Tree-삭제-구현

* https://blogshine.tistory.com/102

* 추가 학습 https://lemonlemon.tistory.com/135

* ```
  https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
  ```



# AVL Tree (AVL은 발명자 세명의 이름에서 따왔다)

`자가 균형 이진 탐색 트리.`

이진 탐색 트리에서, 노드들이 삽입시 한쪽으로 편향되면 결국 탐색에서 O(N)의 시간이 걸리게 된다.

* <img src="https://blog.kakaocdn.net/dn/cYIDFZ/btrJHeTZiIn/lFEE2hqN32aP3HCN0ptIHk/img.png" align="left">
  * 그림 : 편향트리.



이진 탐색 트리의 편향트리를 극복하기 위해 재구성(회전, Rotate)을 통해 트리를 균형있게 만든다.

AVL 트리는 다음과 같은 특징을 가진다.

1. 이진 탐색 트리(BST)의 속성을 가진다.
2. 왼쪽, 오른쪽 서브 트리의 `높이차이가 최대 1`이다.
3. 삽입, 삭제 등 어떤 시점에서 높이 차이가 1보다 커지면 회전(Ratation)을 통해 균형을 맞춰 높이를 1로 맞춘다.
4. AVL 트리는 높이를 logN으로 유지하기 떄문에 삽입, 검색 ,삭제의 시간 복잡도는 O(log N) 이다.



AVL 트리는 균형이 무너졌는지에 대해 판단할 떄 `Balance Factor (BF)` 라는 것을 이용합니다.

* AVL 트리는 모든 노드의 BF가 -1, 0, 1중 하나여야 합니다. 이를 벗어나면 균형이 깨진것이고, 회전이 필요합니다.

## Banlace Factor(BF)

* 균형이 무너졌는지 확인하는것.

> BF(K) = height(left(k)) - height(right(k))

* k의 왼쪽 서브트리 높이 - k의 오른쪽 서브트리 높이 

> BF가 1이면 왼쪽 서브트리가 오른쪽 서브트리보다 높이가 한 단계 높은것.
>
> BF가 0이면 왼쪽 서브트리와 오른쪽 서브트리의 높이가 같은것.
>
> BF가 -1이면 왼쪽 서브트리가 오른쪽 서브트리보다 높이가 한 단계 낮은것. 

* 즉 BF값이 범위를 벗어났을 떄  양수이면 왼쪽 서브트리가 더 높이가 높은것
* 음수이면 오른쪽 서브트리가 더 높이가 높은것
  * ex ) -2, -3 이면 음수이므로 오른쪽 서브트리의 높이가 더높은것
  * ex) 2, 3 이면 양수이므로 왼쪽 서브트리의 높이가 더 높은것 





* <img src="http://ehpub.dothome.co.kr/wp-content/uploads/2022/04/2-110.png" align="left">
* 그림 : 트리의 높이



* <img src="https://blog.kakaocdn.net/dn/bSuSxk/btrJAHRpzzw/2p4iXK1Asw9QIErnQCt7dK/img.png" align="left">
* 그림 : 각 트리의 높이에 따른 BF(K) 값
  * 10 : 왼쪽 서브트리 높이 1, 오른쪽 서브트리 높이 1 . `1-1 = 0`
  * 30 : 자식이 없으므로 높이 0
  * 20 : 왼쪽 서브트리 높이 2 오른쪽 서브트리 높이 1. `2-1 = 1` 
  * 50 : 왼쪽 서브트리 높이 3 오른쪽 서브트리 높이 2. `3-2 = 1`
  * 70 : 왼쪽 서브트 리 높이 0 오른쪽 서브트리 높이 1. `0 - 1 = -1`



## 회전(Rotation)

AVL 트리는 균형이 무너지면(BF(K)값이 0, -1, 1 이 아니면 ) 회전을 하여 균형을 맞춘다.

이때 사용하는것이 회전이다. 

검색 및 순회 연산은 BF를 변경하지 않지만 삽입 및 삭제 연산에서는 BF가 변경될 수 있다.

불균형 노드를 기준으로 서브트리의 위치를 변경하는 작업이 Rotation이다

삽입 삭제 시 노드들의 배열에 따라 4가지 (LL, LR, RR, RL) 불균형이 발생할 수 있으며 각 상황바다 회전하는 방향이 다르다



* 좌회전과 우회전을 먼저 봅시다.

### 좌회전

* <img src="https://blog.kakaocdn.net/dn/C534j/btrJD278Hpp/8rsF9w6EeGTFBsfM8rjoT1/img.png">

* 균형이 깨진 노드 z
* z노드를 오른쪽 자식노드의 왼쪽으로 이동 -
* z 노드의 오른쪽 자식노드 y가 새 부모 노드가 됨.

### 우회전

* <img src = "https://blog.kakaocdn.net/dn/p69vS/btrJBU93zlQ/IXHiIvZsiZKs3EmmsIbplK/img.png">

* 균형이 깨진 노드 z
* z노드를 z의 왼쪽 자식노드인 y노드의 오른쪽 자식으로 이동 
* z노드의 왼쪽 자식노드인 y가 새 부모 노드가 됨.



LL, RR ,LR , RR 을 보기전에 다시한번 기억해둬야 하는 내용

>  BF가 `1`이면 왼쪽 서브트리가 오른쪽 서브트리보다 높이가 한 단계 높은것.
>
> BF가 `0`이면 왼쪽 서브트리와 오른쪽 서브트리의 높이가 같은것.
>
> BF가 `-1`이면 왼쪽 서브트리가 오른쪽 서브트리보다 높이가 한 단계 낮은것. 
>
> * 즉 BF값이 범위를 벗어났을 떄  양수이면 왼쪽 서브트리가 더 높이가 높은것
> * 음수이면 오른쪽 서브트리가 더 높이가 높은것
>   * ex ) -2, -3 이면 음수이므로 오른쪽 서브트리의 높이가 더높은것
>   * ex) 2, 3 이면 양수이므로 왼쪽 서브트리의 높이가 더 높은것 



### LL 회전 (Left Left) -> 우회전한다.

* BF값이 양수로 범위를 벗어난 경우 (2)
* 왼쪽 서브트리의 높이가 오른쪽 서브트리의 높이보다 더 높은경우
* BF값을 벗어난 노드를 z,
* z의 아들을 y 
* y의 아들을 x (x는 z의 손자)



> LL 회전은 y가 왼쪽 자식노드이고, x가 왼쪽 자식노드일 경우 회전한다

*  `Right Rotation (우회전)`

* <img src="https://blog.kakaocdn.net/dn/bHczX8/btrJHdU5Me8/8XA9aNGraMId77f5kmFl10/img.png" style="zoom:50%;" align="left"/>

* 해당 노드인 z를 기준으로 우회전 하면 불균형이 해소된다.

1. y노드의 오른쪽 자식 노드를 z로 변경
2. z노드 왼쪽 자식 노드를 y 노드의 오른쪽 서브트리로 변경
3. y가 새로운 루트 노드 



### RR 회전(Right Right) -> 좌회전한다 

* BF값이 음수로 범위를 벗어난 경우( -2)
* 오른쪽 서브트리의 높이가 왼쪽 서브트리의 높이보다 더 높은 경우
* BF 값을 벗어난 노드를 z

* z의 아들을 y 
* y의 아들을 x (x는 z의 손자)

> RR 회전은 y가 z의 오른쪽 자식이고, x가 오른쪽 자식 노드일경우 회전한다

* Left Rotation(좌회전)

* <img src="https://blog.kakaocdn.net/dn/bljfoM/btrJD3suFD0/vva8lGs3KKQ5GA0EBZ8QD0/img.png">

* 해당 노드인 z를 기준으로 좌회전하면 불균형이 해소된다

1. y노드의 왼쪽 자식 노드를  z 노드로 변경
2. z노드 오른쪽 자식 노드를 y노드 왼쪽 서브트리로 변경
3. y가 새로운 루트노드



### LR (Left Right) - 2번의 Rotation.  left -> right 순으로 두번 수행한다

* BF 값이 양수로 범위를 벗어남
* BF의 왼쪽 자식노드가 오른쪽 자식 노드를 갖고 있는 경우 

* BF 값을 벗어난 노드를 z

* z의 아들을 y 
* y의 아들을 x (x는 z의 손자)

> LR 회전은 y가 z의 왼쪽 자식이고 x가 y의 오른쪽 자식 노드일경우 left -> right 순으로 2번 회전한다

* <img src="https://blog.kakaocdn.net/dn/brglTa/btrJKtDpCdW/SZGEs13e4hK1IITS0wN3kk/img.png">

1. 왼쪽 자식 노드인 y를 기준으로 좌회전

2. 본인인 z 기준으로 우회전 

```
y = z.left;
y = rotateLeft(y);
z = rotateRight(z);
```



### RL(RIght Left )- 2번의 Rotation. right left 순으로 두번 수행한다

* BF 값이 음수로 범위를 벗어남
* BF의 오른쪽 자식 노드가 왼쪽 자식 노드를 갖고 있는 경우

* BF 값을 벗어난 노드를 z

* z의 아들을 y 
* y의 아들을 x (x는 z의 손자)

> RL 회전은 y가 z의 오른쪽 자식이고 x가 의 왼쪽 자식일떄 right -> left 순으로 두번 회전한다. 

* <img src="https://blog.kakaocdn.net/dn/beJPHT/btrJEMKKt1f/WZ9ku3GBAg07ySnmVsGli0/img.png">

1. 오른쪽 자식 노드인 y를 기준으로 우회전
2. 본인인 z 기준으로 좌회전 

```
y = z.right;
y = rotateRight(y);
z = rotateLeft(z);
```



<details>
<Summary> 자바 소스코드 구현 -  접기/펼치기</Summary>

```java
@Getter @Setter
@NoArgsConstructor @AllArgsConstructor
public class Node {

    private int key;
    private int height;
    private Node left;
    private Node right;

    public Node(int key) {
        this.key = key;
    }
}

package tree;

/**
 * @author : ysk
 */
public class AVLTree {

    private Node root;

    private void updateHeight(Node n) {
        n.setHeight(1 + Math.max(height(n.getLeft()), height(n.getRight())));
    }

    private int height(Node n) {
        return n == null ? -1 : n.getHeight();
    }

    private int getBalanceFactor(Node n) {
        return n == null ? 0 : height(n.getRight()) - height(n.getLeft());
    }

    private Node rotateLeft(Node z) { // z 본인, 할아버지. y 본인의 오른쪽노드. x  손주 y의 왼쪽 노드
        Node y = z.getRight();
        Node x = y.getLeft();

        // y의 왼쪽 자식 노드를 z로 지정
        y.setLeft(z);
        // z의 오른쪽 자식 노드를 x로 지정
        z.setRight(x);

        updateHeight(z);
        updateHeight(y);

        return y; // 새로운 루트 노드 반환
    }

    private Node rotateRight(Node z) { // z 본인, 할아버지. y 본인의 왼쪽노드 . x  손주 y의 왼쪽 노드
        Node y = z.getLeft();
        Node x = y.getRight();

        y.setRight(z);
        z.setLeft(x);

        updateHeight(z);
        updateHeight(y);

        return y; // 새로운 루트노드
    }

    private Node insert(int key) {

        Node newNode = new Node(key);

        if (root == null) {
            root = newNode;
            return newNode;
        }

        Node rootNode = root;

        while (true) {
            if (key < rootNode.getKey()) {
                if (rootNode.getLeft() != null) {
                    rootNode = rootNode.getLeft();
                } else {
                    rootNode.setLeft(newNode);
                    return newNode;
                }
            } else if(key > rootNode.getKey()) {
                if (rootNode.getRight() != null) {
                    rootNode = rootNode.getRight();
                } else {
                    rootNode.setRight(newNode);
                    return newNode;
                }
            } else {
                throw new IllegalArgumentException("has Contain, value : " + key);
            }
        }

    }

    public void insertNode(Integer... values) {
        for (Integer value : values) {
            insertNode(value);
        }
    }

    public Node insertNode(int key) {

        Node insertNode = insert(key);

        updateHeight(insertNode);

        return rebalance(insertNode);
    }

    private Node rebalance(Node node) {

        int balanceFactor = this.getBalanceFactor(node);

        if (balanceFactor < -1) { // RR : 현재 노드 기준으로 오른쪽 서브트리가 더 커서 발란스가 작아진경우
            if (getBalanceFactor(node.getLeft()) <= 0) {
                node = rotateRight(node);
            } else { // LR
              node.setLeft(rotateLeft(node.getLeft()));
              node = rotateRight(node);
            }
        }

        if (balanceFactor > 1) { // LL
            if (getBalanceFactor(node.getRight()) > 0) { // LL
                node = rotateLeft(node);
            } else { // RL
                node.setRight(rotateRight(node.getRight()));
                node = rotateLeft(node);
            }
        }

        return node;
    }

    public Node searchNode(int key) {
        Node node = root;

        while(node != null) {
            if (key == node.getKey()) {
                return node;
            } else if (key < node.getKey()) {
                node = node.getLeft();
            } else {
                node = node.getRight();
            }
        }
        return null;
    }

    public Node getRoot() {
        return this.root;
    }

    public void inOrder(Node node) {
        if (node != null) {
            if (node.getLeft() != null) {
                inOrder(node.getLeft());
            }
            System.out.print(node.getKey() + ", ");
            if (node.getRight() != null) {
                inOrder(node.getRight());
            }
        }

    }

    public static void main(String[] args) {
        AVLTree avlTree = new AVLTree();

        avlTree.insertNode(3, 5, 4, 7, 9, 11, 15, 14, 10, 2, 99, 98, 94, 90, 18, 19, 23, 25, 53, 70, 88, 46, 64, 72);

        Node root = avlTree.getRoot();

        avlTree.inOrder(root);

    }
}
```
</details>



참고



https://yoongrammer.tistory.com/72

https://galid1.tistory.com/176

https://www.happycoders.eu/algorithms/avl-tree-java/

https://www.baeldung.com/java-avl-trees

https://www.zerocho.com/category/Algorithm/post/583cacb648a7340018ac73f1

# B Tree & B+ Tree

검색을 위한 자료구조중에서 이진트리는 한 부모가 두 개의 자식밖에 가지질 못하고, 균형이 맞지 않으면 검색 효율이 선형(O(n)) 급으로 떨어지지만, 균형이 잘맞으면 성능이 O(log N) 수준으로 보이는 장점이 있어 이를 바탕으로 개선하고자 하는 자료구조들이 나왔습니다.

B Tree는 이진트리를 확장해서 더 많은수의 자식을 가질 수 있고, 균형이 맞지 않는 편향트리가 되지 않도록 균형을 맞추는 구조를 갖고 있습니다.

데이터베이스, 파일 시스템에서 널리 사용되는 트리 자료구조의 일종입니다.

단순하고 효율적이며 레벨로만 따지면 완전히 균형을 맞춘 트리입니다.

대량의 데이터를 처리할 때 하나의 노드에 많은 데이터를 가질 수 있으므로 큰 장점을 갖고 있습니다.

## B Tree의 규칙

* M차 트리일 때, 루트 노드와 리프노드 를 제외한 모든 node는 `최소 [M/2, 천정함수]`, `최대 M개`의 서브 트리를 갖는다.

  * 최소의 [M/2 천정함수, ceil] : 반올림값 이라고 이해하면 편하다. 1.5 -> 2 / 2.5 ->3
  * M = 자식수 * 2  - 1 (M = 2t -1)   

* 루트 노드는 적어도 2개 이상의 자식을 가져야 한다.

  * 노드의 데이터 개수가 n개라면 자식 노드의 개수는 n + 1
  * 최소차수는 자식수의 하한값을 의미
  * 자식 수가 t 이면 M = 2t - 1 (최소차수가 2라면 M은 3이고, 이 트리는 3차 B tree )

* 각 노드의 자료수가 N이면 자식 수는 N+1 이여야 한다.

  * key 수 = 자료(data) 수
  * 노드에 2개의 키가 있으면 자식 수는 2 + 1 = 3이다.
  * 아래 그림에서는 9, 11 노드가 8, 10, 12,14 노드를 가리켜서 4개 같지만 4개가 아니다.
  * 8 노드, 10 노드, 그리고 12와 14가 묶은 한 노드인 총 3개의 노드를 가리키고 있는것이다. 

* 각 노드의 자료는 정렬된 상태여야 한다.

* 각 노드에는 key 값이 2개 이상 들어갈 수 있다. 

* 최대 M개의 자식을 가질 수 있는 B 트리를 M차 B트리라고 한다. 

  * M : 자식을 가질수 있는 숫자 = B트리의 차수

* 외부 노드로 가는 경로의 길이는 모두 같다. - 외부 노드는 모두 같은 레벨에 있다. 

* 입력 자료는 중복될 수 없다. 

  

* <img src = "https://blog.kakaocdn.net/dn/3XP3x/btrJBJPi1GP/bvWtvcICkLGrIqucIhxsN1/img.png">



* 키, 포인터를 가진다.
* 그림에서 숫자는 각 노드의 key이다
* key 옆의 진한 주황색 부분은 각 자식들을 가르키는 포인터이다.

* BST의처럼 각 노드의 왼쪽 자식 노드들의 key 값은 부모 노드보다 작으며 오른쪽 자식 노드들의 key값은 부모 노드보다 크다.



## B Tree의 조회

1. 루트노드에서 시작하여 이진트리와 같이 검색을 수행합니다.
   * BST의 특성으로 자기자신보다 작은값은 왼쪽, 큰값은 오른쪽에 있습니다
   * 하지만 B Tree는 한 노드에 2개이상의 키를 가지고 있을 수 있기 때문에 그 사이에 있는 값인지도 체크 해야합니다.
2. 특정한 key들 사이에 찾는 값이 존재한다면 해당 key들 사이의 자식 노드로 내려갑니다.
   * 위 그림에서 9를 찾는다면, 루트노드의 키인 7, 15중 7보단 크고 15보단 작으므로 가운데 노드로 내려가서 찾습니다.

3. 해당 과정을 리프노드에 도달할 때 까지 반복. 만일 리프노드에서도 키가 없다면 검색은 실패. 



 ## B Tree의 삽입

1. 자료는 항상 리프 노드에만 삽입된다.
2. 리프 노드의 선택은 루트 노드부터 시작해 하향식으로 탐색한다.
3. 선택한 리프 노드에 여유가 있다면 그냥 삽입. 
4. 삽입하려는 위치의 노드가 가득 찼다면, `노드를 분할하고 생성`
5. 노드가 분할되는 경우 노드의 중앙값을 기준으로 분할.
   * 중앙값은 부모 노드로 합쳐지거나 새로운 노드로 생성된다.
   * 중앙값을 기준으로 왼쪽의 key는 왼쪽 자식, 오른쪽 key는 오른쪽 자식으로 삽입.

* https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree

* [홀수일때와 짝수일때의 삽입/삭제과정](https://swycha.tistory.com/236)

## B Tree의 삭제

리프 노드와 리프 노드가 아닐 경우 두가지로 나뉘고, 두 가지 경우 내에서 또 여러 가지 경우로 나뉩니다.

 노드를 찾았다면 데이터 삭제 후, 노드에 너무 적은 수의 데이터가 남지 않도록 해야 합니다.  (M/2 이상 보장)  만일 데이터 수가 부족하다면 형제에게서 데이터를 빌리거나 형제와 결합합니다.

* https://rebro.kr/169
* https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree



## B Tree 성능

B Tree의 탐색 시간복잡도는 O(lonN)

* B-트리는 자동으로 균형을 잡기 때문에 최악의 경우에도 O(logN) 성능을 보장합니다. 

- 노드의 삽입/삭제 후에도 균등한 응답 속도를 보장합니다
- 단점 : 삽입/ 삭제시 균형 유지를 위해 복잡한 연산이 필요합니다. 

```
데이터 로드 효율성 측면은 대량의 데이터로 트리를 구성할 때, 진가를 발휘합니다. 
데이터가 많은경우 메모리에 트리 구조를 유지하기 보다는 외부장치에 데이터를 저장해야 합니다. 
각 노드의 값을 파일로 저장한 후, 파일 정보만 저장하고 있다면 메모리에서도 충분히 트리를 유지할 수 있게 됩니다. 
외부장치에서 데이터를 읽어올때 데이터가 크던 작던 블럭 크기 만큼 읽어옵니다. 
즉 노드의 데이터를 특정 블럭 크기 만큼 지정하여 저장 할 수 있다면 효율적으로 데이터를 읽어올 수 있다는 장점이 생깁니다.
```



# B+ Tree

B Tree의 변형된 형태로, 특정 데이터를 탐색할경우 빠르게 탐색할 수 있지만, 

전체 데이터를 차례대로 처리해야 할 경우(linear, 선형) 중위 탐색을 수행하게 되어 트리 전체를 탐색하게 되면 성능 저하가 발생한다.

BTree의 순차 접근 문제를 해결하기 위해 제시된 자료구조이다.

B-Tree에서는 비단말노드(리프 노드가 아닌 중간노드, 인덱스노드라고도 함)에 key와 data를 담을 수 잇지만 

B+Tree에서는 비단말노드에는 key만 담아두고 data는 담지 않는다.

오직 리프노드에만 key와 data를 같이 저장하고 리프 노드끼리는 LinkedList로 연결되어 있다. 

* <img src="https://blog.kakaocdn.net/dn/Lo2Lo/btrJGUuLO9U/IuEJsK5ViagKNJI8dzG8b1/img.png" width = 800 height = 500>



* B-Tree에서는 중복값 없이 한 개의 노드에만 key가 유일하게 존재했으나 B+Tree는 leaf 노드와 그 외 노드에 공존할 수 있다.  

* B+Tree의 리프 노드 끼리는 연결리스트로 구성되어 있으며 순차 집합(Sequence Set)이라고도 한다.  

* 리프 노드가 아닌 비단말 노드는 인덱스 집합(Index Set)이라고 부르며 데이터로의 빠른 접근을 위한 인덱스 역할만 하기 때문에 키와 포인터로만 구성된다.   

* 따라서 기존 B-Tree의 데이터를 모두 리프 노드로 내려서 리프 노드를 B-Tree의 구조 + 연결리스트로 구현된 색인 구조로 구성하여 순차적인 탐색에 유리하다.  





## B+Tree의 성질

1. 모든 데이터는 리프 노드에만 존재한다.
2. 리프 노드가 아닌 비단말 노드는 key값만 담는다.
3. 모든 리프 노드는 연결리스트로 구성된다. (리프 노드들 끼리)
4. 데이터의 삽입/삭제 연산은 `리프 노드에서만` 발생한다. 

5. 키 값은 중복될 수 있다. 
6. 모든 리프노드의 첫번째 key는 index set (비단말 노드들)에 존재한다. 
7. 모든 리프노드는 같은 레벨에 있다.
8. 데이터 노드의 자료들은 정렬되어 있다.

## B+Tree에서의 검색

B-Tree의 경우 최상의 케이스에서는 루트에서 끝날 수 있지만

B+Tree의 경우 모든 데이터가 리프노드에 있기 때문에 

모든 경우에 대해 리프 노드로 가서 순차 탐색함으로 데이터를 찾아야한다. 

 

## B+Tree의 장점

1. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 
2. 하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.(cache hit를 높일 수 있음)

3. 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다. 

## B+Tree의 단점

B-Tree의 경우 최상의 케이스에서는 루트에서 끝날 수 있지만

B+Tree의 경우 모든 데이터가 리프노드에 있기 때문에 

모든 경우에 대해 리프 노드로 가서 순차 탐색함으로 데이터를 찾아야한다. 

* [B+Tree에서의 삽입과 삭제](https://8iggy.tistory.com/191)
* [참조](https://sdesigner.tistory.com/79)
* [B-Tree, B+Tree 비교](https://zorba91.tistory.com/m/293)



# 힙(Heap)

**힙**(heap)은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리를 기본으로 한 자료구조이다.

힙에는 두가지 종류가 있다.

* 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙 : 최대 힙(Max Heap)
* 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙 : 최소 힙(Min Heap)

우선 순위 큐(Priority queue)를 위해서 만들어졌다. - 힙 자체가 우선순위 큐이다. 

큐는 FIFO(First In First Out, 선입선출) 자료구조인데, 

우선순위큐는 들어간 순서에 상관 없이 우선순위가 높은 데이터가 먼저 나온다. 

Queue의 시간 복잡도는 enqueue = O(1), dequeue O(1) 이고

Priority queue 의 시간 복잡도는 push(삽입, O(log N)), pop (삭제 O(log N)) 이다.

다만 검색은(특정 값을 찾는것) 위치에 대한 개념이 없기 떄문에 선형시간 O(n) 이다

* 자바 PriorityQueue 도 선형으로 되어있다.

시뮬레이션 시스템, 작업 스케줄링, 수치해석 계산에 사용된다.

* <img src = "https://blog.kakaocdn.net/dn/bHdVzT/btrJGVNZBNr/Aq8AlYKoAaoBYVC6KoK0k0/img.png" align="centor">

- Tree의 형식을 취하고 있으며 Tree 중에서도 **배열을 기반으로 한 (Complete Binary Tree)완전 이진 트리**이다.
- 최대값 및 최소값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전 이진 트리이다.
- 배열에 트리의 값을 넣어줄 때는 0번째는 건너뛰고 1번째부터 루트 노드가 시작된다. 이유는 노드의 고유 번호와 index를 일치시켜 혼동을 줄이기 위함이다.
- 중복된 값을 허용. (이진 탐색 트리는 중복 값을 허용하지 않음.)

* Max Heap은 루트 노드에 저장된 값이 가장 크다.
* Min Heap은 루트 노드에 저장된 값이 가장 작은값이 된다.
* 최대힙에서는 Root Node에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 시간 복잡도는 O(1)이다.
* Complete Binary Tree이기 때문에 **배열을 이용해 관리할 수 있으며**, **인덱스를 통한 Random Access**가 가능하다.
* Index 번호는 노드 개수가 n개일 때, i번째 노드에 대하여 왼쪽 자식은 ix2, 오른쪽 자식은 ix2+1가 된다.

### 구현

힙을 저장하는 표준적인 자료구조는 배열이다.

구현을 쉽게 하기 위해 배열의 첫 번째 인덱스인 0은 사용되지 않고, 1부터 시작한다.

특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.

<부모 노드와 자식 노드의 관계>

- 왼쪽 자식 index : (부모 index) * 2
  - n번째 노드의 왼쪽 자식 = 2n
- 오른쪽 자식 index : (부모 index) * 2 + 1
  - n번째 노드의 오른쪽 자식 = 2n + 1
- 부모 index : (자식 index) / 2
  - n번째 노드의 부모 = n / 2
- 힙의 높이는l og(N) 이다.
  - push 했을 때 스왑하는 과정이 최대 logN번 반복되기 떄문에 시간복잡도는 O(log N)

### 삽입

1. MaxHeap

   1. 힙에 새로운 요소가 들어오면 새로운 요소를 마지막노드에 삽입.

   2. bottom-up 방식으로 새 요소와 크기를 비교해가면서 `새로운 요소보다 부모가 더 작으면 swap`

      * ```java
        int index = lastIndex(); // 마지막 인덱스. 이 기준은 루트 인덱스가 1로 가정했을때이다.
        while (부모가 존재하는가? && 그렇다면 부모가 나보다 값이 작은가?){
        	swap(부모인덱스, 내 인덱스);
        	index = 부모인덱스 // 스왑했으니까 부모가 되고, 다음 조건에 맞으면 새 부모와 다시 비교한다.
        }
        ```

      * heapifyUp()

2. MinHeap

   1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입.

   2. bottom-up 방식으로 새로운 요소와 크기를 비교해가면서 `부모가 더 크면 부모와 swap`

      * ```java
        int childIndex = lastIndex();
        while (부모가 존재하는가? && 그렇다면 부모가 나보다 값이 큰가?) {
        	swap(부모인덱스, 내 인덱스);
        	childIndex = 부모인덱스 // 스왑했으니까 부모가 되고, 다음 조건에 맞으면 새 부모와 다시 비교한다.
        }
        ```

      * heapfiyUp();



- max heap일 때 들어온 값, 부모 중 부모가 작으면 부모랑 교환한다 - 부모값이 더 커야 하므로
- min heap일 때 들어올 값, 부모 중 부모가 크면 부모랑 교환한다 - 부모값이 더 작아야 하므로



힙 재구성을 heapify라고 하겠습니다. 

힙을 재구성 할때는 insert와 delete시 방법이 다르다.

* insert - heapifyUp
  * 마지막 인덱스부터 루트 인덱스까지 bottom-up 방식으로 크기를 비교해서 재구성한다 

* delete - heapfiyDown
  * 루트 인덱스부터 마지막 인덱스까지 top-down 방식으로 크기를 비교해서 재구성 한다. 

### 삭제

1. MaxHeap

   1. 힙의 루트 에서 값을 빼고, 마지막 인덱스의 값을 힙의 루트로 삽입.

   2. top-down 방식으로 새 루트 요소와 왼쪽 오른쪽 자식들을 비교하면서, `더 큰 값의 자식과 swap`

      * ```java
        int parentIndex = 1; // 인덱스를 0에서 시작하느냐, 1에서 시작하느냐에 따름. 루트 인덱스 값
        while (왼쪽 자식이 있느냐(부모인덱스)){ // 왼쪽 자식이 없으면 오른쪽 자식은 없다.
        	int bigChildIndex = getLeftChildIndex(parentIndex); // 
        	
        	if (오른쪽 자식이 있고 && 오른쪽 자식이 왼쪽 자식보다 크다면) {
        		bigChildIndex = 오른쪽 자식인덱스;
        	}
        	
        	if (부모값이 자식값보다 크다면) {
        		break;
        	} else { // 부모 값이 자식보다 작다면 
        		swap(부모인덱스, 더 큰 자식 인덱스);
        		parentIndex = 더 큰 자식 인덱스; // 반복해가면서 비교한다
        	}
        }
        ```

      * heapfiyDown();



2. MinHeap

   1. 힙의 루트에서 값을 빼고 마지막 인덱스의 값을 힙의 루트로 삽입

   2. top-down 방식으로 새 루트 요소와 왼쪽, 오른쪽 자식들이 값을 비교하면서 `더 작은 값의 자식과 swap`

      * ```
        int parentIndex = 1; //인덱스를 0에서 시작하느냐, 1에서 시작하느냐에 따름. 루트 인덱스 값
        while (왼쪽 자식이 있느냐(부모인덱스)) {
        	int smallChildIndex = getLeftChildIndex(parentIndex);
        	
        	if (오른쪽 자식이 있꼬 && 오른쪽 자식이 왼쪽 자식보다 더 작다면) {
        		smallChildIndex = 오른쪽 자식인덱스;
        	}
        	
          if (부모 값이 자식보다 작다면) {
          	break;
          } else { // 부모 값이 자식보다 크다면
          	swap(부모 인덱스, 더 작은 자식 인덱스);
          	parentIndex = 더 작은 자식인덱스;
          }
        }
        ```

      * heapifyDown();







### Java Code(자바 코드) - 배열과 ArrayList를 사용한 2가지 방식. 

<details>
<summary> ArrayList 사용 - 접기/펼치기</summary>
추상클래스 이용하여 구현

```java
public abstract class ListHeap<T> {

    abstract void add(T data);

    abstract T pop();

    abstract void heapifyUp();

    abstract void heapifyDown();

    abstract T peek();

    abstract int size();

    abstract boolean contains(T data);

    abstract void swap(int i, int j);

    protected int getParentIndex(int childIndex) {
        return (int) Math.floor((int) ((childIndex - 1) / 2));// 바닥함수. 내려야한다.
    }

    protected int getLeftChildIndex(int parentIndex) {
        return (2 * parentIndex) + 1;
    }

    protected int getRightChildIndex(int parentIndex) {
        return (2 * parentIndex) + 2;
    }

    protected boolean hasRightChild(int index) {
        return getRightChildIndex(index) < size();
    }

    protected boolean hasLeftChild(int index) {
        return getLeftChildIndex(index) < size();
    }

    protected boolean hasParent(int index) {
        return getParentIndex(index) >= 0;
    }

    protected int lastIndex() {
        return this.size() - 1;
    }

    public void printElements() {
        while (this.size() > 0) {
            System.out.print(this.pop() + (this.size() != 1 ? ", " : ""));
        }
    }

}
  
public class ArrayListMaxHeap<T extends Comparable<T>> extends ListHeap<T> {

    private final List<T> elements;

    public ArrayListMaxHeap() {
        this.elements = new ArrayList<>();
    }

    @Override
    public void swap(int i, int j) {
        final T temp = elements.get(i);
        elements.set(i, elements.get(j));
        elements.set(j, temp);
    }

    private boolean isRightChildBigThenLeftChild(int parentIndex) {
        return elements.get(getRightChildIndex(parentIndex)).compareTo(elements.get(getLeftChildIndex(parentIndex))) > 0;
    }

    private boolean isParentBiggerThenBigChild(int parentIndex, int childIndex) {
        return elements.get(parentIndex).compareTo(elements.get(childIndex)) > 0;
    }

    private boolean isParentSmallThenChild(int childIndex) {
        return elements.get(getParentIndex(childIndex)).compareTo(elements.get(childIndex)) < 0;
    }

    @Override
    public void add(T data) {
        elements.add(data);
        heapifyUp();
    }

    @Override
    protected void heapifyUp() {
        int childIndex = lastIndex();

        while (hasParent(childIndex) && isParentSmallThenChild(childIndex)) {
            swap(getParentIndex(childIndex), childIndex);
            childIndex = getParentIndex(childIndex);
        }
    }

    @Override
    public T pop() {
        if (this.size() == 0) {
            throw new ArrayIndexOutOfBoundsException("heap is empty");
        }

        final T pop = elements.get(0);

        elements.set(0, elements.get(lastIndex()));
        elements.remove(lastIndex());

        heapifyDown();

        return pop;
    }

    @Override
    protected void heapifyDown() {
        int index = 0;

        while (hasLeftChild(index)) { // 왼쪽 자식이 없으면 오른쪽 자식도 없다.
            int bigChildIndex = getLeftChildIndex(index);

            if (hasRightChild(index) && isRightChildBigThenLeftChild(index)) {
                bigChildIndex = getRightChildIndex(index);
            }

            if (isParentBiggerThenBigChild(index, bigChildIndex)) {
                break;
            } else {
                swap(bigChildIndex, index);
                index = bigChildIndex;
            }

        }
    }

    @Override
    public T peek() {
        return this.elements.get(0);
    }

    @Override
    int size() {
        return this.elements.size();
    }

    @Override
    boolean contains(T data) {
        return this.elements.contains(data);
    }

    public static void main(String[] args) {
        ListHeap<Integer> arrayListListHeap = new ArrayListMaxHeap<>();

        arrayListListHeap.add(5);
        arrayListListHeap.add(4);
        arrayListListHeap.add(2);
        arrayListListHeap.add(7);
        arrayListListHeap.add(8);
        arrayListListHeap.add(9);
        arrayListListHeap.add(3);
        arrayListListHeap.add(6);
        arrayListListHeap.add(15);
        arrayListListHeap.add(999);
        arrayListListHeap.add(21);
        arrayListListHeap.add(1);
        arrayListListHeap.add(2393);
        arrayListListHeap.add(8237);
        arrayListListHeap.add(9999);
        arrayListListHeap.add(999);
        arrayListListHeap.add(999);
        arrayListListHeap.add(999);


        arrayListListHeap.printElements();

    }

}

public class ArrayListMinHeap<T extends Comparable<T>> extends ListHeap<T> {

    private final List<T> elements;

    public ArrayListMinHeap() {
        this.elements = new ArrayList<>();
    }

    @Override
    public void add(T data) {
        elements.add(data);
        heapifyUp();
    }

    @Override
    public T pop() {
        if (this.size() == 0) {
            throw new ArrayIndexOutOfBoundsException("heap is empty");
        }

        final T pop = elements.get(0);

        elements.set(0, elements.get(lastIndex()));
        elements.remove(lastIndex());

        heapifyDown();

        return pop;
    }

    private boolean isParentBigThenChild(int childIndex) {
        return elements.get(getParentIndex(childIndex)).compareTo(elements.get(childIndex)) > 0;
    }

    @Override
    protected void heapifyUp() {
        int childIndex = lastIndex();

        while (hasParent(childIndex) && isParentBigThenChild(childIndex)) {
            swap(getParentIndex(childIndex), childIndex);
            childIndex = getParentIndex(childIndex);
        }
    }

    @Override
    protected void heapifyDown() {
        int index = 0;

        while (hasLeftChild(index)) { // 왼쪽 자식이 없으면 오른쪽 자식도 없다.
            int smallChildIndex = getLeftChildIndex(index);

            if (hasRightChild(index) && isRightChildSmallThenLeftChild(index)) {
                smallChildIndex = getRightChildIndex(index);
            }

            if (isParentSmallThenSmallChild(index, smallChildIndex)) {
                break;
            } else {
                swap(smallChildIndex, index);
                index = smallChildIndex;
            }
        }

    }

    private boolean isParentSmallThenSmallChild(int parentIndex, int childIndex) {
        return elements.get(parentIndex).compareTo(elements.get(childIndex)) < 0;
    }

    private boolean isRightChildSmallThenLeftChild(int parentIndex) {
        return elements.get(getRightChildIndex(parentIndex)).compareTo(elements.get(getLeftChildIndex(parentIndex))) < 0;
    }

    @Override
    public T peek() {
        return this.elements.get(0);
    }

    @Override
    public int size() {
        return this.elements.size();
    }

    @Override
    public boolean contains(T data) {
        return this.elements.contains(data);
    }

    @Override
    protected void swap(int i, int j) {
        final T temp = elements.get(i);
        elements.set(i, elements.get(j));
        elements.set(j, temp);
    }

    public static void main(String[] args) {
        ListHeap<Integer> arrayListListHeap = new ArrayListMinHeap<>();

        arrayListListHeap.add(5);
        arrayListListHeap.add(4);
        arrayListListHeap.add(2);
        arrayListListHeap.add(7);
        arrayListListHeap.add(8);
        arrayListListHeap.add(9);
        arrayListListHeap.add(3);
        arrayListListHeap.add(6);
        arrayListListHeap.add(15);
        arrayListListHeap.add(999);
        arrayListListHeap.add(21);
        arrayListListHeap.add(1);
        arrayListListHeap.add(2393);
        arrayListListHeap.add(8237);
        arrayListListHeap.add(9999);
        arrayListListHeap.add(999);
        arrayListListHeap.add(999);
        arrayListListHeap.add(999);


        arrayListListHeap.printElements();
    }
}

```


</details>



<details>
<summary>배열을 이용한 힙 구현 - 접기/펼치기</summary>

```java
public interface ArrayHeap {
    void add(int data);

    void printElements();

    boolean contains(int data);

    int peek();

    int pop();

    int size();

    default int getParentIndex(int childIndex) {
        return (int) Math.floor(childIndex / 2);// 바닥함수. 내려야한다.
    }

    default int getLeftChildIndex(int parentIndex) {
        return (2 * parentIndex) + 1;
    }

    default int getRightChildIndex(int parentIndex) {
        return (2 * parentIndex) + 2;
    }
    default boolean hasParent(int index) {
        return getParentIndex(index) >= 0;
    }

}

public class ArrayMaxHeap implements ArrayHeap {

    private int[] element;
    private int size;
    private int maxSize;

    public ArrayMaxHeap(int maxSize) {
        this.maxSize = maxSize;
        this.element = new int[maxSize + 1];
        this.size = 0;
    }

    private int leftChildValue(int parentIndex) {
        return element[getLeftChildIndex(parentIndex)];
    }

    private int rightChildValue(int parentIndex) {
        return element[getRightChildIndex(parentIndex)];
    }

    private int parentValueFromChild(int childIndex) {
        return element[getParentIndex(childIndex)];
    }

    private int parentValue(int parentIndex) {
        return element[parentIndex];
    }

    private int getParentData(int index) {
        return element[getParentIndex(index)];
    }

    private boolean isGraterThenChild(int parentIndex) {
        return parentValue(parentIndex) > leftChildValue(parentIndex) && parentValue(parentIndex) > rightChildValue(parentIndex);
    }

    private void swap(int targetIndex, int otherIndex) {
        int temp = element[targetIndex];
        element[targetIndex] = element[otherIndex];
        element[otherIndex] = temp;
    }

    @Override
    public void add(int data) {

        validateSizeAndResize();

        this.element[++size] = data;
        heapifyUpUseWhile(); // or heapifyUpUseFor();
    }

    // insert 할때는 마지막 인덱스부터 루트 인덱스(1) 까지 bottom-up 방식으로 크기를 비교해서 재구성 한다.
    // maxHeap은 큰값이 부모가 되어야 한다
    private void heapifyUpUseFor() {
        for (int i = size; i > 1; i--) {
            int parentIndex = getParentIndex(i);

            if (element[parentIndex] < element[i]) {
                swap(parentIndex, i);
            }
        }
    }

    // insert 할때는 마지막 인덱스부터 루트 인덱스(1) 까지 bottom-up 방식으로 크기를 비교해서 재구성 한다.
    private void heapifyUpUseWhile() {
        int childIndex = size;

        while (hasParent(childIndex) && getParentData(childIndex) < element[childIndex]) {
            swap(getParentIndex(childIndex), childIndex);
            childIndex = getParentIndex(childIndex);
        }
    }

    private void validateSizeAndResize() {
        if (size == this.maxSize) {
            element = Arrays.copyOf(element, maxSize * 2);
            maxSize *= 2;
        }
    }

    @Override
    public int pop() {
        if (size == 0) {
            throw new ArrayIndexOutOfBoundsException("heap is empty");
        }

        int root = element[1];

        element[1] = element[size];
        element[size] = 0;
        this.size = size - 1;

        heapifyDownUseFor();// or heapifyDownUserWhile();

        return root;
    }

    // delete 할때는 루트 인덱스부터 마지막 인덱스까지 top-down 크기를 비교해서 재구성 한다.
    public void heapifyDownUseFor() {
        for (int parent = 1; parent * 2 <= size; ) {

            if (isGraterThenChild(parent)) {
                break;

            } else if (leftChildValue(parent) > rightChildValue(parent)) {
                swap(parent, getLeftChildIndex(parent));
                parent = parent * 2;
            } else {
                swap(parent, getRightChildIndex(parent));
                parent = parent * 2 + 1;
            }

        }
    }

    public void heapifyDownUserWhile() {
        int parent = 1;

        while (parent * 2 <= size) {

            if (isGraterThenChild(parent)) {
                break;

            } else if (leftChildValue(parent) > rightChildValue(parent)) {
                swap(parent, getLeftChildIndex(parent));
                parent = parent * 2;
            } else {
                swap(parent, getRightChildIndex(parent));
                parent = parent * 2 + 1;
            }

        }
    }

    @Override
    public void printElements() {
        if (this.size == 0) {
            return;
        }

        while (!(this.size == 0)) {
            System.out.print(pop() + ", ");
        }

    }

    @Override
    public boolean contains(int data) {
        for (int i = 1; i <= size; i++) {
            if (element[i] == data) {
                return true;
            }
        }
        return false;
    }

    @Override
    public int peek() {
        return element[1];
    }


    @Override
    public int size() {
        return this.size;
    }

    public static void main(String[] args) {
        ArrayHeap arrayMaxHeap = new ArrayMaxHeap(10);

        arrayMaxHeap.add(5);
        arrayMaxHeap.add(4);
        arrayMaxHeap.add(2);
        arrayMaxHeap.add(7);
        arrayMaxHeap.add(8);
        arrayMaxHeap.add(9);
        arrayMaxHeap.add(3);
        arrayMaxHeap.add(6);
        arrayMaxHeap.add(15);
        arrayMaxHeap.add(999);
        arrayMaxHeap.add(2134134);
        arrayMaxHeap.add(21);
        arrayMaxHeap.add(1);
        arrayMaxHeap.add(9918324);
        arrayMaxHeap.add(239328);
        arrayMaxHeap.add(8237237);
        arrayMaxHeap.add(99999999);
        arrayMaxHeap.printElements();
    }
}
                                 
public class ArrayMinHeap implements ArrayHeap {

    private int[] element;

    private int size;

    private int maxSize;

    private int leftChildValue(int parentIndex) {
        return element[getLeftChildIndex(parentIndex)];
    }

    private int rightChildValue(int parentIndex) {
        return element[getRightChildIndex(parentIndex)];
    }

    private int parentValue(int parentIndex) {
        return element[parentIndex];
    }

    private int getParentData(int index) {
        return element[getParentIndex(index)];
    }

    private boolean hasLeftChild(int index) { // 배열이기때문에 음수 값도 들어갈수 있어서 값 대신 size로 비교
        return getLeftChildIndex(index) < size;
    }

    private boolean hasRightChild(int index) { // 배열이기때문에 음수 값도 들어갈수 있어서 값 대신 size로 비교
        return getRightChildIndex(index) < size;
    }

    @Override
    public boolean hasParent(int index) {
        return getParentIndex(index) >= 1;
    }

    private void swap(int targetIndex, int otherIndex) {
        int temp = element[targetIndex];
        element[targetIndex] = element[otherIndex];
        element[otherIndex] = temp;
    }

    private void validateSizeAndResize() {
        if (size == this.maxSize) {
            element = Arrays.copyOf(element, maxSize * 2);
            maxSize *= 2;
        }
    }

    public ArrayMinHeap(int maxSize) {
        this.maxSize = maxSize;
        this.element = new int[maxSize + 1];
        Arrays.fill(element, Integer.MAX_VALUE);
        this.size = 0;
    }

    @Override
    public void add(int data) {
        validateSizeAndResize();

        this.element[++size] = data;
        heapifyUpUseWhile(); // or heapifyUpUseFor();
    }

    // insert 할때는 마지막 인덱스부터 루트 인덱스(1) 까지 bottom-up 방식으로 크기를 비교해서 재구성 한다.
    // min heap은 작은값이 부모가 되야한다.
    private void heapifyUpUseFor() {
        for (int i = size; i > 1; i--) {
            int parentIndex = getParentIndex(i);

            if (hasParent(i) && element[parentIndex] > element[i]) {
                swap(parentIndex, i);
            }
        }
    }

    private void heapifyUpUseWhile() {
        int childIndex = size;

        while (hasParent(childIndex) && getParentData(childIndex) > element[childIndex]) {
            swap(getParentIndex(childIndex), childIndex);
            childIndex = getParentIndex(childIndex);
        }
    }

    @Override
    public int pop() {
        if (size == 0) {
            throw new ArrayIndexOutOfBoundsException("heap is empty");
        }

        int root = element[1];

        element[1] = element[size];
        element[size] = 0;
        this.size = size - 1;

        heapifyDownUseFor();// or heapifyDownUserWhile();

        return root;
    }

    private void heapifyDownUseFor() {
        for (int parent = 1; hasLeftChild(parent); ) {

            if (parentValue(parent) < leftChildValue(parent) && parentValue(parent) < rightChildValue(parent)) {
                break;

            } else if (leftChildValue(parent) < rightChildValue(parent)) {
                swap(parent, getLeftChildIndex(parent));
                parent = parent * 2;
            } else {
                swap(parent, getRightChildIndex(parent));
                parent = parent * 2 + 1;
            }

        }
    }

    // 자식 값중 더 작은 값을 교체해줘야 한다.
    public void heapifyDownUserWhile() {

        int parent = 1;

        while (hasLeftChild(parent)) {

            int smallIndex = smallerOfTheChildren(parent);

            if (hasRightChild(parent) && rightChildValue(parent) < leftChildValue(parent)) {
                smallIndex = getRightChildIndex(parent);
            }

            if (element[parent] < element[smallIndex]) {
                break;
            }

            swap(parent, smallIndex);
            parent = smallIndex;

        }
    }

    private int smallerOfTheChildren(int parentIndex) {

        if (hasLeftChild(parentIndex) && leftChildValue(parentIndex) < rightChildValue(parentIndex)) {
            return getLeftChildIndex(parentIndex);
        } else {
            return getRightChildIndex(parentIndex);
        }
    }

    @Override
    public void printElements() {
        if (this.size == 0) {
            return;
        }

        while (!(this.size == 0)) {
            System.out.print(pop() + ", ");
        }
    }

    @Override
    public boolean contains(int data) {
        for (int i = 1; i <= size; i++) {
            if (element[i] == data) {
                return true;
            }
        }
        return false;
    }


    @Override
    public int peek() {
        return element[1];
    }

    @Override
    public int size() {
        return this.size;
    }

    public static void main(String[] args) {
        ArrayMinHeap arrayMinHeap = new ArrayMinHeap(10);

        arrayMinHeap.add(5);
        arrayMinHeap.add(4);
        arrayMinHeap.add(2);
        arrayMinHeap.add(7);
        arrayMinHeap.add(8);
        arrayMinHeap.add(9);
        arrayMinHeap.add(3);
        arrayMinHeap.add(6);
        arrayMinHeap.add(15);
        arrayMinHeap.add(999);
        arrayMinHeap.add(2134134);
        arrayMinHeap.add(21);
        arrayMinHeap.add(1);
        arrayMinHeap.add(9918324);
        arrayMinHeap.add(239328);
        arrayMinHeap.add(8237237);
        arrayMinHeap.add(99999999);

        arrayMinHeap.printElements();
    }
}

```
</details>





- [힙(Heap)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Heap.md)
- [Data Structure\] Heap](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Heap.md)

* [Binary Heap](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#binary-heap)



# 그래프(Graph)

그래프란 정점(Vertex)과 간선(Edge)로 이루어진 자료구조이다.

* 트리 또한 그래프이며, 트리는 사이클이 허용되지 않고, 그래프는 사이클이 허용된다.
  * 사이클 : 그래프의 특정 정점에서 출발하여 돌아다니다가 다시 처음 출발했던 곳으로 되돌아 갈 수 있으면 사이클이 있다고 한다.

* ![img](https://blog.kakaocdn.net/dn/bdgyLS/btq6BDZM6bK/X20KZquS1PT9wRPhcI063k/img.png)

## 그래프 용어

* 정점 (Vertext, V) : 노드 라고도 하며 데이터가 저장되는 그래프의 기본 원소
* 간선 (Edge, E) : 정점(V, Node)를 연결하는 선, link, brach 라고도 부름
* 인접 정점 (adjacenct vertex, adj) : 간선에 의해 연결된 정점(그림 0, 3  등 이어진 정점)
* 단순 경로 (simple path) :  경로 중에서 반복되는 정점이 없는 경우. 동일한 간선을 지나가지 않는 경로
* 차수 (degree) : 무방향 그래프에서 하나의 정점에 인접한 정점의 수 (0의 차수는 3 -> 1, 2, 3)
* 진출 차수 (out- degree) : 방향 그래프에서 한 정점에서 다른 정점으로 `나가는` 간선의 수
* 진입 차수 (in - dgree) : 방향 그래프에서 외부에서 한 정점으로 `들어오는` 간선의 수
* 사이클(cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우.  



### 그래프와 트리의 차이

* <img src = "https://blog.kakaocdn.net/dn/PSrSI/btrJLSXq9JM/ppmMtenur5pAqv1wEIOUtK/img.png">

## 그래프의 구현 방법

그래프는 구현할 때 행렬(인접행렬) 방식과 리스트(인접리스트) 방식으로 구현할 수 있다.



## 인접행렬 (adjacent matrix)

* 정방 행렬을 사용하는 방법
* 그래프의 노드를 2차원 배열로 행렬로 만든것
* 노드들간에 직접 연결되어있으면 1, 아니면 0을 넣어서 간선 연결 여부를 알 수 있음. 
* 만약 가중치(거리 등)을 입력하는 그래프라면 해당 가중치 값을 넣어준다
* 2차원 배열에 그래프 정점들의 정보가 모두 담겨있기 때문에 속도는 O(1)



* 장점
  * 조회할 때 시간복잡도가 O(1)
  * 구현이 쉽다
* 단점
  * 모든 정점에 간선 정보를 대입해야 하므로 초기화할 때 O(n ^ 2) 시간이 소요된다
  * 무조건 2차원 배열이기 때문에 메모리가 필요 이상으로 사용될 수 있다.

* ![img](https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F035d0fb8-6a69-44d8-8ae0-cfd4410d8f7f%2Fimage.png)

* 1번 노드와 1번 노드는 자기자신이므로 연결정보가 0
* 1번 노드와 3번 노드는 연결되어있으므로 연결정보가 1
* 1번 노드와 6번 노드는 연결되어있지 않으므로 연결정보가 0



## 인접리스트 (adjacent list)

* 연결 리스트를 사용하는 방법 (Linked List)
* 그래프의 노드를 연결리스트로 표현한것
* 정점마다 리스트 배열을 만들어 연결 정보를 알 수 있다.



* 장점
  * 필요한 만큼의 메모리만 사용하기에 낭비가 적다
* 단점
  * 정점들의 연결 정보를 탐색할 때 간선의 갯수만큼의 탐색이 필요하므로 O(n) 시간복잡도가 소요되어 인접행렬에 비해 시간이 오래 소요된다. O(E) = E는 간선 수 (O(n))
  * 구현이 비교적 어렵다 



* ![img](https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F5f21a135-da40-40a7-baaa-637c6ae956a9%2Fimage.png)

* 1번 정점은 2번 3번이랑 연결
* 3번 정점은 2번 3번 4번 5번이랑 연결



## 그래프의 종류

그래프는 간선에 방향을 표시할 수 있는  `방향 그래프` 

방향이 없는 `무방향 그래프`

간선에 가중치가 존재하는 `가중치 그래프`

모든 정점사이에 간선이 존재하는 `완전 그래프`

무방향 그래프에서 모든 정점 쌍에 대해 항상 경로가 존재하는 `연결 그래프` 

무방향 그래프 중에서 특정 정점 사이에 경로가 존재하지 않는 `비연결 그래프` 가 있다





* 무방향 그래프 - 두 정점을 연결하는 간선에 방향이 없는 그래프

* ![img](https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F51f4cb8a-46da-4297-a9e5-26beae1d10c8%2Fimage.png)

---

* 방향 그래프 - 두 정점을 연결하는 간선에 방향이 있는 그래프. 간선의 방향으로만 이동할 수 있다.
* ![img](https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F832e8427-5f72-412c-98f0-779e257ca2cc%2Fimage.png)

---

* 가중치 그래프 - 간선에 가중치가 존재하며, 정점 끼리 이동할 때 비용이 나온 그래프

* ![img](https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2F430d0bbb-77e5-4c4c-90f6-d44ee507816b%2Fimage.png)



---

* 완전 그래프 - 모든 정점사이에 간선이 존재하는 그래프. 고로 사이클도 무조건 존재
* ![img](https://velog.velcdn.com/images%2Fnnnyeong%2Fpost%2Fafcc3bb5-7955-41dd-b04e-7c38164edfc7%2Fimage.png)

---

* 연결 그래프 
  * 무방향 그래프에 있는 모든 정점 쌍에 대해서 항상 간선이 연결되어 있어 경로가 존재하는 그래프
  * 트리가 대표적인 예
* <img src="https://blog.kakaocdn.net/dn/Y8CIN/btrJGU9zJLH/EN5UEgKgHMKGhbfckEsfXK/img.png" style="zoom:150%;" />

---

* 비연결 그래프
  * 무방향 그래프에서 특정 정점 사이에는 경로가 존재하지 않는 그래프
  * 노드들 중 간선에 연결되어 있지 않은 노드가 존재하는 그래프
* <img src="https://blog.kakaocdn.net/dn/kFe68/btrJItYbYVG/EZ4onyXOxgmu1xM70iNeiK/img.png">



## 그래프의 탐색

그래프의, 모든 정점을 탐색하기 위한 방법은 2가지가 있다.

BFS(너비 우선 탐색 - Breadth First Search),

DFS(깊이 우선 탐색 - Depth First Search)



* ![external/blog.ha...](https://w.namu.la/s/1fe9246903b78fae07577b243a0b22791e02cb39640d5cbaae10d9849343b4ea6f162a9a677a5892fbf7819abd4ef7221ebd3608849cfb66793411fb5e6439515a1a8522f8649b6cfc558b18e771eddd2a3ee8d03280ce19936f9fbe7318156f)
  * [출처](https://namu.wiki/w/%EB%84%88%EB%B9%84%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89)





##  DFS, BFS를 활용하면 좋은 상황

DFS와 BFS를 활용하면 좋은 상황으로는 아래와 같은 상황들이 있다.

* (1) 그래프의 모든 정점을 방문하는 것이 주요한 문제: DFS, BFS 모두 무방하다.

* (2) 경로의 특징을 저장해둬야 하는 문제: 
  * 각 장점에 숫자가 있고 a 부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안된다는 문제 등, 
  * 각각의 경로마다 특징을 저장해둬야 하는 경우는 DFS를 사용해야 한다. BFS는 경로의 특징을 저장하지 못한다.

* (3) 최단거리를 구하는 문제: BFS가 유리하다. DFS의 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만 BFS의 경우 먼저 찾아지는 해답이 곧 최단거리이기 때문이다.
  *  미로찾기

* (4) 재귀적이고 백트래킹을 이용하여 모든 경우를 하나하나 탐색하는 완전탐색 문제에서는 DFS가 유리하다.
  * (조합, 순열 등)



* https://foameraserblue.tistory.com/188?category=481823





## BFS(너비 우선 탐색 - Breadth First Search)

넓게 탐색한다고 생각하면 된다.

그래프상의 한 정점으로부터 연결되어있는 모든 정점으로 나아간다.

Tree에서의 Level Order Traversal 형식이다(레벨 먼저 탐색 )

일반적으로 Queue를 사용한다

* 사용하는 경우 : 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을때 사용  -> `최단경로`

### BFS의 특징

* 재귀적으로 동작하지 않는다.
* 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다 (검사하지 않을 경우 무한루프 가능성 있음 )

* 방문한 노드들을 차례대로 저장한 후 꺼낼 수 있는 자료구조인 큐(Queue)를 사용
  * 선입선출(FIFO) 원칙으로 탐색

* 최단 경로를 찾기위해 사용한다.

* DFS와의 가장 큰 차이로, 여러 갈래 중 무한한 길이를 가지는 경로가 존재하고 탐색 목표가 다른 경로에 존재하는 경우 DFS로 탐색할 시에는 무한한 길이의 경로에서 영원히 종료하지 못하지만, BFS의 경우는 모든 경로를 동시에 진행하기 때문에 탐색이 가능하다는 특징이 있다

* <img src="https://blog.kakaocdn.net/dn/br0PrP/btrJKsxVlzL/dVTAxFhAsBNUex69HLvej1/img.png">

* [이미지 출처](https://minhamina.tistory.com/36)

### 진행순서

* 1. 시작 노드를 방문하고 방문한 노드를 체크한다.
  2. 큐에서 꺼낸 노드와 인접한 노드들을 큐에 추가한다(모두 차례대로 방문)
     * 큐에서 꺼낸 노드를 방문한다
     * 큐에서 꺼낸 노드와 인접한 노드들을 모두 방문한다
       * 인접한 노드가 없다면 큐의 앞에서 노드를 꺼낸다(dequeue)
     * 큐에 방문된 노드를 삽입(enqueue)한다
  3. 큐가 공백상태가 될때까지 계속 반복한다





### 구현 방법

* 인접리스트(연결리스트로 된 배열 -> LinkedList[] adjList )
* 인접행렬(2차원 행렬) -> `int[][] adjArra;`

###  

* ![img](https://blog.kakaocdn.net/dn/s9cNv/btqSdtcL9I9/WGH8cw8sqPuRDW1jygiwkk/img.png)

* 정점의 개수에 비해 간선의 개수가 적은 그래프에서는 인접리스트가 유리할 수 있고.
* 모든 정점간 간선이 존재하는 완전그래프에서는 인접행렬이 유리할 수 있다.
* 상황에 따라 최대로 유리한 최선에 방법을 선택하는 것이 좋다.



### Java 구현

<details>
<summary> Java BFS 인접리스트, 인접행렬 구현 - 접기/펼치기 </summary>

```java
public class Graph {
    
    public static class AdjList {
    
        private final LinkedList<Integer>[] adj;
        private final int vertexCount;

        public AdjList(int vertexCount) {
            this.vertexCount = vertexCount;
            adj = new LinkedList[vertexCount];

            for (int i = 0; i < vertexCount; i++) {
                adj[i] = new LinkedList<>();
            }
        }

        public void addEdge(int v, int otherV) {
            adj[v].add(otherV);
        }

        public List<Integer> bfs(int startVertex) {
            boolean visited[] = new boolean[this.vertexCount];

            Queue<Integer> queue = new LinkedList<>();

            visited[startVertex] = true;

            queue.add(startVertex);

            List<Integer> visitOrder = new ArrayList<>();

            while (!queue.isEmpty()) {
                int visitVertex = queue.poll();

                visitOrder.add(visitVertex);

                for (int nextVertex : adj[visitVertex]) {
                    if (!visited[nextVertex]) {
                        visited[nextVertex] = true;
                        queue.add(nextVertex);
                    }
                }
                // 같은 방법
//            Iterator<Integer> iterator = adj[visitVertex].iterator();
//
//            while (iterator.hasNext()) {
//                int nextVertex = iterator.next();
//
//                if (!visited[nextVertex]) {
//                    visited[nextVertex] = true;
//                    queue.add(nextVertex);
//                }
//            }

            }

            return visitOrder;
        }
    }

    public static class AdjArray {
        private final int[][] adjArray;
        private final int vertexCount;

        public AdjArray(int vertexCount) {
            this.vertexCount = vertexCount;
            this.adjArray = new int[vertexCount][vertexCount];
        }

        public void addEdge(int vertex, int otherVertex) {
            adjArray[vertex][otherVertex] = 1;
            adjArray[otherVertex][vertex] = 1;
        }

        public List<Integer> bfs(int startVertex) {
            List<Integer> visitOrder = new ArrayList<>();

            Queue<Integer> queue = new LinkedList<>();
            boolean[] visited = new boolean[vertexCount];

            queue.add(startVertex);
            visited[startVertex] = true;

            while (!queue.isEmpty()) {
                int visitVertex = queue.poll();
                visitOrder.add(visitVertex);

                for (int i = 0; i < adjArray[visitVertex].length; i++) {
                    if (adjArray[visitVertex][i] == 1 && !visited[i]) {
                        queue.add(i);
                        visited[i] = true;
                    }
                }
//                  같은 방식
//                for (int i = 0; i < vertexCount; i++) {
//                    if (adjArray[visitVertex][i] == 1 && !visited[i]) {
//                        queue.add(i);
//                        visited[i] = true;
//                    }
//                }
            }

            return visitOrder;
        }

    }

    public static void main(String[] args) {
        // 인접리스트
        Graph.AdjList listGraph = new Graph.AdjList(4);

        listGraph.addEdge(0, 1);
        listGraph.addEdge(0, 2);
        listGraph.addEdge(1, 2);
        listGraph.addEdge(2, 0);
        listGraph.addEdge(2, 3);
        listGraph.addEdge(3, 3);

        System.out.println(listGraph.bfs(2));

        listGraph = new Graph.AdjList(5);

        listGraph.addEdge(0, 1);
        listGraph.addEdge(0, 2);
        listGraph.addEdge(0, 4);
        listGraph.addEdge(1, 2);
        listGraph.addEdge(3, 4);
        listGraph.addEdge(2, 3);
        listGraph.addEdge(2, 4);

        System.out.println(listGraph.bfs(0));

        // 인접행렬
        Graph.AdjArray arrayGraph = new Graph.AdjArray(4);

        arrayGraph.addEdge(0, 1);
        arrayGraph.addEdge(0, 2);
        arrayGraph.addEdge(1, 2);
        arrayGraph.addEdge(2, 0);
        arrayGraph.addEdge(2, 3);
        arrayGraph.addEdge(3, 3);

        System.out.println(arrayGraph.bfs(2));

        arrayGraph = new Graph.AdjArray(5);

        arrayGraph.addEdge(0, 1);
        arrayGraph.addEdge(0, 2);
        arrayGraph.addEdge(0, 4);
        arrayGraph.addEdge(1, 2);
        arrayGraph.addEdge(3, 4);
        arrayGraph.addEdge(2, 3);
        arrayGraph.addEdge(2, 4);

        System.out.println(arrayGraph.bfs(0));

    }

}
```
</details>





## DFS (Depth First Search)

깊게 탐색.

연결된 노드들을 따라서 더 나아갈 길이 보이지 않을떄까지 깊이 들어간다.

* 루트 노드(정점) 혹은 다른 임의의 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 끝까지 탐색하는법
  * 더 이상 연결된 노드가 없으면 시작한 노드에서 다른 노드로 이동. 
* 모든 노드를 방문하고자 하는 경우에 사용.

* 자기 자신을 호출하는 순환 알고리즘(재귀 형태 )
  * 스택 또는 재귀 함수로 구현 
* BFS 보다 좀더 간단하나 검색 속도 자체는 BFS보다 느리다 

* 트리 순회(전위, 중위 ,후위 순회)는 모두 DFS의 한 종류
* 어떤 노드를 방문했었는지 여부를 반드시 검사 안하면 무한루프 빠질 위험이 있다. 

### 진행순서

* <img src = "https://blog.kakaocdn.net/dn/yjiuZ/btrJD4rxJDl/4soqzotLD3RpVZ1ZPjuuM0/img.png">



* 1. a 노드(시작 노드라고 가정)를 방문하고 방문한 노드를 체크한다.
  2. a 노드의 인접한 노드들을 차례로 순회
     * 방문한 노드와 인접한 노드가 없다면 종료
  3. a노드와 이웃한 노드 b노드를 방문했다면, a와 인접한 다른 이웃한 노드를 방문하기 전에 먼저 방문한 b노드의 인접 노드들을 전부 방문해야한다.
  4. b와 인접한 노드들을 전부 탐색했다면 다시 a에 인접한 정점들 중에서 아직 방문이 안된 정점을 찾는다.
     * 있으면 그 정점을 시작 정점으로 다시 DFS를 시작
  5. 모든 정점을 방문했으면 종료.



### 구현 방법

1. 순환 호출 이용 - 재귀방법
2. 스택 사용 - 인접한 정점들을 스택에 저장하였다가 사용



<details>
<summary> Java 인접리스트 - Stack, Recursiv 구현 - 접기/ 펼치기</summary>

```java
public static class AdjList {
        private int vertexCount;

        private LinkedList<Integer> adj[];

        private boolean[] visited;

        public AdjList(int vertexCount) {
            this.vertexCount = vertexCount;
            adj = new LinkedList[vertexCount];
            for (int i = 0; i < vertexCount; i++) {
                adj[i] = new LinkedList<>();
            }
            visited = new boolean[vertexCount];
        }

        public void addEdge(int vertex, int otherVertex) {
            adj[vertex].add(otherVertex);
            adj[otherVertex].add(vertex);

        }

        public void dfsRecursive(int vertex) {
            visited[vertex] = true;

            System.out.println("visited -> " + vertex);

            for (int next : adj[vertex]) {
                if (!visited[next]) {
                    dfsRecursive(next);
                }
            }
//            while (iterator.hasNext()) {
//                int next = iterator.next();
//
//                if (!visited[next]) {
//                    dfsRecursive(next);
//                }
//            }
        }

        public void dfsStack(int startVertex) {

            Stack<Integer> stack = new Stack<>();
            stack.push(startVertex);
            visited[startVertex] = true;

            while (!stack.isEmpty()) {
                int vertex = stack.pop();

                System.out.println("visited -> " + vertex);

                for (int next : adj[vertex]) {
                    if (!visited[next]) {
                        stack.push(next);
                        visited[next] = true;
                    }
                }

            }

        }

    }
```
</details>



<details>
<summary> Java 인접행렬 - Stack, Recursiv 구현 - 접기/ 펼치기</summary>


```java
public static class AdjArray {
        private int[][] adjArray;
        private int vertexCount;
        private boolean[] visited;

        public AdjArray(int vertexCount) {
            this.vertexCount = vertexCount;
            adjArray = new int[vertexCount][vertexCount];
            visited = new boolean[vertexCount];
        }

        public void addEdge(int vertex, int otherVertex) {
            adjArray[vertex][otherVertex] = 1;
            adjArray[otherVertex][vertex] = 1;
        }

        public void dfsRecursive(int vertex) {
            visited[vertex] = true;

            System.out.println("visited -> " + vertex);

            for (int i = 0; i < adjArray[vertex].length; i++) {
                if (adjArray[vertex][i] == 1 && !visited[i]) {
                    dfsRecursive(i);
                }
            }

        }

        public void dfsStack(int startVertex) {

            Stack<Integer> stack = new Stack<>();
            stack.push(startVertex);
            visited[startVertex] = true;

            while (!stack.isEmpty()) {
                int vertex = stack.pop();

                System.out.println("visited -> " + vertex);

                for (int i = 0; i < adjArray[vertex].length; i++) {
                    if (adjArray[vertex][i] == 1 && !visited[i]) {
                        stack.push(i);
                        visited[i] = true;
                    }
                }

            }

        }

    }
```
</details>





* [Graph](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#graph)

* [참조](https://velog.io/@nnnyeong/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%9E%98%ED%94%84-Graph)
* https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/
* https://suyeon96.tistory.com/32



# 신장 트리와 최소 신장 트리(Minimum Spanning Tree)

신장트리란, 다음 특징을 가지고 있다.

* `그래프 내의 모든 정점을 연결`하고 `사이클이 없는` 그래프.
  * 사이클이 없는것은 트리의 기본 조건 

* https://ssabi.tistory.com/60
* https://sskl660.tistory.com/72
* https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#graph
* https://chanhuiseok.github.io/posts/algo-33/
* https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html

# 해시

- [해시(Hash)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Hash.md)

* [[Data Structure\] Hash(해시)](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/[Data Structure] Hash(해시).md)

* [hash-table](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure#hash-table)

해시테이블 88

# 트라이

- [트라이(Trie)](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer Science/Data Structure/Trie.md)

* [[Data Structure\] Trie(트라이) 자료구조](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data Structure/Trie(트라이).md)

- [[Data Structure\] Tree Map](