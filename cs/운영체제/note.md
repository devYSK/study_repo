# 운영체제

목차 

- [프로세스, 스레드](#프로세스,-스레드)
- [멀티 스레드 vs 멀티 프로세스](#멀티-스레드-vs-멀티-프로세스)
  - [프로세스(process)](##프로세스(process))
  - [멀티 프로세스(Multi process)](##멀티-프로세스(Multi-process))
  - [Context Switching( 컨텍스트 스위칭, 문맥 교환)](##Context-Switching(컨텍스트-스위칭,-문맥-교환))
  - [스레드](##스레드(Thread,-쓰레드))
  - [멀티 스레드](##멀티-스레드-(Multi-Thread,-멀티-쓰레드))
  - [공유자원 (Shared Resource)](##공유자원-(Shared-Resource))
  - [**경쟁상태** (Race Condition)](##경쟁상태-(Race-Condition))
  - [임계 영역(임계구역, Critical Section)](##임계-영역(임계-구역,-Critical-Section))


- [동기화 문제](#동기화-문제)
  - [교착 상태](##교착-상태)
  - [뮤텍스, 상호배제](##뮤텍스(Mutex)-:-상호배제,-Mutual-exclusion,-이진-세마포어-(bynary-semaphore))
  - [세마포어](##세마포어-(Semaphore))
  - [모니터, Monitor](##모니터(Monitor))

- [동기와 비동기](##동기와-비동기)
- [시스템 콜](##시스템-콜)
- [인터럽트](##인터럽트)
- [CPU 스케쥴링](##CPU-스케쥴링(스케줄링,-Scheduling))
- [메모리 관리](##메모리-관리)
- [가상 메모리](##-가상-메모리)
- [페이징 앤 세그맨테이션](##페이징-앤-세그멘테이션(Paging-and-Segmentation))
- [캐시](##캐시)



운영 체제(OS, Operating System)

하드웨어를 관리하고, 컴퓨터 시스템의 자원들을 효율적으로 관리해줍니다.

사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 시스템 소프트웨어.

### 관리하는 자원들

CPU(중앙처리장치), 프로세스 관리, 메모리 관리, 디스크 파일(SSD, HDD), I/O Devices 관리(모니터, 마우스, 키보드, 네트워크)

# 프로세스, 스레드

프로그램(program)

* 어떤 작업을 위해 실행할 수 있는 파일 - 실행 파일



## 프로세스(process)

* 실행중인 프로그램(program)이 메모리에 적재되어 실행되는것

* 운영체제로부터 시스템 자원을 할당받는 작업의 `단위`

  * 할당받는 시스템 자원 : 
    * CPU 시간,  
    * 운영되기 위한 주소 공간, 파일, 메모리 영역 등
    * 프로세스는 각각 독립된 메모리 영역을 할당 받는다. Code, Data, Stack, Heap의 구조로 되어있는 `독립된 메모리 영역` 

* <img src="https://blog.kakaocdn.net/dn/egpi9B/btrI1OJXdbh/ZXOY6BzAnnnGqbJqHATVhK/img.png" width = 750 height = 450/>

  * > [이미지 출처](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)

| Code 영역  | 실행한 프로그램의 코드가 저장되는 메모리 영역 (프로그램 명령어,  소스 코드 자체) |
| ---------- | ------------------------------------------------------------ |
| Data 영역  | 프로그램의 전역 변수와 static 변수가 저장되는 메모리 영역( 전역변수, staticq변수. `정적` ) |
| Heap 영역  | 프로그래머가 직접 공간을 할당(malloc)/해제(free) 하는 메모리 영역(new() 등   `동적`) |
| Stack 영역 | 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 임시 메모리 영역 (지역변수, 매개변수, 함수, 리턴값 `동적`) |

* 한 프로세스는 다른 프로세스의 자원(변수나 자료구조)에 접근할 수 없다. 
  * 다른 프로세스에게 영향을 받지 않는다.
* 접근하려면 `IPC 통신`이 필요하다.



<details>
  <summary>IPC - 접기 펼치기</summary>
  <div markdown="1">  


* 프로세스는 `완전히 독립된 실행객체`이기 때문에 IPC를 이용해서 데이터를 주고받아야 한다.

* `커널이 제공하는 IPC 설비`를 통해 프로세스간 통신을 할 수 있다
  * 커널 : 운영체제가 메모리에 상주하는 부분. `운영체제의 핵심적인 부분`

* IPC의 종류

  1. 익명 PIPE

     > 파이프는 두 개의 프로세스를 연결하는데 하나의 프로세스는 데이터를 쓰기만 하고, 다른 하나는 읽기만 할 수 있다.
     >
     > 한쪽방향으로만 통신이 가능한 반이중 통신
     >
     > 통신할 프로세스를 명확히 알 수 있는 경우에 사용.
     >
     > 양쪽으로 모두 송/수신을 하고싶으면 2개의 파이프를 만들어야한다. -> 전이중통신
     >
     > 반이중 통신으로는 매우 간단하게 사용할 수 있는 장점이 있지만, 전이중통신으로 2개를 만들땐 구현이 복잡해짐.

  2. Named PILE(FIFO)

     >익명 파이프의 확장된 상태.
     >
     >전혀 모르는 상태의 프로세스들 사이 통신에 사용
     >
     >동시에 읽기/쓰기가 불가능하므로 익명파이프처럼 2개를 만들어야 가능.

  3. Message Queue (메시지 큐)

     > 같은점 : 입출력 방식은 Named 파이프와 동일.
     >
     > 다른점 : 파이프처럼 데이터의 흐름이 아닌 메모리 공간. 어디에서나 물건을 꺼낼 수 있는 컨테이너 벨트라고 보면됨(인덱스로 꺼낼 수 있게)
     >
     > 사용할 데이터에 번호를 붙여 여러 개의 프로세스가 동시에 데이터를 쉽게 다를 수 있다.

  4. Shared Memory (공유 메모리)

     > 공유 메모리는 데이터 자체를 공유하도록 지원하는 설비.
     >
     > 통신을 이용해서 데이터를 주고받는것이 아닌 데이터를 아예 공유해서 함께 사용하는것
     >
     > 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스는 해당 메모리 영역에 접근할 수 있게 된다.
     >
     > - **중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동함**

  5. Memory Map (메모리 맵)

     > 공유 메모리처럼 메모리를 공유. 열린 파일을 메모리에 맵핑 시켜서 공유하는 방식
     >
     > (매개채 :  파일. 파일은 시스템이 모두 공유할 수 있는 자원  )

  6. 소켓

     > 네트워크 소켓 통신을 통해 데이터를 공유
     >
     > 클라이언트 - 서버 통신 구조
     >
     > bind - listen - accept
     >
     > 서버에서 bind - listen - accept를 해주어 연결 준비 - 클라이언트에서는 connect를 통해 서버에 요청 - Socket을 send 하여 데이터를 주고 받음.

* 이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 세마포어와 뮤텍스를 사용한다. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)
  </div>

</details>



## 멀티 프로세스(Multi process)

* 하나의 응용 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가  협력적으로 하나 이상의 작업(`Task`)을 동시에 처리하는 것이다. (병렬처리)
  * 동시성은 CPU core가 1개일 때, 여러 process를 짧은 시간동안 번갈아 가면서 연산을 하게 되는 시분할 시스템(time sharing system)으로 실행되는 것입니다.
  * 병렬성은 CPU core가 여러개일 때, 각각의 core가 각각의 process를 연산함으로써 process가 동시에 실행되는 것입니다.
* 장점
  * 안정성이 확보된다. 여러개의 자식 프로세스 중 하나에 문제가 발생해도 그 자식프로세스만 죽으므로 다른 영향이 가지않는다.
    * 다른 프로세스가 문제가 생겨도 정상적으로 수행된다.

* 단점 
  * 프로세스는 각 독립된 메모리 영역을 할당받았기 때문에 공유하는 메모리가 없다. 
  * 그래서 작업량이 많을수록 Context Swtiching 이 자주 일어나서 오버헤드가 발생하여 성능 저하
    * 컨텍스트 스위칭이 발생하면 해당 CPU는 그 발생 기간 동안 아무런 작업을 하지 못하므로 오버헤드 발생



## Context Switching(컨텍스트 스위칭, 문맥 교환)

* CPU에 실행할 프로세스를 교체하는 기술. 프로세스의 상태 정보를 저장하고 복원하는 과정이다.

* CPU가 한 개의 Task(Process / Thread) 를 실행하고 있는 상태에서 Interrupt 요청에 의해 다른 Task 로 실행이 전환되는 과정에서 기존의 Task 상태 및 Register 값들에 대한 정보 (Context)를 저장하고 새로운 Task 의 Context 정보로 교체하는 작업

* CPU를 사용중이며 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(`Context`)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 CPU를 사용하기 위해 이전에 보관했던 프로세스의 상태(문맥)를 복구하는 작업을 말한다.

* 과정

  1. 실행 중지할 프로세스(실행하고 있는 Task)의  정보를 PCB에 저장.

  2. 다음 실행할 프로세스의 PCB 정보를 읽어 register에 적재하고 CPU에 넣고 실행 

  * 이전에 진행했떤 과정을 저장하므로 연속적으로 수행할 수 있다.

* 컨텍스트 스위칭은 많은 비용이 소모된다.

  * 캐시 메모리 초기화
  * 메모리 맵핑 초기화 

* 컨텍스트 스위칭의 비용은 프로세스가 스레드보다 더 많이 든다.

  * 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 Stack 영역만 변경을 진행하면 되기 떄문. 



## PCB (Process Control Block)

프로세스 메타 데이터들을 저장해 놓는 곳, 한 PCB 안에는 한 프로세스의 정보가 담김

- Process Metadata
  - Process ID
  - Process State
  - Process Priority
  - CPU Registers
  - Owner
  - CPU Usage
  - Memeory Usage

* OS는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다.
* 프로세스는 CPU를 할당받아 작업을 처리하다가 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 한다. 이때 작업의 진행 상황을 모두 PCB에 저장한다. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되었던 내용을 불러와 종료되었던 시점부터 다시 작업을 수행한다.
* PIB는 Linked List 형식으로 관리된다. [참조-PCB](https://whereisusb.tistory.com/12), [참조-PCB](https://velog.io/@hoyun7443/PCB)
  * 삽입 삭제 용이.

## 스레드(Thread, 쓰레드)

프로세스 내에서 실행되는 여러 흐름의 단위.

즉 프로세스의 실행 단위.

* <img src="https://blog.kakaocdn.net/dn/l0XEi/btrI9l0L3w8/YlPiiP6Y9EinPwG0h8pvO0/img.png" width=650 />
  * [이미지출처](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)

* 프로세스 내에서 각각 Stack만 따로 할당 받고, Code, Data, Heap 영역은 공유한다
* PC Register(레지스터)도 별도로 갖고있다.
  * 프로세스 간의 자원 공유는 IPC를 이용해야 하지만, 스레드는 Stack영역을 제외한 다른 영역을 공유하기 때문에 자원 공유의 이점을 갖는다. 
  * 스레드는 한 프로세스 내에서 동작되는 여려 실행의 프름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에서 스레드끼리 공유하면서 실행된다.
  * 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 유지한다. (프로세스 간의 데이터 공유는 IPC를 통해서만 가능하다)
  * 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(Siblind thread)도 `그 결과를 즉시 확인 가능.`
  * 하나의 프로세스에 여러개의 스레드 생성 및 실행이 가능하다.
  * 스레드를 Ligh Weigh Process 라고함

* 하나의 프로세스가 생성될 때 기본적으로 하나의 스레드가 같이 생성
* Stack을 쓰레드마다 독립적으로 할당하는 이유
  * 스택은 함수 호출시 전달되는 매개변수, 되돌아갈 주소값(리턴), 함수 내에서 선언하는 지역 변수 등을 저장하기 위해 사용되는 메모리 공간
  * 스택 메모리 공간이 독립적이라는 것은 `독립적인 함수 호출이 가능`하다는 것
  * 스레드의 정의에 따라 `독립적인 실행 흐름을 추가하기 위한` 최소 조건으로 쓰레드마다 독립적으로 할당한다.

* Register(레지스터)를 쓰레드마다 독립적으로 할당하는 이유 
  * PC 레지스터는 명령어를 어디까지 수행하였는지를 나타냄 - > 저장된 상태를 의미
  * 쓰레드도 Context Switching(컨텍스트 스위칭)이 발생하는데 당연히 현재 상태를 모두 저장하고 종료해야 하니 상태값을 저장한다.
  * 명렁어를 어디까지 수행했고 현재 상태를 저장해야 하니 따라서 PC 레지스터를 독립적으로 할당. 

* [자바 스레드(Java Thread) 란 - 출처](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html) 
  * 일반 스레드와 거의 차이가 없으며, JVM가 운영체제의 역할을 한다.
  * 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
  * 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.
  * 아래와 같은 스레드와 관련된 많은 정보들도 JVM이 관리한다.
    * 스레드가 몇 개 존재하는지
    * 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지
    * 스레드의 상태는 무엇인지
    * 스레드 우선순위는 얼마인지
  * 즉, 개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일 뿐이다.

### 스레드의 장단점

* 장점
  * 사용자에 대한 응답성이 향상된다. 왜?
  * 자원 공유가 효율적임 - Data, Code, Heap을 공유하기 때문에.
    * IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요 없다.
    * 프로세스 안에 있으므로 프로세스의 데이터를 모두 접근가능.
  * 그래서 ContextSwitching이 빠르다. 
* 단점
  * 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받는다.
    * 모든 프로세스가 종료될 수 있다.
    * 자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수 있따.
  * 컨텍스트 스위칭 효율이 좋아도, 스레드도 너무많이 생성하면 컨텍스트 스위칭 오버헤드로 인해 성능 저하
    * 리눅스에서는 쓰레드를 프로세스와 같이 다루는데 스레드를 많이 생성하면   모든 스레드를 스케쥴링 해야 하니 오버헤드 발생.



* `프로세스는 자신만의 고유공간과 자원을 할당받아 사용하는데 반해, 스레드는 Stack을 제외한 다른스레드와 공간, 자원을 공유하면서 사용하는 차이가 존재`  



## 멀티 스레드 (Multi Thread, 멀티 쓰레드)



멀티 스레드란 한 프로세스(실행중인 하나의 프로그램) 를 여러개의 쓰레드로 구성하고 각 쓰레드로 하여금 한 작업(task)를 처리하도록 하는 것.

한 프로세스가 동시에 여러개의 일을 수행할 수 있도록 해주는것.

하나의 프로세스에서 여러 작업을 병렬로 처리하는 것이다.

웹 서버는 대표적인 멀티 스레드 응용 프로그램

* 멀티 쓰레드에서는 한 프로세스 내에 여러개의 쓰레드가 있고, 각 쓰레드들은 Stack 메모리를 제외한 Data, Code, Heap 영역을 공유한다. 
* 각 쓰레드가 한 프로세스 내에서 독립적인 기능을 수행한다는 것은 독립적으로 함수를 호출하는것  
* <img src="https://blog.kakaocdn.net/dn/vp6Ax/btrI9lsWxkx/iSXHMM0MoEjBRJefidvuLK/img.png" width = 650 />
  * [이미지 출처](http://www.yes24.com/Product/Goods/78225791)

* 장점 
  * 효율성이 좋다. 
    * 멀티 프로세스(독립적인 프로세스들)에 비해 메모리 공간과 시스템 자원 소모가 줄게 된다
    * 스레드간 통신시  Heap영역을 이용해 데이터를 주고 받으므로 통신이 간단
  * 컨텍스트 스위칭 시 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠르다.
* 단점
  * 안정성에 문제가 있을 수 있다.
    * 하나의 스레드에 문제가 생기면 다른 스레드에도 영향을 끼친다(heap, data, code의 공유 메모리를 갖고있기 때문에.)
    * 프로세스에게로 까지 영향을 끼쳐 프로세스가 종료되면서 전체 쓰레드도 종료될 수 있다.
  * 자원을 공유하기 때문에 `동기화 문제`가 발생한다.



- - 해결책
    - Lock(하드웨어 기반): 동시에 공유자원에 접근하는 것을 막기 위해 Critical section에 진입하는 프로세스는 Lock을 획득하고, Critical section을 빠져나올 때, Lock을 반납한다.
    - Semaphores(소프트웨어 기반)
      - 카운팅 세마포: 가용 자원의 개수로 초기화되어, 자원을 사용할 때마다 세마포가 감소하고, 방출하면 세마포를 증가시킨다.
      - 이진 세마포(Mutual Exclusion): 이진수로 초기화되어, 한 개의 스레드만 접근할 수 있다.
      - Deadlock 문제 발생
        - 스레드/프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, ‘교착 상태’라고도 하며 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.
        - 해결책
          - 여러 개의 스레드/프로세스가 공유자원을 이용할 수 있도록 한다.
          - 스레드/프로세스가 실행되기 전 필요한 모든 자원을 할당한다.



# 멀티 스레드 vs 멀티 프로세스

* 멀티스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 컨텍스트 스위칭이 더 빠릅니다.
* 멀티 프로세스는 멀티 스레드보다 많은 메모리 공간과 cpu 시간을 차지합니다.
* 그러나 멀티 스레드는 오류로 인해 하나의 스레드가 종료되면 전체 스레드 및 프로세스가 종료될 수 있다는 단점이 있고, 스레드의 공유 메모리 영역에 의한 동기화 문제를 가지고 있습니다.
* 멀티 프로세스는 프로세스 끼리 메모리 공간을 공유하지 않으므로 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않기 때문에 안정성이 높습니다.

* 두 방법은 동시에 여러 작업을 수행한다는 측면에서 유사하지만, 적용할 시스템에 따라 두 방법의 장단점을 고려하여 적합한 방식을 선택해야 합니다.

* 메모리 구분이 필요할때는 멀티 프로세스가 유리합니다.

* 반면에 컨텍스트 스위칭이 자주 일어나고 데이터 공유가 빈번한 공유, 자원을 효율적으로 사용해야 하는 경우에는 멀티 스레드를 사는것이 유리합니다.

* |               | 메모리 사용 / CPU 시간           | Context switching | 안정성 |
  | ------------- | -------------------------------- | ----------------- | ------ |
  | multi process | 많은 메모리 공간 / CPU 시간 차지 | 느림              | 높음   |
  | multi thread  | 적은 메모리 공간 / CPU 시간 차지 | 빠름              | 낮음   |

  multi thread가 multi process보다 좋은 점은?

  * multi process를 이용하던 작업을 multi thread로 구현할 경우, 메모리 공간과 시스템 자원 소모가 적다 
  * 또한 process를 생성하고 자원을 할당하는 등의 `system call`을 생략할 수 있기 때문에 자원을 효율적으로 관리할 수 있습니다. 
  * Context switching 시 캐시 메모리를 초기화할 필요가 없어서 속도가 빠르다.
    * 쓰레드는 스택 영역만 초기화 하면 되기 때문

  * 데이터를 주고 받을 때를 비교해보면, process 간의 통신(IPC)보다 multi thread 간의 통신 비용이 적기 때문에 통신으로 인한 오버헤드가 적다.

    * 스레드 끼리는 스택 영역을 제외한 모든 메모리 (data, code, heap)을 공유하기 때문  

    

  * 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더욱 효율적이기 때문

### Thread-safe(스레드 세이프, 쓰레드 세이프)

* 멀티스레드 환경에서 여러 스레드가 `동시에` 하나의 객체 및 변수(공유 자원), 함수에 접근하더라도 프로그램에 실행에 문제가 없고 의도한데로 동작하는 것을 쓰레드 세이프하다고 한다.
* Reetrant(재진입성)
  * 어떤 함수가 reetrant 하다는 것은 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장한다는 의미 
  * 이를 만족하기 위해서 공유 자원을 사용하지 않으면 된다
    * 예를 들어 정적(지역) 변수를 사용하거나 반환하면 안되고 호출 시 제공된 매개변수 만으로 동작
    * reentrant하다면 thread-safe 하지만 그 역은 성립하지 않는다.
* Thread-safe하게 구현하기
  * 뮤텍스 사용 
  * 원자 연산 - Atomic operation 
  * 임계영역(critical section)을 동기화 기법으로 제어해줘야 한다. -> 상호 배제 
    * [세마포어](https://ko.wikipedia.org/wiki/%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4) 등의 락(lock)으로 통제한다  
    * 쓰레드 로컬(Thread local, Thread local storage) - 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용하므로 동시 접근을 막음

### 공유자원 (Shared Resource)

시스템 안에서 각 프로세스, 스레드가 (여러 프로세스) 공동으로 접근하고 이용하는 변수, 메모리, 파일, 데이터를 말한다.

### 경쟁상태 (Race Condition)

공유 자원을 2개 이상의 프로세스나 쓰레드가 병행적으로 읽거나 쓰는 상황.

동시에 접근을 시도할 때 접근 순서 등이 결괏값에 영향을 줄 수 있는 상태.  

1. ##### 커널 작업을 수행하는 중에 인터럽트 발생

   - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
   - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.

2. ##### 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환(컨텍스트 스위칭)이 발생할 때

   - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
   - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함

3. ##### 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때

   - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
   - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법

### 임계 영역(임계 구역, Critical Section)

공유 자원에 2개 이상의 프로세스나 쓰레드가 접근할 때 경쟁상태가 일어날 수 있는 영역.(접근 순서 등에 결과값을 줄 수 있는 상태) 



# 동기화 문제

동기화 : 한정적인 시스템 자원에 여러 스레드가 동시에 접근하면 문제가 발생할 수 있다.

이 문제를 방지하기 위해 여러 스레드에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정하는 기법

#### 동기화 문제를 해결하기 위한 동기화 기법

### 뮤텍스(Mutex) : 상호배제, Mutual exclusion, 이진 세마포어 (bynary semaphore)

* 임계 영역을 가진 스레드들의 실행시간(running time)이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술
* 공유 자원의 데이터를 여러 프로세스, 스레드가 접근하는 것을 막고 프로세스/스레드 수를 `1개로 제한.`!!!
* 공유 자원에 대한 접근을 조율하기 위해 lock, unlock을 사용
  * 락에 대한 소유권이 있으며 락을 가지고 있을 경우에만 공유 자원에 접근할수 있고, 락을 가진 사람만 자원을 반납할 수 있다.
  * lock : 현재 임계 영역에 들어갈 권한을 얻어옴(다른 프로세스나 스레드가 임계 영역 접근중이면 종료할떄까지 대기)
  * unlock: 현재 임계 영역을 모두 사용했음을 알림(대기 중인 다른 프로세스/스레드가 임계 영역에 진입할 수 있다.)
  * `임계 영역에 들어가기 전에 반드시 락을 획득해야 하고 빠져나올때 락을 반납해야 한다` 

* 뮤텍스는 락 또는 언락 상태만을 가진다. 



### 세마포어(Semaphore)

* 공유 자원에 데이터를 여러 프로세스, 스레드가 접근하는 것을 막음. - 프로세스 / 스레드의 개수는 2개 이상이 될 수 있다.

* 뮤텍스와의 가장 큰 차이점은, 뮤텍스는 공유 자원에 접근할 수 있는 프로세스/스레드의 개수가 1개 이지만, 세마포어는 2개 이상이 될 수 있다.

* Counter : 동시에 접근할 수 있는 허용 가능한 갯수(공유 자원에 접근할 수 있는 프로세스/스레드의 수를 나타내는 값)

* 세마포어 변수 

  * S : S값 만큼 프로세스나 스레드가 접근이 가능하다

  * P(wait 라고도 함) : 검사. S값이 1 이상이면 임계 영역 진입후 S값 1 차감 (0이면 대기)

  * V(signal 라고도 함) : 증가. 임계 영역에서 나올 때 S값을 1 더하고 나온다. 

    1. S값이 0보다 크면 임계영역으로 접근이 가능하고, 접근한 다음 S값을 감소한다. S값이 0이라면 다른 프로세스/스레드는 접근할 수 없다. 
    2. 임계영역에서 작업을 마치고 나올 떄 S값을 1 증가시킨다.

    * ```
      wait(S) 
      // -> 이 영역이 임계 영역(critical section)
      signal(S)
      ```

  * 세마포어 값(S)가 0 또는 1만 가질 수 있는 경우 binary semaphore라고 하고 이는 뮤텍스랑 유사하게 작동한다



### 모니터(Monitor)

* 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체 (추상화된 데이터 형태)
* 공유 자원에 접근하기 위한 키(락) 획득과 해제를 모두 처리한다 ( 자동이다. )



* 뮤텍스와 세마포어 기법의 차이

  * 세마포어는 뮤텍스가 될 수 없지만, 뮤텍스는 세마포어가 될 수 있다.

  * 뮤텍스는 오직 1개의 프로세스/스레드만 공유 자원에 접근할 수 있고, 세마포어는 세마포어 변수(S)값 만큼 프로세스 들이 동시에 자원에 접근할 수 있다.

    

* 뮤텍스와 모니터의 차이

  * 뮤텍스는 다른 프로세스나 스레드 간에 동기화를 위해 사용
  * 모니터는 하나의 프로세스 내에서 다른 스레드간에 동기화 할 때 사용 
  * 뮤텍스는 운영체제 커널에 의해 제공 -> 무겁고 느리다
  * 모니터는 프레임워크나 라이브러리 그 자체에서 제공 -> 가볍고 빠르다 

  

* 모니터와 세마포어 차이
  * 모니터는 세마포어보다 구현하기 쉬우며 상호 배제가 자동인 반면, 세마포어에서는 명시적으로 직접 상호배제를 구현해야 한다. 
  * 자바에서는 모니터를 모든 객체에게 기본적으로 제공하지만 C에서는 상요할 수 없음.
  * 세마포어는 카운터 변수(S)를 개발자가 상호 배제나 정렬의 목적으로 사용 시 매번 값을 따로 지정해줘야하는 번거로움이 있음.
    * 모니터는 이러한 일들이 캡슐화 되어 있어서 개발자는 synchronizaed, wait(), notify()등의 키워드를 이용해 좀더 편하게 동기화 가능.



# 교착 상태

* 한정된 자원을 여러 프로세스/스레드에서 사용하려고 할 때 발생하는 문제

* 둘 이상의 스레드가 각기 다른 스레드가 점유하고 있는 자원을 `서로`가 기다릴 때 무한 대기에 빠져 중단된 상황

  * 다음 단계로 진행하지 못하는 상태

* 교착 상태의 발생 조건

  * 상호 배제(Mutext), 점유 대기(hold and Wait), 비선점 (No Preemption), 순환 대기(Circula Wait)이 `동시에 성립할때 발생`.

  * 4가지 조건중 하나라도 성립하지 않는다면 교착상태를 해결할 수 있다. 즉 하나만 해결하면 해결된다. 

    1. 상호 배제(Mutual Exclusion)
       * 자원은 한 번에 한 프로세스만이 사용할 수 있다.

    2. 점유와 대기(Hold and Wait)
       - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

    3. 비선점 (No Preemption)
       - 다른 프로세스에 할당된 자원은 사용이 끝나서 반납할 때까지 강제로 빼앗을 수 없다.

    4. 순환 대기 (Circular Wait)

       - 프로세스의 집합 {P0, P1, ..., Pn}에서 0은 1이 점유한 자원을 대기하고 1은 2가 점유한 자원을 대기하고 Pn은 P0이 점유한 자원을 요구해야 한다.

       - 이처럼 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.

  

* 교착 상태를 해결하는 방법

  * 예방 - 교착 상태 발생 조건 4가지중 하나를 제거함

    * 자원의 상호배제 조건 방지  - 모든 자원을 공유 허용 
    * 점유와 대기 조건 방지 - 모든 자원에 대해 선점 허용
    * 비선점 조건 방지  필요 - 자원을 한 번에 모두 할당하기
    * 순환 대기 조건 방지  -자원에게 순서 부여를 통해 프로세스 순서의 증가 방향으로만 자원 요청
    *  단점 : 자원 낭비가 심함

    

* 은행원 알고리즘
  * 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 검사하여 교착 상태를 회피하는 기법이다.
  * 안정 상태에 있으면 자원을 할당하고 그렇지 않으면 다른 프로세스들이 자원을 해제할 때까지 대기한다.

### 기아 상태

* 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
* 교착상태와 기아상태
  * 교착상태는 여러 프로세스가 동일 자원을 점유 요청할 때 발생
  * 기아상태는 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자원 할당이 안되는 경우를 주로 의미



## 동기와 비동기

*  동기 : 메서드나 함수를 실행시킴과 동시에 반환 값이 기대되는 경우를 **동기**

* 그렇지 않은 경우에 대해서 **비동기**라고 표현한다. 
  * "동시에"라는 말은 실행되었을 때 값이 반환되기 전까지는 blocking되어 있다는 것을 의미한다.
  *  비동기의 경우, blocking되지 않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task를 위임하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.

- 동기(synchronous : 동시에 일어나는)
  - 동시에 일어난다는 뜻이다.  요청과 그 결과가 동시에 일어난다는 약속이다.
  - 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 한다.
  - 요청과 결과가 한 자리에서 동시에 일어난다.
  - A노드와 B노드 사이의 작업 처리 단위(transaction)를 동시에 맞추겠다.
- 비동기(Asynchronous : 동시에 일어나지 않는)
  - 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을 것이라는 약속이다.
  - 요청한 그 자리에서 결과가 주어지지 않는다.
  - 노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.
- 동기 방식은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 한다는 단점이 있다.
- 비동기 방식은 동기보다 복잡하지만, 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다는 장점이 있다.



## 시스템 콜



운영체제가 커널에 접근하기 위한 인터페이스

OS의 특정 기능을 쓸 수있게 하는 인터페이스를 요청하는 함수

유저 프로그램이 운영체제의 서비스나 시스템 호출을 하기 위해 고급 API를 통해 커널 함수를 호출할 때 사용 

커널 모드와 사용자 모드에 대해서 알아야 한다.

OS는 는 Kernel Mode와 User Mode로 나뉘어서 구동된다.

시스템 콜이 작동될 때 modebit를 참고해서 커널 모드와 사용자 모드를 구분한다.

커널 모드는 0 사용자 모드는 1

1. 커널 모드
   * 프로그램 카운터가 운영체제가 존재하는 부분을 가리키고 있으면 운영체제의 코드를 수행중이며 CPU가 커널모드에서 수행중이라고 한다.
2. 사용자 모드
   * 프로그램 카운터가 사용자 프로그램이 존재하는 메모리 위치를 가리킬 경우, 사용자 프로그램을 수행중이며 CPU가 사용자 모드라고 한다.

### 시스템 콜의 유형

5가지의 범주로 나눌 수 있다.

1. 프로세스 제어 : 프로세스 특권 모드를 사용해 직접적으로 프로세스 제어가 가능
2. 파일 조작 : 파일을 생성하거나 삭제, 관리 등
3. 장치 관리 : 장치 요구 및 장치 해제, 읽기, 쓰기, 재배치 등
4. 정보 유지 : 시간과 날짜의 설정과 획득, 시스템 자료의 설정과 획득
5. 통신 : 통신 연결의 생성 및 제거, 메시지의 송수신, 상태 정보 전달 등

### 

---

## 인터럽트 

CPU가 프로그램을 실행하고 있을 때 예기치 않은 상황이나 입출력 하드웨어 이벤트 등이 발생했을 경우, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는것

CPU가 잠깐 정지된다

인터럽트의 종류

1. 내부 인터럽트( 주로 소프트웨어 인터럽트라고 함, 트랩(trap) )

* 주로 프로그램 내부에서 잘못된 명령으로 프로세스 오류 예외나 시스템 콜이 발생할 때 발생
  * 0으로 나누는 연산, 오버플로우, 언더플로우 등



2. 외부 인터럽트 ( 주로 하드웨어 인터럽트라고 함)

* 하드웨어에서 발생하는 인터럽트
  * IO디바이스로 인한 인터럽트 - 키보드 등
  * 전원 이상, 기계 문제
  * 타이머   



* 인터럽트 발생 처리 과정

> 주 프로그램이 실행되다가 인터럽트가 발생
>
> 현재 수행중인 프로그램을 멈추고, 현재 수행중인 명령, 상태 레지스터  PC 등을 스택에 잠시 `저장` 한 뒤 인터럽트 서비스(처리) 루틴으로 이동 -> PCB에 저장 
>
> 인터럽트 처리 루틴에서 인터럽트를 처리하고 수행중이였던 프로그램의 저장한 정보를 바탕으로 다시 돌아와 저장된 지점부터 명령 수행

* 만약 인터럽트 기능이 없다면, 컨트롤러가 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야함 -> polling 이라고 한다.
  * 폴링을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있다.

- 인터럽트 벡터(Interrupt Vector)
  - 여러가지 인터럽트에 대해 해당 인터럽트 발생시 처리해야 할 루틴의 주소를 보관하고 있는 테이블.
  - 일종의 함수를 가리키는 포인터
- 인터럽트 핸들러(Interrupt Handler)
  - 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 한다.
  - 운영체제 코드 부분에는 각종 인터럽트 별로 처리해야 할 내용이 이미 프로그램되어 있으며, 이 부분을 인터럽트 서비스 루틴 또는 인터럽트 핸들러라고 한다.

예를 들어, 입출력 관련 인터럽트가 발생한 경우, CPU는 인터럽트 라인을 통해 발생한 인터럽트를 확인한다. 

인터럽트 벡터를 통해 해당 인터럽트 발생시 처리해야 할 루틴의 메모리 주소를 알아낸다. 

주소를 통해 실제 수행되어야 할 코드가 담겨있는 루틴을 찾아가 상황에 맞는 처리를 진행한다.



## CPU 스케쥴링(스케줄링, Scheduling)

CPU가 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 수행해야 한다. 

이때 어떤 프로세스를 다음에 처리할 지 선택하는 알고리즘을 CPU Scheduling 알고리즘이라고 한다. 

상황에 맞게 CPU를 어떤 프로세스에 배정하여 효율적으로 처리하는방법

* 오버헤드를 낮추고, 사용률을 높히고, 기아현상을 낮추는것 



#### 선점형 스케쥴링

* #### 선점(Preemptive) : 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생하지 않았을 경우에도 CPU를 뺏는것. 점유

* 처리시간 예측이 어렵다.



1. SRT(Shortest Remaining Time) : 최단 잔여(짧은) 시간 우선
   * 잔여시간이 짧은 순서대로 프로세수 수행.
   * 현재 프로세스가 남은 CPU 버스트 시간보다 더짧은 CPU 버스트시간을 가진 프로세스가 도착하면 나중에 온 애가 선점



2. RR, RoundRobin() : 라운드로빈

      * 큐 이용. 각 프로세스는 동일한 크기의 사용 시간을 할당받음.

      * 할당 시간이 지나면 프로세스는 선점당하여 큐의 제일뒤에가서 다시 줄을 선다.

      * 이 작업을 모든 프로세스가 돌아가면서 진행

      * 장점으로 응답시간이 빨라지고, 각 프로세스들이 공평하게 사용된다.

      * 단점으로는 할당된 시간이 작으면 컨텍스트 스위칭이 잦아져서 오버헤드 증가 



3. Multilevel-Queue(멀티레벨 큐, 다단계 큐)
   * 프로세스를 그룹으로 나누어 각 그룹에 따라 큐를 여러 개 두고 각 큐마다 다른 규칙을 지정하여 사용.
   * 프로세스들이 여러줄로 슨다.



4. Multilevel feedback queue(멀티레벨 피드백 큐, 다단계 피드백 큐 )

   * 기본적으로 다단계 큐와 동일하나, 프로세스가 기다리고 있던 큐에서 다른 큐로 이동가능하다.

   * 기다리고 있던 큐에 대기시간이 너무 길면 대기시간이 짧은 큐로 프로세스를 옮겨서 대기시간을 조정 

   * 대부분의 상용 운영체제는 여러개의 큐를 사용하고 각 큐마다 다른 스케쥴링을 사용하여 최대한 효율을 높힌다.



2. 비선점형 스케쥴링

* 비선점(Non-Preemptive) : 프로세스가 CPU를 점유하면 I/O나 인터럽트 발생 또는 프로세스가 종료될 떄 까지 다른 프로세스가 CPU를 못뺐음
  * 처리시간 예측이 용이  



1. FCFS(First Come, First Served, FIFO)
   * 먼저 큐에 온 순서대로 처리.
   * 실행시간이 짧은게 뒤로가면 평균 대기시간이 길어짐



2. SJF(Shortest - Job - First)
   * 다른 프로세스가 먼저 도착했어도 수행시간이 가장 짧은 프로세스를 먼저 처리
   * FCFS보다 평균 대기시간 감소 
   * 그러나 사용시간이 긴 프로세스는 거의 영원히 할당받을 수 없다. 



3. Priority : 우선순위

* 우선순위(정수로 나타냄)가 가장 높은 프로세스에게 할당한하는 스케줄링
* 선점 / 비선점 모두 가능 
* 우선순위가 낮으면 기아상태 발생 



## 메모리 관리

메모리는 CPU가 접근할 수 있는 기억 장치. 휘발성. 프로세스가 메모리에 올라와서 실행되면 프로그램

메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성
- 레지스터: CPU 안에 있는 작은 메모리, 휘발성, 속도 가장 빠름, 기억 용량이 가장 적음.
- 캐시: L1, L2 캐시를 지칭합니다. 휘발성, 속도 빠름, 기억 용량이 적음.
- 주기억장치: RAM을 가리킵니다. 휘발성, 속도 보통, 기억 용량이 보통
- 보조기억장치: HDD, SDD를 일컬으며 비휘발성, 속도 낮음, 기억 용량이 많다.



CPU는 레지스터가 지시하는대로 메모리에 접근하여 다음에 수행할 명령어를 가져옴

명령어 수행 시 메모리에 필요한 데이터가 없으면 해당 데이터를 우선 가져와야 함

이 역할을 하는 것이 바로 **MMU**.

#### MMU (Memory Management Unit, 메모리 관리 장치)

- 논리 주소를 물리주소로 변환해 준다.
- 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해주는 하드웨어

논리적 주소(logical address)란?

* process가 memory에 적재되기 위한 독자적인 주소 공간인 논리적 주소(logical address)가 생성.
*  논리적 주소는 각 process마다 독립적으로 할당되며, 0번지부터 시작.

물리적 주소(physical address)란?

* 물리적 주소(physical address)는 process가 실제로 메모리에 적재되는 위치.

주소 바인딩(address binding)이란?

* CPU가 기계어 명령을 수행하기 위해 process**의 논리적 주소가 실제 물리적 메모리의 어느 위치에 매핑되는지 확인하는 과정**을 주소 바인딩(address binding)



## 가상메모리

가상 메모리는  OS에서 사용되는 메모리 관리 기술.

컴퓨터의 물리적 메모리 부족을 보완하고, RAM에서 디스크로 데이터를 일시적으로 전송하는 스와핑을 할수 있게 하며, 보조 메모리를 주 메모리 인것처럼 처리하기도 함.

메모리가 실제로 메모리보다 많아 보이게 하는 기술. 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술

* 가상 메모리의 주요 기능
  * 주 기억장치의 효율적 관리(스와핑): 하드디스크를 주 기억장체에 대한 캐시로 설정하여 당장 사용하는 영역만 유지하고 쓰지 않는 데이터는 하드디스크로 옮긴 뒤 필요할 때만 램에 데이터를 불러와 올리고 사용하지 않으면 하드디스크로 옮겨 램을 효과적으로 관리
  * 메모리 용량 및 안정성 보장 : 램은 한정된 공간. 램을 거의 무한한 가상메모리 공간을 배정함으로써 프로세스들 끼리 메모리 침범이 일어날 여지를 줄인다. 



## 페이징 앤 세그멘테이션(Paging and Segmentation)

가상 메모리를 관리하는 기법

페이징이란, 프로세스가 할당받은 메모리 공간을 일정한 page 단위로 나누어 물리 메모리에서 연속되지 않는 서로 다른 위치에 저장하는 메모리 관리 기법

- 프로세스를 나눈 조각을 Page라 하고, 메모리를 나눈 조각을 Frame이라 한다.
- 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다.

* 스와핑
  * 페이지 폴트가 발생한 경우 메모리의 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의
    일부분을 “마치 메모리처럼” 불러와 쓰는 것.

* 페이지 폴트

  * 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에
    발생하는 것.

* 스레싱

  * 메모리의 페이지 폴트율이 높은 것을 의미함

  

**메모리 단편화(Memory fragmentation)** 

* 물리적 메모리 공간이 작은 조각으로 나눠져서 메모리가 충분히 존재함에도 할당이 불가능한 상태를 메모리 단편화 라고 함

* paging 기법에서는 process의 논리적 주소 공간과 물리적 메모리가 같은 크기의 page 단위로 나누어지기 때문에 외부 단편화 문제가 발생하지 않는다. 
* 하지만 process 주소 공간의 크기가 page 크기의 배수라는 보장이 없기 때문에, 프로세스의 주소 공간 중 가장 마지막에 위치한 page에서는 내부 단편화 문제가 발생할 가능성이 있다.



### 메모리할당 : 고정분할과 가변분할 (연속할당)

* 연속 할당 : 메모리에 ‘연속적으로’ 공간을 할당하는 것

  - 고정분할 : 메모리를 미리 나누어 관리. 내부단편화

  - 가변분할 : 매시점 프로그램에 맞춰 동적으로.외부단편화





### 메모리할당 : 페이징, 세그멘테이션, 페이지드 세그멘테이션 (불연속할당)

* 불연속 할당 : 메모리를 연속적으로 할당하지 않는 기법

  - 페이징(paging) : 동일한 크기(보통 4kb)의 페이지 단위로 나누어 메모리의 서로 다른 위치에
    프로세스를 할당합니다. 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이
    복잡해짐.

  - 세그멘테이션 : 페이지 단위가 아닌 의미 단위인 세그먼트(segment)로 나누는 방식입니다.
    프로세스는 코드, 데이터, 스택, 힙 등으로 이루어지는데, 코드와 데이터 등 이를 기반으로
    나눌 수도 있으며 함수 단위로 나눌 수도 있음을 의미합니다. 공유와 보안 측면에서 좋으며
    홀 크기가 균일하지 않은 문제가 발생됨

  - 페이지드 세그멘테이션 : 공유나 보안을 의미 단위의 세그먼트로 나누고, 물리적 메모리는
    페이지로 나누는 것을 말함.

### 페이지교체 알고리즘 : FIFO, LRU, NUR, LFU

- FIFO : 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법
- LRU : 참조가 가장 오래된 페이지를 바꾸는 방법
- NUR : 일명 clock 알고리즘이라고 하며 먼저 0과 1을 가진 비트를 둡니다. 1은 최근에
  참조되었고 0은 참조되지 않음을 의미합니다. 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간
  해당프로세스를 교체하고, 해당 부분을 1로 바꾸는 알고리즘
- LFU : 가장 참조 횟수가 적은 페이지를 교체하는 알고리즘



## 캐시



캐시는 CPU 칩 안에 들어가는 작고 엄청 빠른 메모리이다. 용량이 작고 비싸다.

프로세서가 매번 메인 메모리에 접근하여 데이터를 받아오면 시간이 오래걸리기 때문에, 캐시에 자주 사용하는 데이터를 담아두고 

메인 메모리보다 캐시에 접근해서 가져와서 처리 속도를 높혀 병목 현상을 줄이기 위한것이 캐시이다.



* 캐시의 지역성
  * 시간 지역성(Temporal locality)
    * 가장 최근에 접근한 데이터의 주소에 다음에도 다시 접근하는 특성
    * 가령 for 루프의 i가 있다. 
  * 공간 지역성(Spatial locality)
    * 최근에 접근한 데이터의 주소와 인접한 주소의 내용들이 다시 접근되는 특성
    * 가령 루프에서의 배열요소들

* 캐시 히트(cash hit) : 캐시에서 원하는 데이터를 찾은것
  * hit rate(캐시 적중율) : 캐시 적중율을 극대화 하기 위해 지역성의 원리를 이용한다
    * 지역성의 원리의 전제조건은 프로그램은 모든 코드나 데이터를 균등하게 Access하지 않는다는 특성을 기본으로 한다.

* 캐시 미스(cash miss) : 해당 데이터가 캐시에 없다면 주 메모리로 가서 데이터를 찾아오는것 



* 캐싱 라인(caching line)

  * 빈번하게 사용되는 데이터들을 캐시에 저장하더라도 필요한 데이터를 찾을 때 모든 데이터를 순회하는것은 시간낭비.
  * 캐시에 데이터를 저장할 시 자료구조를 활용해 묶어서 저장하는것을 캐싱 라인이라고 함 

  1. Full Associative
  2. Set Associative
  3. Direct Map







## 참조

* https://github.com/gyoogle/tech-interview-for-developer
* https://github.com/WooVictory/Ready-For-Tech-Interview
* https://github.com/cheese10yun/TIL/blob/master/OS/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C_%EA%B8%B0%EC%B4%88.md
