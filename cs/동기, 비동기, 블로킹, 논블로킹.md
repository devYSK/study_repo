# 동기 비동기, 블로킹 논블로킹

이 두가지 개념은 **서로 전혀 다른 곳에 초점을 맞춘 별개의 개념**들이므로 서로 직접적인 관련은 거의 없다고 봐도 됩니다.



동기(sync) / 비동기(async)는 **행위**에 관한 개념 - 프로세스의 수행 순서에 관한 매커니즘

블럭(block) / 논블럭(non-block)은 **함수 호출**에 관한 개념 - 프로세스의 제어권에 관련된 매커니즘

>  \- 제어권 : 제어권은 자신(함수)의 코드를 실행할 권리 같은 것이다. 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려준다.
>  \- 결과값을 기다린다는 것 : A 함수에서 B 함수를 호출했을 때, A 함수가 B 함수의 결과값을 기다리느냐의 여부를 의미한다.

Blocking / Non-Blocking이 **현재의 작업 상태**에 따라 동작이 결정되는것이라면, Synchronous / Asynchronous는 **결과를 기다리는 주체가 누구인가**에 대한 이야기입니다.



# 동기(Synchronous) / 비동기(Asynchronous)

동기(Synchronous)와 비동기(Asynchronous)는 어떤 일을 수행할 때 그 일의 결과가 돌아오는 시간과 그 일을 수행하는 동안 다른 작업을 수행할 수 있는지 여부에 따라 구분됩니다.

> **블록/논블록과 다르게 기술적으로 구분되지 않으며**, 추상적인 구분 즉, 행위에 대한 이야기

* 5개를 요청했는데 응답에서 그 순서가 지켜진다면 Sync이고 어떤 게 먼저 올지 모른다면 Async입니다.

동기와 비동기는 어떠한 프로세스를 처리하는데 절차적인 측면이 강합니다.

이 둘의 차이점은 **'호출되는 함수의 작업 완료 여부를 누가 신경 쓰는지'에**(관찰하는가) 대한 관점으로 볼 수 있습니다.

* 블록과 유사하지만, 호출한 함수가 호출된 함수의 결과를 확인합니다. 

* 만약 작업 A가 작업 B를 관찰하는 작업(호출한)이라면 작업 A와 작업 B가 동시에 처리되더라도 동기입니다. 즉 신경쓰느냐 안쓰느냐 차이라고도 볼 수 있습니다.

> **Synchronous** : 작업을 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작
> **Asynchronous** : 시작, 종료가 일치하지 않으며, 끝나는 동시에 시작을 하지 않음

<img src="https://blog.kakaocdn.net/dn/b0HbfT/btsbT2l80pD/yztdpSdHqWh1KZCP7mSSHk/img.png" width = 900 height = 400>

# 동기(Synchronous)

요청을 보낸 후 응답을 받아야 다음 동작을 진행할 수 있으며, 요청자가 응답을 신경 쓰는 방식 (계속 관찰하는 방식). 

* 요청과 결과가 <u>동시에 일어나는</u> 방식
* 3개의 요청에서 응답에서 그 순서가 지켜진다면 동기이다. 

**호출하는 함수 A**가 **호출되는 함수 B**의 작업 완료 후 리턴을 기다리거나,

바로 리턴 받더라도 미완료 상태이라면 작업 완료 여부를 스스로 계속 확인하며 **신경쓰면 동기이다(Synchronous)**

* 함수 A, B를 클라이언트와 서버개념으로 생각해도 된다. 



이러한 동기 방식은 설계가 간단하고 직관적이지만 결과를 받을 때까지 다른 작업을 못하고 대기해야 하는 단점이 있습니다.



장점:

- 결과값을 바로 사용할 수 있어서 간단하고 직관적입니다.
- 코드가 순차적으로 실행되기 때문에 디버깅이 상대적으로 쉽습니다.
- 서버와 클라이언트 사이의 요청과 응답이 일치하므로 데이터 일관성 유지가 용이합니다.

단점:

- 요청을 보낸 후 응답이 올 때까지 대기해야 하므로, 다른 작업을 수행하지 못하고 대기해야 합니다. 이로 인해 시스템 전체 성능이 저하될 수 있습니다.
- 서버에서 응답이 오지 않으면 클라이언트는 영원히 기다려야 할 수 있습니다. 이를 데드락(deadlock)이라고 합니다.
- 서버 부하가 많을 경우, 대기 시간이 길어질 수 있습니다.

# 비동기(Asynchronous)

요청을 보낸후 응답을 받지 않아도 요청자는 다음 동작을 진행할 수 있으며, 요청자는 응답을 신경쓰지 않는 방식. 

* 두 주체가 서로의 시작이나 종료시간에 관계없이 별도의 시작, 종료 시간을 가지고 있다

**함수 A**는 **함수 B**를 호출한 후로 함수 B의 작업 완료 여부에는 신경쓰지 않는다. (관찰하지 않는다)

**함수 A**가 **함수 B**를 호출할 때 **콜백 함수를 함께 전달**해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다.

* 함수를 호출하는 곳에서 결과를 기다리지 않고, 다른 함수(Callback)에서 결과를 처리합니다.
* 리턴값(결과물)을 주로 콜백 함수를 통해 가져옵니다.



장점:

- 요청과 응답이 분리되어 있기 때문에, 다른 작업을 수행하면서도 여러 개의 요청을 처리할 수 있습니다.
- 대기하지 않고 다음 작업을 수행하기 때문에, 전체적인 성능이 향상됩니다. 때문에 사용자 관점에서 만족도가 높아질 수 있습니다. 
- 서버 부하가 많을 때도 대기 시간이 상대적으로 짧습니다.

단점:

- 코드가 복잡해지며, 비동기 처리 방식에 대한 이해가 필요합니다.
- 순서를 보장하지 않기 때문에, 결과값을 처리하기 전에 다음 작업을 수행해버리는 문제가 발생할 수 있습니다.

# 블로킹과 논블로킹

블로킹과 논블로킹은 호출자가 피 호출자를 호출했을 때, **제어권을 누가 갖고있느냐 **는 관심사입니다.

* 제어권이란 함수를 실행하고 통제할 권리

* 처리되어야 하는 (하나의) 작업이, **전체적인 작업 '흐름'을 막느냐 안막느냐**에 대한 관점
   

Blocking : 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것
Non-Blocking : 다른 주체의 작업에 관련없이 자신의 작업을 하는 것



Blocking / Non-Blocking의 차이는 **'제어권이 어디 있는지'에** 대한 관점으로 볼 수 있습니다.

 

*(제어권이란, 자신(함수)의 코드를 실행할 권리 같은 것으로 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후에 자신을 호출한 함수에게 제어권을 돌려줍니다.)*



블로킹(Blocking)과 논블로킹(Non-Blocking)은 어떤 작업을 수행할 때 그 작업의 완료 여부를 확인하는 방식에 따라 구분됩니다.

 

# 블로킹 (Blocking)

자신의 작업을 진행하다가, 다른 작업을 호출했을 때 제어권이 넘어가서 다른 작업이 끝나고 제어권이 돌아오면 작업을 시작하는 것을 의미합니다. 

요청에 대한 결과가 처리될때 까지 결과를 기다리게 됩니다. 결과가 돌아올때 까지 자신의 작업을 수행할 수 없습니다. 

* 호출자가 자신의 행위가 호출한 다른 행위로 이해 막혀버렸다는 의미

**A 함수**가 **B 함수**를 호출하면, **제어권을 A가 호출한 B 함수에 넘겨준다.**

<img src="https://blog.kakaocdn.net/dn/u9ebj/btsbSd273mN/OEVaKXwl9ZVmkJ85rOSn4k/img.png" width = 500 height =500>

1. A함수가 B함수를 호출하면 B에게 제어권을 넘긴다.
2. 제어권을 넘겨받은 B는 열심히 함수를 실행한다. A는 B에게 제어권을 넘겨주었기 때문에 함수 실행을 잠시 멈춘다.
3. B함수는 실행이 끝나면 자신을 호출한 A에게 제어권을 돌려준다.

피호출자로부터 호출자로 제어권이 돌아오면 그제서야 작업을 다시 시작할 수 있습니다.



장점:

- 결과값을 반환할 때까지 기다리기 때문에, 결과값을 활용하여 작업을 처리할 수 있습니다.
- 코드가 간단하고 직관적입니다.

단점:

- 결과값을 반환할 때까지 대기해야 하기 때문에, 다른 작업을 수행할 수 없습니다. 이로 인해 전체 시스템 성능이 저하될 수 있습니다.
- 데드락(deadlock) 문제가 발생할 수 있습니다. 데드락은 각각의 프로세스가 서로 상대방의 작업이 완료될 때까지 대기하면서 멈추어 있는 상태를 말합니다.

따라서 블로킹 방식은 코드가 간단하고 직관적이지만, 대기 시간과 데드락 문제 등의 단점이 있어서 대규모 시스템에서는 사용이 제한적입니다.

# 논블로킹 (Non-Blocking)

자신의 작업을 진행하다가, 다른 작업을 호출하더라도, 제어권은 호출자가 가지고 있어 기존 작업을 계속 수행할 수 있습니다. 

* 피 호출자는 멀티스레드나 콜백함수를 이용해 작업을 스레드 각각이 제어권을 가지고 따로 수행합니다.
* 논블로킹(Non-blocking) 방식에서는 결과값을 바로 사용할 수 없기 때문에, 비동기(Asynchronous) 방식과 결합하여  작업이 완료될 때 호출되는 콜백 함수(callback function)를 이용하여 결과값을 처리합니다. 콜백 함수는 비동기 함수가 완료된 후 자동으로 호출되는 함수입니다.

* **A 함수**가 **B 함수**를 호출해도 **제어권은 그대로 자신이 가지고 있는다**

<img src="https://blog.kakaocdn.net/dn/dlZ5ig/btsbXJe984M/owi4h8E4u5wLNk7Y3mKvY1/img.png" width = 400 height = 450>

1. A함수가 B함수를 호출하면, B 함수는 실행되지만, **제어권은 A 함수가 그대로 가지고 있는다.**
2. A함수는 계속 제어권을 가지고 있기 때문에 B함수를 호출한 이후에도 자신의 코드를 계속 실행한다.

블로킹과 마찬가지로 호출할 때 제어권을 넘겨주기는 하지만 바로 돌려받습니다. 제어권을 바로 돌려받아서 가지고 있기 때문에 계속해서 다른 작업을 할 수 있습니다.



장점:

- 대기하지 않고 다음 작업을 수행하기 때문에, 전체적인 성능이 향상됩니다.
- 서버 부하가 많을 때도 대기 시간이 상대적으로 짧습니다.
- 비동기 처리와 결합하면 성능을 더욱 개선할 수 있습니다.

단점:

- 결과값을 바로 사용할 수 없기 때문에, 코드가 복잡해질 수 있습니다.
- 작업 순서가 보장되지 않기 때문에, 일관성 있는 처리를 보장하기 어렵습니다.
- 작업에 대한 콜백 함수를 정의해야 하기 때문에, 코드의 가독성이 저하될 수 있습니다.

따라서 논블로킹 방식은 대규모 시스템에서 효율적인 성능 향상을 가져올 수 있으나, 코드가 복잡해지고 일관성 유지에 어려움이 있을 수 있습니다.

## 차이점

### 동기(Synchronous) vs 비동기(Asynchronous) 차이점

1. 결과 반환 시점

   - 동기 방식은 함수나 작업이 완료될 때까지 대기하면서 결과를 반환합니다.

   - 비동기 방식은 함수나 작업이 완료될 때까지 기다리지 않고 다음 작업을 수행하며, 결과값을 반환하지 않을 수도 있습니다.

2. 코드 흐름
   - 동기 방식은 호출된 작업이 완료될 때까지 코드의 흐름이 멈추고 대기하지만 비동기 방식은 호출된 함수나 작업이 완료될 때까지 코드의 흐름이 멈추지 않고 다음 작업을 수행합니다.

3. 병렬 처리

   - 동기 방식은 함수나 작업이 완료될 때까지 다른 작업을 수행하지 못하므로, 병렬 처리가 어렵습니다.

   - 비동기 방식은 함수나 작업이 완료되지 않아도 다른 작업을 수행할 수 있기 때문에, 병렬 처리가 가능합니다.

4. 코드의 복잡도
   - 동기 방식은 직관적인 코드지만, 비동기 방식은 콜백 함수 등을 사용하여 코드가 복잡해질 수 있습니다.

따라서 동기와 비동기는 결과 반환 시점, 코드 흐름, 병렬 처리, 코드의 복잡도 등에서 차이가 있으며, 적절한 방식을 선택하는 것이 중요합니다.

### Non-Blocking Vs ASynchronous 차이점

- Asynchronous은 **요청에 처리 완료와 관계없이 응답한다. 이후 운영체제에서 응답할 준비가 되면 응답한다.**
- Non-Blocking은 **요청에 처리할 수 있으면 바로 응답하고 아니면 Error를 반환한다.**
- 논블로킹 방식은 입출력 작업의 블로킹을 최소화하여 대기시간을 최소화하는 방식이며, 비동기 방식은 결과값을 반환하지 않는 방식으로 대기시간을 최소화하는 방식

논블로킹과 비동기는 서로 다른 개념이지만, 둘 다 입출력 작업의 대기시간을 최소화하기 위한 방법 
논블로킹 방식은 입출력 작업 중 다른 작업을 수행할 수 있도록 허용하는 방식이며, 
비동기 방식은 결과값을 바로 반환하지 않는 방식으로 대기시간을 최소화하는 방식입니다.

### Blocking Vs Synchronous 차이점

*Wait Queue 유무*

- Blocking은 **System Call의 Return을 기다리는 동안 필수로 Wait Queue에 머문다.**
  - 블로킹은 제어권이 넘어가서 다른 작업을 수행못하는 작업(프로세스 또는 스레드)을 큐에 저장한다.
- Synchronous은 **System Call의 Return을 기다리는 동안 Wait Queue에 머물 수도 아닐 수도 있다.**
  - 동기는 호출한 함수가 작업이 완료될때까지 기다린다.



# 동기와 비동기의 조합

동기 & 비동기와 블로킹 & 논 블로킹은 개념이 달라서 조합하여 사용할 수 있습니다.

### 1. Sync-Blocking

제어권이 넘어갔고, 순서대로 진행됩니다. 

<img src="https://blog.kakaocdn.net/dn/DH4wp/btsbVd8EPf3/otuV9znsXvlv2ejpH1xh91/img.png" width = 400 height = 400>

- 함수는 다른 함수의 리턴값을 고려해서 동작한다. (동기)

- 함수는 다른 함수에게 제어권을 넘겨주고 대기한다. (블로킹)

- 제어권을 함수 B에게 넘겨주고, 함수 B가 실행을 완료하여 리턴값과 제어권을 돌려줄때까지 **기다린다** (**블로킹**).


일반적으로 우리가 작성하는 코드가 sync-blocking 방식입니다. 

### 2. Sync-NonBlocking

제어권이 넘어가진 않았지만, 순서대로 진행되어야 하기 때문에 계속적으로 작업완료를 확인합니다. 

<img src="https://blog.kakaocdn.net/dn/cpRVMD/btsbUpIetpp/t6m6IiSkg95f9Y7uvh18g0/img.png" width = 400 height = 450>

- 함수는 다른 함수의 리턴값을 고려해서 동작한다. (동기)

- 함수는 다른 함수에게 제어권을 주지 않고 자신의 코드를 계속 실행한다. (논 블로킹)

  이 때 **A 함수는 B 함수에게 제어권을 주지 않고**, **자신의 코드를 계속 실행한다** (**논블로킹**).

  그런데 **A 함수는 B 함수의 리턴값이 필요하기 때문**에, **중간중간 B 함수에게 함수 실행을 완료했는지 물어본다**(관측) (**동기**).

### 3. Async-Blocking

순서대로 진행되지 않아도 되지만 제어권이 넘어갔기 때문에 호출자는 더 진행하지 못하므로 대기 시간 발생합니다. 

<img src="https://blog.kakaocdn.net/dn/bI25a3/btsb5lLFUEx/n8r8PbuuV4EzLbx5KLQK31/img.png" width = 400 height =450>



- 함수는 다른 함수의 리턴 값을 고려하지 않고 동작(비동기)하지만 다른 함수에게 제어권을 넘겨주고 대기한다. (블로킹)

- A 함수는 B 함수의 리턴값에 신경쓰지 않고, 콜백함수를 보낸다 (**비동기**).

  그런데, B 함수의 작업에 관심없음에도 불구하고, A 함수는 B 함수에게 <u>제어권</u>을 넘긴다 (**블로킹**).

  따라서, A 함수는 자신과 관련 없는 B 함수의 작업이 끝날 때까지 기다려야 한다.



Sync-Blocking과 비교했을 때 이점이 없기 때문에 거의 사용되지 않는다. -> 의도치 않게 실수로 사용된다.

Async-blocking의 경우 sync-blocking과 성능의 차이가 거의 없기 때문에 사용하는 경우는 거의 없다.

### 4. Async-NonBlocking

제어권이 넘어가진 않았지만, 순서대로 진행되지 않아도 되기 때문에 호출하고 작업을 하고 있다가 완료 시 콜백

<img src="https://blog.kakaocdn.net/dn/blMhex/btsb6ZuUOdm/n1ZGwNnIbeyMQMABs6VoZ0/img.png" width = 400 height =450>



- 함수는 다른 함수의 리턴 값을 고려하지 않고 동작한다. (비동기)

- 함수는 다른 함수에게 제어권을 주지 않고 자신의 코드를 계속 실행한다. (논 블로킹)

- A 함수는 B 함수를 호출한다.

  이 때 **제어권을** B 함수에 주지 않고, **자신이 계속 가지고 있는다.** 따라서 B 함수를 호출한 이후에도 멈추지 않고 **자신의 코드를 계속 실행**한다. (**논블로킹**)

  그리고 B 함수를 호출할 때 **콜백함수**를 함께 준다. B 함수는 **자신의 작업이 끝나면** A 함수가 준 **콜백 함수를 실행**한다 (**비동기**).



함수가 다른 함수를 호출할 때 제어권을 주지 않고 자신의 코드를 계속 실행한다. 

함수가 다른 함수를 호출할 때 콜백함수를 함께 줘서 다른 함수는 자신의 작업을 처리하면 콜백 함수를 실행한다.

> **NonBlocking-Async 방식을 쓰는데 그 과정 중에 하나라도 Blocking으로 동작하는 놈이 포함되어 있다면 의도하지 않게 Blocking-Async로 동작**할 수 있다.

* AJAX 요청 / JS 비동기 콜백에 사용됩니다.

- 또, Spring의 Reactive Web 프로그래밍이 있습니다.
- 클라이언트에서 비동기 방식으로 요청을 보내면, Spring은 이를 Mono나 Flux와 같은 리액티브 타입으로 변환합니다.
- 이후 요청 처리를 위한 작업을 non-blocking 방식으로 백그라운드에서 수행하고, 이때 Mono나 Flux와 같은 리액티브 타입을 반환합니다.

<img src="https://blog.kakaocdn.net/dn/bhCDkb/btsb1PTN2HD/UKc0SkzzNxSP9lyookHr80/img.png" width = 900 height = 500>

### 참조

* http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/

* https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-2-%EB%B8%94%EB%A1%9C%ED%82%B9%EA%B3%BC-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-e11b3d01fdf8

* https://wildeveloperetrain.tistory.com/104

* https://jaehoney.tistory.com/242

* https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0